var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @namespace Takeaway
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  // Needs to put in correct order
  exports.Cache = require('./Cache');
  exports.Utils = require('./Utils');
  exports.ServerDateTime = require('./ServerDateTime');
  exports.Category = require('./Category');
  exports.TimeWindow = require('./TimeWindow');
  exports.PaymentMethod = require('./PaymentMethod');
  exports.DeliveryArea = require('./DeliveryArea');
  exports.DeliveryMethod = require('./DeliveryMethod');
  exports.Discount = require('./Discount');
  exports.ActiveDiscount = require('./ActiveDiscount');
  exports.Restaurant = require('./Restaurant');
  exports.Product = require('./Product');
  exports.ProductSize = require('./ProductSize');
  exports.SideDish = require('./SideDish');
  exports.AutoAddProduct = require('./AutoAddProduct');
  exports.Voucher = require('./Voucher');
  exports.Basket = require('./Basket');
} else {
  var Takeaway = Takeaway || {};
}
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global Takeaway */
/**
 * The date of the server
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.ServerDateTime
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var moment = require('moment');
}
(function (global) {
  'use strict';

  /**
   * Constructor
   * @param {moment} time the server time
   * @param {int} day week day
   */

  var ServerDateTime = function ServerDateTime(time, day) {
    this.time = time;
    this.weekDay = day;
  };
  /**
   * Current server date and time.
   * @property {moment}
   */
  ServerDateTime.prototype.time;
  /**
   * Current day of the week according to the server
   * @property {int}
   */
  ServerDateTime.prototype.weekDay;

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = ServerDateTime;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.ServerDateTime = ServerDateTime;
  } else {
    Takeaway.ServerDateTime = ServerDateTime;
  }
})(undefined);
/* global Takeaway */
/**
 * Static class to save temporary data.
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Cache
 */
(function (global) {
  'use strict';

  var Cache = function Cache() {};

  /**
   * @property {ServerDateTime} ServerDateTime
   */
  Cache.serverDateTime;

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Cache;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Cache = Cache;
  } else {
    Takeaway.Cache = Cache;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global Takeaway */
/**
 * Holds the date, day of the week, start en end time.
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.TimeWindow
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var moment = require('moment');
}
(function (global) {
  'use strict';

  var TimeWindow = function TimeWindow() {};

  /**
   * @property {moment} date e.g. 2017-08-15. This will be used for exception time.
   */
  TimeWindow.prototype.date;
  /**
   * @property {int} week day 0 Sunday, 6 Saturday,
   */
  TimeWindow.prototype.weekDay;
  /**
   * @property {moment} start time for e.g. 08:00.
   */
  TimeWindow.prototype.startTime;
  /**
   * @property {moment} end time for e.g. 19:00.
   */
  TimeWindow.prototype.endTime;

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = TimeWindow;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.TimeWindow = TimeWindow;
  } else {
    Takeaway.TimeWindow = TimeWindow;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * The category for the products
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Category
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var Category = function Category() {
    this.orderTimes = [];
    this.exceptionTimes = [];
  };

  /**
   * @enum Restaurant OpeningStatus
   * @property {Number} OpeningStatus.Closed Restaurant is closed.
   * @property {Number} OpeningStatus.Open Restaurant is open.
   * @property {Number} OpeningStatus.PreOrder Restaurant can be preordered.
   */
  Category.Status = Object.freeze({
    Closed: 0,
    Open: 1,
    PreOrder: 2
  });

  /**
   * @property {string} id of the category.
   */
  Category.prototype.id;
  /**
   * @property {Array<TimeWindow>} ordertimes.
   */
  Category.prototype.orderTimes;
  /**
   * @property {Array<TimeWindow>} exceptionTimes.
   */
  Category.prototype.exceptionTimes;
  /**
   * The status of the category.
   * @property {Category.Status} status
   */
  Category.prototype.status;
  /**
   * The current time the category is now. For multiple order times. It will pick the last one.
   * This is kinda stupid in the code.
   */
  Category.prototype.currentOrderTime;
  /**
   * List of product ids.
   * @property {Array<string>}
   */
  Category.prototype.productIds;

  /**
   * Validate order time. If there is no order time, it means it should be available.
   * The result will be set on status.
   * @param {moment} time the time
   * @param {int} weekDay the day of the week
   * @return {Category.Status} The status of the category.
   */
  Category.prototype.validateOrderTime = function (time, weekDay) {
    var orderTimes = [];
    // Check if there is an exception time for today
    if (this.exceptionTimes.length > 0) {
      var date = Takeaway.Utils.getDate(time);
      orderTimes = this.exceptionTimes.filter(function (exceptionTime) {
        return exceptionTime.date.isSame(date);
      });
    }

    // Do regular times if there are no exception times.
    if (orderTimes.length === 0) {
      orderTimes = this.orderTimes.filter(function (orderTime) {
        return orderTime.weekDay === weekDay;
      });
    }

    var status = Takeaway.Category.Status.Open;
    if (orderTimes.length > 0) {
      status = Takeaway.Category.Status.Closed;
      for (var x in orderTimes) {
        var orderTime = orderTimes[x];
        this.currentOrderTime = orderTime; // argghhh this shouldn't be here
        var startTime = Takeaway.Utils.timeToToday(orderTime.startTime, time);
        var endTime = Takeaway.Utils.timeToToday(orderTime.endTime, time);

        // If category is set to 00:00 then the category is not available.
        if (Takeaway.Utils.getSeconds(startTime) === 0 && Takeaway.Utils.getSeconds(endTime) === 0) {
          return Takeaway.Category.Status.Closed;
        }

        var timeStatus = Takeaway.Utils.checkTimeBetween(orderTime, time, time);
        if (timeStatus === Takeaway.Utils.TimeStatus.Before) {
          return Takeaway.Category.Status.PreOrder;
        }

        if (timeStatus === Takeaway.Utils.TimeStatus.Between) {
          return Takeaway.Category.Status.Open;
        }
      }
    }
    return status;
  };

  /**
   * Validate the category by server date time. The result will be in Category.status.
   * @param {ServerDateTime} serverDateTime The time + weekday from the server.
   * @return {Category.Status} The status of the category.
   */
  Category.prototype.validateOrderTimeByServerTime = function (serverDateTime) {
    return this.status = this.validateOrderTime(serverDateTime.time, serverDateTime.weekDay);
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Category;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Category = Category;
  } else {
    Takeaway.Category = Category;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global Takeaway */

if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var moment = require('moment');
}
(function (global) {
  'use strict';

  var Utils = function Utils() {};

  Utils.intervalStartTime = moment({ hour: 0, minute: 0, second: 0, millisecond: 0 });
  Utils.intervalEndTime = moment({ hour: 7, minute: 0, second: 0, millisecond: 0 });

  Utils.TimeStatus = Object.freeze({
    Before: 1,
    Between: 2,
    After: 3
  });

  Utils.possibleCashPayments = [];
  Utils.denominationsDefault = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50];
  Utils.denominationsCH = [0.10, 0.20, 0.50, 1, 2, 5, 10, 20, 50, 100];
  Utils.denominationsVN = [1000, 2000, 5000, 20000, 50000, 100000, 200000, 500000];

  /**
   * Converts date string into Unix timestamp. Example date: "16 Apr 2020 12:43:08 GMT"
   * @param date
   * @returns {number}
   */
  Utils.dateToTimestamp = function (date) {
    return Number(moment(date).format('x'));
  };

  /**
   * A hack to avoid floating points.
   * @param {number} value The number that needs to be checked on.
   * @param {number} decimals The length after the comma/point.
   * @return {number} The number rounded on the given decimals.
   */
  Utils.toMoney = function (value, decimals) {
    var str = value.toString();
    var n = str.lastIndexOf('.');

    if (n !== -1) {
      str = str.substr(n, str.length);
      if (str.length >= 4 && str[3] === '5') {
        value += 0.001;
      }
    }
    return parseFloat(value.toFixed(decimals));
  };

  /**
   * Get the money denomination by country code.
   * The current country code can be found with window.GeoCountryCode or check site.inc.php.
   * @param {int} countryCode the code of the country.
   * @return {array} denomination according the country code.
   */
  Utils.getDenominations = function (countryCode) {
    switch (countryCode) {
      case 6:
        // CH
        return Utils.denominationsCH;
      case 239:
        // VN
        return Utils.denominationsVN;
      default:
        return Utils.denominationsDefault;
    }
  };

  /**
   * Get the possible cash payments
   * @param price The number the needs to be calculated on.
   * @param denominations Utils.denominationsDefault, denominationsCH pr denominationsVN
   * @return {Array<float>} Ascending sorted possible cash payments.
   */
  Utils.getPossibleCashPayments = function (price, denominations) {
    Utils.possibleCashPayments = [];
    var denominations2 = denominations;
    var currentMoney = 0;

    // add exact value first
    Utils.possibleCashPayments.push(price);

    for (var i = 0; i < denominations.length; i++) {
      var denomination = denominations[i];
      currentMoney = Utils.toMoney(Math.ceil(price / denomination) * denomination, 2);
      var part1 = currentMoney;
      var filtered = Utils.possibleCashPayments.filter(function (cash) {
        return part1 === cash;
      });

      if (filtered.length === 0) {
        Utils.possibleCashPayments.push(part1);
      }
      part1 = 0;

      var lower = Utils.toMoney(Math.floor(price / denomination) * denomination, 2);
      for (var ii = 0; ii < denominations2.length - 1; ii++) {
        var denomination2 = denominations2[ii];
        if (denomination2 <= denomination) {
          currentMoney = Utils.toMoney(lower + Math.ceil((price - lower) / denomination2) * denomination2, 2);
          var part2 = currentMoney;
          var filtered2 = Utils.possibleCashPayments.filter(function (cash) {
            return part2 === cash;
          });
          if (filtered2.length === 0) {
            Utils.possibleCashPayments.push(part2);
          }
          part2 = 0;
        }
      }
    }
    Utils.possibleCashPayments.sort(function (a, b) {
      return a - b;
    });
    return Utils.possibleCashPayments;
  };

  /**
   * Set the time into the current time.
   * @property {moment} time
   * @property {moment} currentTime
   * @return {moment} the converted time.
   */
  Utils.timeToToday = function (time, currentTime) {
    return currentTime.clone().set({
      hours: time.hours(),
      minutes: time.minutes(),
      seconds: 0
    });
  };

  /**
   * Set the date into the current time.
   * @property {moment} date
   * @return {moment} the converted date.
   */
  Utils.getDate = function (date) {
    return moment({
      year: date.year(),
      month: date.month(),
      date: date.date()
    });
  };

  /**
   * Pass moment and get seconds back.
   * @param {moment} time
   * @return {long} time in seconds
   */
  Utils.getSeconds = function (time) {
    return (time.hours() * 60 + time.minutes()) * 60;
  };

  /**
   * If the time is after midnight and before 07.00, then day will the yesterday.
   *
   * Note: The function is globally exposed
   *
   * @param {long} timestamp
   * @return {object}
   */
  Utils.normalizeServerTime = function (timestamp) {
    var time = moment(timestamp);
    var hours = time.hours();

    // Between 00:00 and 07:00
    if (hours >= Utils.intervalStartTime.hours() && hours < Utils.intervalEndTime.hours()) {
      time.add(-1, 'days');
    }
    return { time: time, weekDay: time.day() };
  };

  /**
   * Check if the time is between two times.
   * @param {TimeWindow} timeWindow contains the start and end time.
   * @param {moment} compareTime the time that you want to check.
   * @param {moment} serverTime the time that is passed from the server.
   */
  Utils.checkTimeBetween = function (timeWindow, compareTime, serverTime) {
    // Convert time to sever time.
    var startTime = Utils.timeToToday(timeWindow.startTime, serverTime);
    var endTime = Utils.timeToToday(timeWindow.endTime, serverTime);

    // Convert time in seconds
    var serverSec = Utils.getSeconds(serverTime);
    var startSec = Utils.getSeconds(timeWindow.startTime);
    var endSec = Utils.getSeconds(timeWindow.endTime);
    var compareSec = Utils.getSeconds(compareTime);
    var intervalStartSec = Utils.getSeconds(Utils.intervalStartTime);
    var intervalEndSec = Utils.getSeconds(Utils.intervalEndTime);

    // Midnight
    var isMidnight = false;
    if (serverSec > intervalStartSec && compareSec < intervalEndSec) {
      isMidnight = true;
    }

    // It is not midnight, but maybe the start time is.
    if (!isMidnight && startSec >= intervalStartSec && startSec < intervalEndSec) {
      startTime.add(1, 'days');
    } else if (isMidnight && startSec > intervalStartSec && startSec < intervalEndSec) {
      // it means the server and start time are midnight and don't need to do any fancy stuff.
    } else if (isMidnight) {
      // it is midnight, but the start time isn't.
      startTime.add(-1, 'days');
    }

    // It is not midnight, but maybe the end time is.
    if (!isMidnight && endSec >= intervalStartSec && endSec < intervalEndSec) {
      endTime.add(1, 'days');
    } else if (isMidnight && endSec > intervalStartSec && endSec < intervalEndSec) {
      // it means the server and end time is midnight and don't need to do any fancy stuff.
    } else if (isMidnight) {
      // it is midnight, but the end time isn't.
      endTime.add(-1, 'days');
    }

    if (compareTime.isBefore(startTime)) {
      return Utils.TimeStatus.Before;
    } else if (compareTime.isBetween(startTime, endTime) || compareTime.isSame(startTime) || compareTime.isSame(endTime)) {
      return Utils.TimeStatus.Between;
    } else if (compareTime.isAfter(endTime)) {
      return Utils.TimeStatus.isAfter;
    }
  };

  /**
   * Extend Number object with method to convert numeric degrees to radians
   */
  if (Number.prototype.toRadians === undefined) {
    // eslint-disable-next-line no-extend-native
    Number.prototype.toRadians = function () {
      return this * Math.PI / 180;
    };
  }

  /**
   * Calculate distance between two points
   * This uses the ‘haversine’ formula to calculate the great-circle distance between two
   * points – that is, the shortest distance over the earth’s surface – giving an
   * ‘as-the-crow-flies’ distance between the points (ignoring any hills they fly over,
   * of course!).
   */
  Utils.calculateDistance = function (lat1, lon1, lat2, lon2) {
    var R = 6371e3; // metres
    var φ1 = lat1.toRadians();
    var φ2 = lat2.toRadians();
    var Δφ = (lat2 - lat1).toRadians();
    var Δλ = (lon2 - lon1).toRadians();

    var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    var d = R * c;
    return d;
  };

  /**
   * Backend sends string and/or number values :( We want to use a strict check
   * @param value
   * @returns {boolean}
   */
  Utils.isZero = function (value) {
    return value === 0 || value === '0';
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Utils;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Utils = Utils;
  } else {
    Takeaway.Utils = Utils;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.PaymentMethod
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var PaymentMethod = function PaymentMethod(obj) {
    if (obj !== undefined) {
      for (var prop in obj) {
        this[prop] = obj[prop];
      }
    }
  };

  // This sucks
  PaymentMethod.ID = Object.freeze({
    Cash: '0',
    Voucher: '13'
  });

  /**
   * @property {String} id
   * e.g.
   * iDEAL 3
   * Visa 6_1
   * Mastercard 6_2
   */
  PaymentMethod.prototype.id;
  /**
   * @property {String} id
   * Only for payment methods that contain sub ids
   * e.g. Creditcard has Visa, Mastercard and American Express. Main id would be 6 then.
   */
  PaymentMethod.prototype.mainId;
  /**
   * @property {String} id
   * Only for payment methods that contain sub ids
   * e.g. Creditcard has Visa (1), Mastercard (2) and American Express (3). Main id would be 6 then.
   */
  PaymentMethod.prototype.subId;
  PaymentMethod.prototype.name;
  PaymentMethod.prototype.transactionFixed;
  PaymentMethod.prototype.transactionPercentage;

  /**
   * Calculate transaction costs.
   * @param {float} price the price the transaction costs needs to be calculated on.
   * @return {float} transaction costs.
   */
  PaymentMethod.prototype.calculateTransactionCosts = function (price) {
    if (price === 0) {
      return 0;
    }
    if (this.transactionFixed === undefined) {
      return 0;
    }
    var costs = 0;
    if (this.transactionFixed === 0) {
      if (this.transactionPercentage !== 0) {
        costs = price * this.transactionPercentage / 100;
      }
    } else {
      costs = this.transactionFixed;
    }

    if (costs !== 0) {
      costs = Takeaway.Utils.toMoney(parseFloat(costs), 2);
    }

    return costs;
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = PaymentMethod;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.PaymentMethod = PaymentMethod;
  } else {
    Takeaway.PaymentMethod = PaymentMethod;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global Takeaway */
/**
 * The delivery area which contains the delivery costs
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.DeliveryArea
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'user strict';

  var DeliveryArea = function DeliveryArea() {};

  /**
   * Delivery area id, for example 8889, 8888-alpha
   */
  DeliveryArea.prototype.id;
  /**
   * @property {object} WARNING: it's an object literal from PHP!
   */
  DeliveryArea.prototype.deliveryCosts;
  DeliveryArea.prototype.minimumOrderAmount;
  // If this is zero, it means there is no free delivery.
  DeliveryArea.prototype.amountNeededForFreeDelivery;

  /**
   * Note: If this returns zero, it means there is no free delivery.
   * @returns {number}
   */
  DeliveryArea.prototype.getAmountNeededForFreeDelivery = function (deliveryCosts) {
    var costsWithZeroValueInUntilField = deliveryCosts.find(function (area) {
      return Takeaway.Utils.isZero(area.till);
    });

    if (costsWithZeroValueInUntilField) {
      var isCostAlsoZero = Takeaway.Utils.isZero(costsWithZeroValueInUntilField.costs);

      return isCostAlsoZero
      // There is "Free delivery" from XX amount (it's called 'from' in TMS)
      ? Number.parseFloat(costsWithZeroValueInUntilField.from)
      // There is no "Free delivery"
      : 0;
    } else {
      // Get the maximum till value for the area
      return Math.max.apply(Math, _toConsumableArray(deliveryCosts.map(function (o) {
        return o.till;
      })));
    }
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = DeliveryArea;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.DeliveryArea = DeliveryArea;
  } else {
    Takeaway.DeliveryArea = DeliveryArea;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Restaurant
 * The restaurant.
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}
(function (global) {
  'use strict';

  // TODO normally Restaurant should have Basket object, but the code in this project doesn't make any sense.
  // TODO or even better use the Repository pattern to decouple the models.

  var Restaurant = function Restaurant() {
    this.openingTimes = [];
    this.pickupOpeningTimes = [];
    this.exceptionTimes = [];
    this.pickupExceptionTimes = [];
    this.deliveryAreas = [];
    this.categories = [];
    this.autoAddProducts = [];
    this.discounts = [];
    this.paymentMethods = [];
  };

  /**
   * @enum Restaurant OpeningStatus
   * @property {Number} OpeningStatus.Closed Restaurant is closed.
   * @property {Number} OpeningStatus.Open Restaurant is open.
   * @property {Number} OpeningStatus.PreOrder Restaurant can be preordered.
   */
  Restaurant.OpeningStatus = Object.freeze({
    Closed: 0,
    Open: 1,
    PreOrder: 2
  });

  Restaurant.prototype.id;
  Restaurant.prototype.name;
  Restaurant.prototype.postcode;
  Restaurant.prototype.url;
  Restaurant.prototype.cartUrl;
  Restaurant.prototype.orderUrl;
  Restaurant.prototype.domain;
  /**
   * @property {Restaurant.OpeningStatus} onlineStatus The opening status independed from the time.
   */
  Restaurant.prototype.onlineStatus;
  /**
   * @property {Restaurant.OpeningStatus} openingStatus The opening status calculated with time.
   */
  Restaurant.prototype.openingStatus;
  /**
   * @property {Array<TimeWindow>} openingTimes
   */
  Restaurant.prototype.openingTimes;
  /**
   * @property {Array<TimeWindow>} pickupOpeningTimes
   */
  Restaurant.prototype.pickupOpeningTimes;
  /**
   * @property {Array<TimeWindow>} exceptionTimes
   */
  Restaurant.prototype.exceptionTimes;
  /**
   * @property {Array<TimeWindow>} pickupExceptionTimes
   */
  Restaurant.prototype.pickupExceptionTimes;
  /**
   * @property {Array<DeliveryArea>} deliveryAreas
   */
  Restaurant.prototype.deliveryAreas;
  /**
   * @property {DeliveryMethod.Type} deliveryType the restaurant supports
   */
  Restaurant.prototype.deliveryType;
  /**
   * @property {string} Current delivery area id
   */
  Restaurant.prototype.deliveryAreaId;

  Restaurant.prototype.categories;
  Restaurant.prototype.amountNeededForFreeDelivery;
  Restaurant.prototype.autoAddProducts;
  Restaurant.prototype.discounts;
  Restaurant.prototype.paymentMethods;
  /**
   * WARNING OBJECT LITERAL FROM PHP
   */
  Restaurant.prototype.translations = {};
  /**
   * WARNING OBJECT LITERAL FROM PHP
   */
  Restaurant.prototype.currency;

  /**
   * Get the opening status of the restaurant according the server time. The result will be set on openingStatus.
   * @param {ServerDateTime} serverDateTime time and weekday from the server.
   * @param {DeliveryMethod.Type} deliveryType the delivery type the status needs to check on.
   * @return {Restaurant.OpeningStatus} the status of the opening.
   */
  Restaurant.prototype.getOpeningStatus = function (serverDateTime, deliveryType) {
    var openingTimes = [];
    // Check if there is an exception time for today.
    if (this.exceptionTimes.length > 0 || this.pickupExceptionTimes.length > 0) {
      var times = deliveryType === Takeaway.DeliveryMethod.Type.Delivery ? this.exceptionTimes : this.pickupExceptionTimes;
      var date = Takeaway.Utils.getDate(serverDateTime.time);
      openingTimes = times.filter(function (exceptionTime) {
        return exceptionTime.date.isSame(date, 'date');
      });
    }

    // Do the regular times if there are no exception times.
    if (openingTimes.length === 0) {
      var _times = deliveryType === Takeaway.DeliveryMethod.Type.Delivery ? this.openingTimes : this.pickupOpeningTimes;
      openingTimes = _times.filter(function (openingTime) {
        return openingTime.weekDay === serverDateTime.weekDay;
      });
    }

    for (var x in openingTimes) {
      var openingTime = openingTimes[x];
      var startTime = Takeaway.Utils.timeToToday(openingTime.startTime, serverDateTime.time);
      var endTime = Takeaway.Utils.timeToToday(openingTime.endTime, serverDateTime.time);

      // if opening time is set to 00:00 then the restaurant is closed.
      if (Takeaway.Utils.getSeconds(startTime) === 0 && Takeaway.Utils.getSeconds(endTime) === 0) {
        this.openingStatus = Restaurant.OpeningStatus.Closed;
        return this.openingStatus;
      }

      var timeStatus = Takeaway.Utils.checkTimeBetween(openingTime, serverDateTime.time, serverDateTime.time);
      if (timeStatus === Takeaway.Utils.TimeStatus.Before) {
        this.openingStatus = Restaurant.OpeningStatus.PreOrder;
        return this.openingStatus;
      } else if (timeStatus === Takeaway.Utils.TimeStatus.Between) {
        this.openingStatus = Restaurant.OpeningStatus.Open;
        return this.openingStatus;
      } else {
        this.openingStatus = Restaurant.OpeningStatus.Closed;
      }
    }
    return this.openingStatus;
  };

  /**
   * Is the restaurant closed or not.
   * getOpeningStatus() should have been called before this method.
   * @return {boolean} Whether the restaurant is closed or not.
   */
  Restaurant.prototype.isClosed = function () {
    if (this.onlineStatus === Takeaway.Restaurant.OpeningStatus.Closed || this.openingStatus === Takeaway.Restaurant.OpeningStatus.Closed) {
      return true;
    }
    return false;
  };

  /**
   * Get the category by id.
   * @param {string} id of the category.
   * @return {Takeaway.Category} the category object.
   */
  Restaurant.prototype.getCategoryById = function (id) {
    return this.categories.filter(function (category) {
      return id === category.id;
    })[0];
  };

  /**
   * Validate all category times whether they are open or closed.
   * Not the best place to put it here. Something like MenuRepository would be handy.
   * @param {ServerDateTime} serverDateTime
   */
  Restaurant.prototype.validateCategoriesOrderTime = function (serverDateTime) {
    for (var x in this.categories) {
      var category = this.categories[x];
      category.validateOrderTimeByServerTime(serverDateTime);
    }
  };

  /**
   * Get the delivery area by id.
   * @param {string} id of the delivery area.
   * @return {Takeaway.DeliveryArea} the delivery area object.
   */
  Restaurant.prototype.getDeliveryAreaById = function (id) {
    return this.deliveryAreas.filter(function (deliveryArea) {
      return id === deliveryArea.id;
    })[0];
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Restaurant;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Restaurant = Restaurant;
  } else {
    Takeaway.Restaurant = Restaurant;
  }
})(undefined);
/* global Takeaway */
/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.DeliveryMethod
 */
(function (global) {
  'use strict';

  var DeliveryMethod = function DeliveryMethod() {};

  /**
   * @enum DeliveryMethod.Type
   * @property {Number} Type.Delivery
   * @property {Number} Type.DeliveryAndPickup
   * @property {Number} Type.Pickup
   */
  DeliveryMethod.Type = Object.freeze({
    Delivery: 1,
    DeliveryAndPickup: 2,
    Pickup: 3
  });

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = DeliveryMethod;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.DeliveryMethod = DeliveryMethod;
  } else {
    Takeaway.DeliveryMethod = DeliveryMethod;
  }
})(undefined);
/* global Takeaway */
/**
 * Sidedish aka addition. It can and it should be extended from a general product entity.
 * @author Ka Wing Chin
 * @class Takeaway.SideDish
 */
(function (global) {
  'use strict';

  var SideDish = function SideDish(obj) {
    if (obj !== undefined) {
      for (var prop in obj) {
        this[prop] = obj[prop];
      }
    }
  };

  SideDish.prototype.id;
  SideDish.prototype.sideDishName;
  SideDish.prototype.price = 0;
  SideDish.prototype.pricePickup = 0;
  SideDish.prototype.ignoreMinimumOrderValue = false;

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = SideDish;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.SideDish = SideDish;
  } else {
    Takeaway.SideDish = SideDish;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.ProductSize
 * The product size
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var ProductSize = function ProductSize(obj) {
    this.sideDishes = [];
    if (obj !== undefined) {
      for (var prop in obj) {
        this[prop] = obj[prop];
      }
    }
  };

  ProductSize.prototype.id;
  ProductSize.prototype.sizeName;
  ProductSize.prototype.price = 0;
  ProductSize.prototype.pricePickup = 0;
  ProductSize.prototype.deliveryType;
  ProductSize.prototype.ignoreMinimumOrderValue = false;
  /**
   * @property {Array<SideDish>} An array of sidedishes.
   */
  ProductSize.prototype.sideDishes;

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = ProductSize;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.ProductSize = ProductSize;
  } else {
    Takeaway.ProductSize = ProductSize;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Product
 * The product that are placed in the basket.
 * To make it even better, there could be an entity for abstract products.
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var Product = function Product(obj) {
    if (obj !== undefined) {
      for (var prop in obj) {
        this[prop] = obj[prop];
      }
    }
  };

  /**
   * Maximum length for the comment.
   */
  Product.CommentMaxLength = 160;

  Product.prototype.uniqueId;
  Product.prototype.id;
  Product.prototype.count = 0;
  Product.prototype.productName;
  Product.prototype.comment = null;
  Product.prototype.categoryId = null;
  Product.prototype.deliveryType;
  /**
   * In the database is called is_meal which is by default true. In the parser the boolean is reverted.
   * It should make more sense if database returned is_not_meal and default would be false.
   * @property {boolean} ignoreMinimumOrderValue
   * @default false
   */
  Product.prototype.ignoreMinimumOrderValue = false;
  /**
   * Single delivery price without sidedish.
   */
  Product.prototype.basePrice = 0;
  /**
   * Single delivery price with sidedish.
   */
  Product.prototype.price = 0;
  /**
   * Base total delivery price without sidedish.
   */
  Product.prototype.baseTotalPrice = 0;
  /**
   * Total delivery price with sidedish.
   */
  Product.prototype.totalPrice = 0;
  /**
   * Single pickup price without sidedish.
   */
  Product.prototype.basePricePickup = 0;
  /**
   * Single pickup price with sidedish.
   */
  Product.prototype.pricePickup = 0;
  /**
   * Total pickup price without sidedish.
   */
  Product.prototype.baseTotalPricePickup = 0;
  /**
   * Total pickup price with sidedish.
   */
  Product.prototype.totalPricePickup = 0;
  /**
   * Total price with minimum order value.
   */
  Product.prototype.totalPriceMinimumOrder = 0;

  /**
   * @property ProductSize
   */
  Product.prototype.size = null;
  /**
   * @property {boolean} Wether the product is disabled. Used for unavailibility
   */
  Product.prototype.isDisabled = false;
  /**
   * @property {int} comboCounter A helper for the combination discount.
   * It tracks how many times the product can be used for a combination.
   */
  Product.prototype.comboCounter;

  /**
   * Update the total price of the base and side dish included.
   */
  Product.prototype.updateTotalPrice = function () {
    if (this.size === null) {
      this.price = this.basePrice;
      this.pricePickup = this.basePricePickup;
      if (!this.ignoreMinimumOrderValue) {
        this.totalPriceMinimumOrder = this.basePrice;
      }
    } else {
      this.price = this.size.price;
      this.pricePickup = this.size.pricePickup;

      if (!this.ignoreMinimumOrderValue) {
        this.totalPriceMinimumOrder = this.price;
      }

      for (var x in this.size.sideDishes) {
        var sideDish = this.size.sideDishes[x];
        this.price += sideDish.price;
        this.pricePickup += sideDish.pricePickup;
        if (!sideDish.ignoreMinimumOrderValue) {
          this.totalPriceMinimumOrder += sideDish.price;
        }
      }
    }

    // Round correctly.
    this.price = Takeaway.Utils.toMoney(this.price, 2);
    this.pricePickup = Takeaway.Utils.toMoney(this.pricePickup, 2);

    // TODO I think it is better do all the calculation in a getter.

    // Base total price
    this.baseTotalPrice = Takeaway.Utils.toMoney(parseFloat(this.basePrice * this.count), 2);
    this.baseTotalPricePickup = Takeaway.Utils.toMoney(parseFloat(this.basePricePickup * this.count), 2);

    // Total price included sidedishes
    this.totalPrice = Takeaway.Utils.toMoney(parseFloat(this.price * this.count), 2);
    this.totalPricePickup = Takeaway.Utils.toMoney(parseFloat(this.pricePickup * this.count), 2);

    // console.log(`${this.baseTotalPrice} : ${this.totalPrice}`);
    // console.log(`${this.baseTotalPricePickup} : ${this.totalPricePickup}`);
  };

  /**
   * Base price without sidedish.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   * @return {float}
   */

  /**
   * Base price without sidedish.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   * @return {float}
   */
  Product.prototype.getBasePrice = function (deliveryType) {
    // When a size is changed change the Baseprice of sizes
    if (deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      if (this.size && this.size.id) {
        return this.size.price;
      }
      return this.basePrice;
    } else if (deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      if (this.size && this.size.id) {
        return this.size.pricePickup;
      }
      return this.basePricePickup;
    }
    throw new Error('Wrong DeliveryType: ' + deliveryType + '. Use Takeaway.DeliveryMethod.Type');
  };
  /**
   * returns sizeId if exists otherwise it returns the productId
   * @returns {id}
   */
  Product.prototype.getId = function () {
    if (this.size && this.size.id) {
      return this.size.id;
    } else {
      return this.id;
    }
  };
  /**
   * lowers the ComboCounter of the product.
   * ComboCounter is used to for checking if the product can still be used for a discount
   * (after a reset it is the same as the count property)
   * @returns {boolean} - if it lowered the counter it returns true
   */
  Product.prototype.lowerComboCounter = function () {
    if (this.comboCounter) {
      this.comboCounter = this.comboCounter - 1;
      return true;
    }
  };
  /**
   * Price with sidedish.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   * @return {float}
   */
  Product.prototype.getPrice = function (deliveryType) {
    if (deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      return this.price;
    } else if (deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      return this.pricePickup;
    }
    throw new Error('Wrong DeliveryType: ' + deliveryType + '. Use Takeaway.DeliveryMethod.Type');
  };

  /**
   * Base total price without sidedish.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   * @return {float}
   */
  Product.prototype.getBaseTotalPrice = function (deliveryType) {
    if (deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      return this.baseTotalPrice;
    } else if (deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      return this.baseTotalPricePickup;
    }
    throw new Error('Wrong DeliveryType: ' + deliveryType + '. Use Takeaway.DeliveryMethod.Type');
  };

  /**
   * Total price with sidedish.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   * @return {float}
   */
  Product.prototype.getTotalPrice = function (deliveryType) {
    if (deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      return this.totalPrice;
    } else if (deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      return this.totalPricePickup;
    }
    throw new Error('Wrong DeliveryType: ' + deliveryType + '. Use Takeaway.DeliveryMethod.Type');
  };

  /**
   * Get the MOV with sidedish or not.
   * @param {boolean} inclusiveSidedishes
   * @param {Takeaway.DeliveryType} deliveryType
   * @return {float}
   */
  Product.prototype.getMinimumOrderValueTotalPrice = function (inclusiveSidedishes, deliveryType) {
    if (this.ignoreMinimumOrderValue) {
      return 0;
    }

    if (deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      return inclusiveSidedishes ? this.totalPriceMinimumOrder : this.basePrice;
    } else if (deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      return 0;
    }
    throw new Error('Wrong DeliveryType: ' + deliveryType + '. Use Takeaway.DeliveryMethod.Type');
  };

  /**
   * A helper for combination calculation.
   * Resets the combination counter.
   */
  Product.prototype.resetComboCounter = function () {
    this.comboCounter = this.count;
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Product;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Product = Product;
  } else {
    Takeaway.Product = Product;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin (kawing.chin@takeaway.com)
 * @class Takeaway.AutoAddProduct
 * @extends Takeaway.Product
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var AutoAddProduct = function AutoAddProduct() {
    Takeaway.Product.call(this);
  };

  AutoAddProduct.prototype = Object.create(Takeaway.Product.prototype);
  AutoAddProduct.prototype.constructor = AutoAddProduct;

  /**
   * Update the total price.
   */
  AutoAddProduct.prototype.updateTotalPrice = function () {
    this.totalPrice = Takeaway.Utils.toMoney(this.price * this.count, 2);
    this.totalPricePickup = Takeaway.Utils.toMoney(this.pricePickup * this.count, 2);
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = AutoAddProduct;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.AutoAddProduct = AutoAddProduct;
  } else {
    Takeaway.AutoAddProduct = AutoAddProduct;
  }
})(undefined);
/* global Takeaway */
/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Discount
 */
(function (global) {
  'use strict';

  var Discount = function Discount() {};

  /**
   * @enum Discount types
   * @property {Number} Type.Product specific product discount
   * @property {Number} Type.Nth the n-th when the discount will be applied.
   * @property {Number} Type.Combination combined products discount.
   * @property {Number} Type.Order discount that will always applied or at a minimum total price.
   */
  Discount.Type = Object.freeze({
    Product: 1,
    Nth: 2,
    Combination: 3,
    Order: 4
  });

  /**
   * @property {string} The id of the discount.
   */
  Discount.prototype.id;
  /**
   * @property {int} The type of the discount. Use DiscountType when doing a comparison.
   */
  Discount.prototype.type;
  /**
   * @property {int} The delivery type. Use DeliveryType when doing a comparison.
   */
  Discount.prototype.deliveryType;
  /**
   * @property {string} The name of the discount.
   */
  Discount.prototype.discountName;
  /**
   * @property {string} The description of the discount.
   */
  Discount.prototype.description;
  /**
   * @property {TimeWindow} date the start and end date when the discount is available.
   */
  Discount.prototype.date;
  /**
   * @property {float} A new price when discount is valid.
   */
  Discount.prototype.specialPrice;
  /**
   * @property {float} An amount of discount.
   */
  Discount.prototype.amount;
  /**
   * @property {float} An percentage on the price.
   */
  Discount.prototype.percentage;
  /**
   * @property {int} For each number the discount will be applied.
   */
  Discount.prototype.number;
  /**
   * @property {boolean} Whether the discount is calculated including sidedishes or not.
   */
  Discount.prototype.inclusiveSidedishes;
  /**
   * @property {boolean} Whether the discount can be repeated or not.
   */
  Discount.prototype.isDiscountRepeat;
  /**
   * @property {float} Discount that starts from a specific total price.
   */
  Discount.prototype.from;
  /**
   * @property {array} A group of product ids which discount will be applied on.
   */
  Discount.prototype.productIds2D;

  /**
   * Check if the discount is available according the server time.
   * @property {ServerDateTime} serverDateTime from the server
   * @return {boolean} whether the discount is available or not.
   */
  Discount.prototype.isAvailable = function (serverDateTime) {
    // TODO it is unknown how this work in TMS. Do we need to take account the 07:00 rule?
    // TMS only has date. It would better if end time would included 07:00 in the value.
    if (this.date.startTime !== undefined && this.date.endTime !== undefined && !serverDateTime.time.isBetween(this.date.startTime, this.date.endTime)) {
      return false;
    }
    if (this.date.weekDay === -1 || this.date.weekDay === serverDateTime.weekDay) {
      return true;
    }
    return false;
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Discount;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Discount = Discount;
  } else {
    Takeaway.Discount = Discount;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin (kawing.chin@takeaway.com)
 * @class Takeaway.ActiveDiscount
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  var ActiveDiscount = function ActiveDiscount() {
    this.productNames = [];
  };

  ActiveDiscount.prototype.id;
  ActiveDiscount.prototype.price;
  ActiveDiscount.prototype.totalPrice;
  /**
   * Don't count
   */
  ActiveDiscount.prototype.excludeMinimumOrder = 0;
  ActiveDiscount.prototype.movDiscount = 0;
  ActiveDiscount.prototype.discountName;
  ActiveDiscount.prototype.description;
  ActiveDiscount.prototype.count;
  ActiveDiscount.prototype.productNames;

  /**
   * Update the total discount price.
   */
  ActiveDiscount.prototype.updateTotalPrice = function () {
    this.totalPrice = Takeaway.Utils.toMoney(this.price * this.count, 2);
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = ActiveDiscount;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.ActiveDiscount = ActiveDiscount;
  } else {
    Takeaway.ActiveDiscount = ActiveDiscount;
  }
})(undefined);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.Voucher
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}
(function (global) {
  'use strict';

  var Voucher = function Voucher(obj) {
    if (obj !== undefined) {
      for (var prop in obj) {
        this[prop] = obj[prop];
      }
    }
  };

  /**
   * @enum Voucher types
   * @type {integer}
   */
  Voucher.Type = Object.freeze({
    Credit: 1,
    Discount: 2
  });

  Voucher.prototype.voucherName;
  Voucher.prototype.description;
  Voucher.prototype.code;
  Voucher.prototype.type;
  /**
   * Only in combination with Voucher.Type.Credit
   */
  Voucher.prototype.initialCredit;
  /**
   * Only in combination with Voucher.Type.Credit
   */
  Voucher.prototype.currentCredit;
  /**
   * Discount amount
   * Only in combination with Voucher.Type.Discount
   */
  Voucher.prototype.amount;
  /**
   * Discount percentage
   * Only in combination with Voucher.Type.Discount
   */
  Voucher.prototype.percentage;
  /**
   * Minimum requirement of the costs
   */
  Voucher.prototype.minimumOrderAmount;
  /**
   * Id of the required product
   */
  Voucher.prototype.productId;
  Voucher.prototype.productName;

  /**
   * Discount price after the calculation
   */
  Voucher.prototype.discount = 0;
  /**
   * How much the customer still needs to pay
   */
  Voucher.prototype.remainingPayment = 0;
  /**
   * The total price which the voucher is calculated on
   */
  Voucher.prototype.basedOnTotalPrice = 0;

  /**
   * Calculate voucher discount.
   * @param {float} price The price the voucher discount will be calculated from.
   */
  Voucher.prototype.calculateVoucherDiscount = function (price) {
    this.discount = 0;
    this.basedOnTotalPrice = price;
    switch (Number(this.type)) {
      case Takeaway.Voucher.Type.Credit:
        if (this.currentCredit < price) {
          this.discount = this.currentCredit;
        } else {
          this.discount = price;
        }
        break;
      case Takeaway.Voucher.Type.Discount:
        if (this.amount > 0) {
          this.discount = this.amount;
        } else {
          this.discount = Takeaway.Utils.toMoney(price * this.percentage / 100, 2);
        }
        break;
      default:
        break;
    }

    this.remainingPayment = price - this.discount;
    // if the discount is larger than the price, it will result into negative number.
    // the discount will be become the same as the price and the remaining payment will become 0.
    if (this.remainingPayment < 0) {
      this.discount = price;
      this.remainingPayment = 0;
    }
    return this.discount;
  };

  /**
   * Validate if the price meets the voucher's minimum requirement.
   * @param {float} price The price you want to validate on.
   */
  Voucher.prototype.validateMinimumAmount = function (price) {
    return price >= this.minimumOrderAmount;
  };

  /**
   * Validate if the products in the baskets meets the voucher's product requirement.
   * @param {Array<Product>} products that are added to basket.
   */
  Voucher.prototype.validateVoucherProduct = function (products) {
    if (this.productId === false) {
      return true;
    }

    if (this.productId !== false) {
      for (var x in products) {
        var product = products[x];
        if (product.isDisabled) {
          continue;
        }
        if (this.productId === product.id) {
          return true;
        }
      }
    }
    return false;
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Voucher;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Voucher = Voucher;
  } else {
    Takeaway.Voucher = Voucher;
  }
})(undefined);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global $, site, basket, currentRestaurant */
/**
 * @author Ka Wing Chin <(kawing.chin@takeaway.com>
 * @class Takeaway.Basket
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Takeaway');
}

(function (global) {
  'use strict';

  /**
   * @enum
   * @property {Number} TIME.TTL Time To Live
   */

  var Time = Object.freeze({
    TTL: 30 * 60 * 1000 // 30 minutes
  });

  /**
   * Self reference of this object.
   */
  var self;
  /**
   * @property {Takeaway.Restaurant}
   */
  var restaurant;
  /**
   * @property {string} The basket has its own id which is the same as the restaurant id.
   */
  var id;

  /**
   * Constructor
   * @param {Takeaway.Restaurant} Restaurant model.
   * @param {DeliveryMethod.Type} deliveryType
   */
  var Basket = function Basket(restaurantModel, deliveryType) {
    this.basketProducts = [];
    this.productMismatches = [];
    this.productMissings = [];

    self = this;
    // console.log("Init Basket " + restaurantModel.id);
    restaurant = restaurantModel;
    id = restaurant.id;
    this.deliveryType = deliveryType;
    this.setDeliveryAreaById(restaurant.deliveryAreaId);
    this.loadBasket(id);
    this.switchDeliveryType(this.deliveryType, true);
  };

  /**
   * @enum
   * @property {string} Basket the name how the basket will be saved in the local storage.
   * @property {string} LAST_INTERACTION_TIME the name how the last interaction time will be saved in the local storage.
   */
  Basket.Persistence = Object.freeze({
    BASKET: 'Basket',
    LAST_INTERACTION_TIME: 'BasketLastInteractionTime'
  });

  Basket.PRODUCT = Object.freeze({
    SUCCESS: 0,
    RESTAURANT_CLOSED: 1,
    CATEGORY_UNAVAILABLE: 2
  });

  /**
   * @property {DeliveryMethod.Type} deliveryType the basket is using. Use DeliveryMethod.Type for comparison.
   */
  Basket.prototype.deliveryType;
  Basket.prototype.isCheckoutAllowed = false;
  Basket.prototype.voucher = null;
  Basket.prototype.voucherValidation = {
    success: false,
    minimumAmount: false,
    productRequired: false
  };

  Basket.prototype.takeawayPayInitialized = false;
  Basket.prototype.takeawayPay = [];
  Basket.prototype.autoAddProducts = [];
  /**
   * Products that are currently in the basket.
   */
  Basket.prototype.basketProducts;
  /**
   * Products that are mismatched. It will be cleared at every validation.
   * @property Array<Product>
   */
  Basket.prototype.productMismatches;
  /**
   * Products that are missing. It will be cleared at every validation.
   * @property Array<Product>
   */
  Basket.prototype.productMissings;
  /**
   * Discount that are available in the restaurant.
   * @property Array<Discount>
   */
  Basket.prototype.discounts = [];
  /**
   * Current discounts that are applied to the basket.
   * @property Array<ActiveDiscount>
   */
  Basket.prototype.activeDiscounts = [];
  /**
   * Current delivery area.
   */
  Basket.prototype.deliveryArea;
  /**
   * Current delivery cost that is applied to the basket.
   */
  Basket.prototype.deliveryCosts = 0;
  /**
   * The total base price, delivery costs and transaction costs excluded.
   */
  Basket.prototype.baseTotalPrice = 0;
  /**
   * @property {float} minimumOrderValueTotalPrice The total base price excluding product minimum order value. This is included discount.
   */
  Basket.prototype.minimumOrderValueTotalPrice = 0;
  /**
   * @property {float} excludeMinimumOrderValueTotalPrice The total base price of XMF products.
   */
  Basket.prototype.excludeMinimumOrderValueTotalPrice = 0;
  /**
   * @property {float} autoAddProductsTotalPrice The total price of the auto add products.
   */
  Basket.prototype.autoAddProductsTotalPrice = 0;
  /**
   * The total price, every costs included.
   */
  Basket.prototype.totalPrice = 0;
  Basket.prototype.totalProducts = 0;
  /**
   * @property {PaymentMethod}
   * The selected payment method.
   */
  Basket.prototype.paymentMethod = null;
  Basket.prototype.transactionCosts;
  /**
   * @property {boolean} isValidateBasketByServer Whether the basket is currently in validation or not.
   */
  Basket.prototype.isValidateBasketByServer = false;

  /**
   * Set the current delivery area
   * @param {string} id of the delivery area.
   */
  Basket.prototype.setDeliveryAreaById = function (id) {
    this.deliveryArea = restaurant.getDeliveryAreaById(id);
  };

  /**
   * Switch delivery type. It will check if the restaurant supports it.
   * @param {int} deliveryType Takeaway.DeliveryMethod.Type
   * @param {boolean} skipValidation Whether to skip the validation or not.
   * @return {object} literal which contains the error data.
   */
  Basket.prototype.switchDeliveryType = function (deliveryType, skipValidation) {
    var errors;
    if (!skipValidation) {
      errors = this.validateRestaurant(deliveryType);
      if (!errors.restaurantSupportedDeliveryType) {
        console.log('Errors found: unsupported delivery type');
        return errors;
      }

      errors = this.validateBasket(deliveryType);
      if (errors.unsupportedDeliveryType.length > 0 || errors.priceDifference.length > 0) {
        console.log('Errors found');
        if (errors.unsupportedDeliveryType.length > 0) {
          console.log('Unsupported delivery type for products');
        }
        if (errors.priceDifference.length > 0) {
          console.log('Price difference');
        }
        return errors;
      }
    }

    this.deliveryType = deliveryType;
    for (var i = 0; i < this.basketProducts.length; i++) {
      var basketProduct = this.basketProducts[i];
      basketProduct.isDisabled = false;
      if (basketProduct.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (basketProduct.size !== null) {
          if (basketProduct.size.deliveryType !== this.deliveryType) {
            console.log('Removing product ' + basketProduct.uniqueId);
            this.removeProduct(basketProduct.uniqueId);
          }
        } else if (basketProduct.deliveryType !== this.deliveryType) {
          console.log('Removing product ' + basketProduct.uniqueId);
          this.removeProduct(basketProduct.uniqueId);
        }
      }
    }
    this.calculateTotalPrice();
    restaurant.getOpeningStatus(Takeaway.Cache.serverDateTime, this.deliveryType);
    return errors;
  };

  /**
   * Check if the basket delivery type is valid for the restaurant
   * @returns {boolean}
   */
  Basket.prototype.isValidDeliveryType = function () {
    // delivery 1, both 2, pickup 3
    // Check the delivery type of the restaurant
    var validDeliveryTypes = [];
    if (restaurant.deliveryType === Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
      validDeliveryTypes = [].concat(_toConsumableArray(validDeliveryTypes), [Takeaway.DeliveryMethod.Type.Pickup, Takeaway.DeliveryMethod.Type.Delivery]);
    } else {
      validDeliveryTypes = [].concat(_toConsumableArray(validDeliveryTypes), [restaurant.deliveryType]);
    }
    // Seems the basket delivery method is not supported by the restaurant
    return validDeliveryTypes.indexOf(this.deliveryType) !== -1;
  };

  Basket.prototype.isCheckoutValid = function () {
    // Is the delivery type that has been chosen valid
    var valid = this.isValidDeliveryType();
    if (valid !== true) {
      console.log('No checkout, unsupported delivery type');
    }
    if (valid === true && self.totalProducts === 0) {
      valid = false;
      console.log('No checkout, no products');
    }

    if (valid === true && this.deliveryType === Takeaway.DeliveryMethod.Type.Delivery && (this.minimumOrderValueTotalPrice <= 0 || this.validateMinimumAmount(this.minimumOrderValueTotalPrice) === false)) {
      valid = false;
      console.log('No checkout, minimum order value has not been reached');
      console.log('Minimum order value is', this.minimumOrderValueTotalPrice);
    }

    return valid === true; // to be sure the type is actually a boolean
  };

  Basket.prototype.resetTakeawayPay = function () {
    this.takeawayPay = [];
  };

  Basket.prototype.resetTakeawayPayInitialized = function () {
    this.takeawayPayInitialized = false;
  };

  Basket.prototype.updateTakeawayPayDiscount = function (_ref) {
    var _this = this;

    var maxAmount = _ref.maxAmount;

    var remainingPrice = maxAmount;
    this.takeawayPayDiscountPrice = 0;
    if (remainingPrice) {
      Object.keys(this.takeawayPay).forEach(function (key) {
        // Get the values from the current takeaway pay card
        var totalCardAmount = _this.takeawayPay[key].totalCardAmount;

        // The complete amount of the card can be used. to get discount
        // The used amount of the card cannot be more then the remaining price

        var usedCardAmount = totalCardAmount < remainingPrice ? totalCardAmount : remainingPrice;
        usedCardAmount = Math.round(usedCardAmount * 100) / 100; // rounding fix

        remainingPrice = remainingPrice - usedCardAmount;
        _this.takeawayPay[key] = _extends({}, _this.takeawayPay[key], { usedCardAmount: usedCardAmount });
      });
      this.takeawayPayDiscountPrice = Object.values(this.takeawayPay).reduce(function (accumulator, card) {
        return accumulator + card.usedCardAmount;
      }, 0);
    }
  };

  Basket.prototype.getTakeawayPayDiscount = function () {
    return this.takeawayPayDiscountPrice;
  };

  /**
   * Calculate the total price.
   */
  Basket.prototype.calculateTotalPrice = function () {
    this.totalPrice = 0;
    this.totalProducts = 0;
    this.autoAddProductsTotalPrice = 0;
    this.minimumOrderValueTotalPrice = 0;
    this.activeDiscounts = [];
    // Add the prices of the products.
    this.totalPrice = calculateProductTotalPrice(this.basketProducts, this.deliveryType);

    // Count the total products
    this.totalProducts = calculateTotalProducts(this.basketProducts, this.deliveryType);

    // Auto added products
    this.autoAddProducts = [];
    if (this.totalProducts > 0) {
      this.autoAddProducts = calculateAutoAddProducts(this.totalPrice);
      this.autoAddProductsTotalPrice = calculateAutoAddProductPrice(this.autoAddProducts, this.deliveryType);
      this.totalPrice = this.totalPrice + this.autoAddProductsTotalPrice;
    }

    // Discounts
    if (this.totalProducts > 0) {
      if (restaurant.discounts !== undefined && restaurant.discounts.length > 0) {
        this.activeDiscounts = calculateDiscounts();
      }
    }

    for (var i = 0; i < this.activeDiscounts.length; i++) {
      var activeDiscount = this.activeDiscounts[i];
      this.totalPrice = Takeaway.Utils.toMoney(parseFloat(this.totalPrice - activeDiscount.totalPrice), 2);
    }

    // MOV (product MOV - discount MOV)
    this.minimumOrderValueTotalPrice = calculateMOVPriceFromDiscount(this.basketProducts, this.activeDiscounts, this.deliveryType);

    // It is possible that it will below 0, because of the discount.
    if (this.minimumOrderValueTotalPrice < 0) {
      this.minimumOrderValueTotalPrice = 0;
    }
    // console.log("!!", this.minimumOrderValueTotalPrice);

    // Total price, delivery and transaction costs excluded.
    this.baseTotalPrice = this.totalPrice;

    // Only applied to delivery.
    this.deliveryCosts = 0;
    this.isCheckoutAllowed = this.isCheckoutValid();
    if (this.deliveryType === Takeaway.DeliveryMethod.Type.Delivery && this.totalProducts > 0) {
      // Delivery costs
      this.deliveryCosts = this.calculateDeliveryCosts(this.totalPrice);
    }

    this.totalPrice = Takeaway.Utils.toMoney(parseFloat(this.totalPrice + this.deliveryCosts), 2);

    // Voucher
    if (this.voucher !== null) {
      this.voucherValidation.minimumAmount = this.voucher.validateMinimumAmount(this.totalPrice);
      this.voucherValidation.productRequired = this.voucher.validateVoucherProduct(this.basketProducts);
      if (this.voucherValidation.minimumAmount && this.voucherValidation.productRequired) {
        this.totalPrice = Takeaway.Utils.toMoney(parseFloat(this.totalPrice - this.voucher.calculateVoucherDiscount(this.totalPrice)), 2);
      }
    }

    // Takeaway Pay
    this.updateTakeawayPayDiscount({ maxAmount: this.totalPrice });
    if (this.takeawayPayDiscountPrice) {
      this.totalPrice = Takeaway.Utils.toMoney(this.totalPrice - this.takeawayPayDiscountPrice, 2);
    }

    // Transaction costs
    if (this.paymentMethod != null) {
      this.transactionCosts = this.paymentMethod.calculateTransactionCosts(this.totalPrice);
      this.totalPrice += this.transactionCosts;
      if (this.voucher !== null) {
        this.voucher.remainingPayment += this.transactionCosts;
      }
    }

    this.totalPrice = Takeaway.Utils.toMoney(this.totalPrice, 2);
  };

  /**
   * @param {Array} foundCombinations - product id's from the discount combinations
   * Lowers the comboCounter for each basket product in the found discount combination
   */
  Basket.prototype.lowerComboCounter = function (foundCombinations) {
    var _this2 = this;

    if (foundCombinations && Array.isArray(foundCombinations)) {
      foundCombinations.forEach(function (productId) {
        // Only lower the combocounter for items in the basket where the product id is equal to the one in the combination and
        // where the combocounter greater then 0
        var foundProduct = _this2.basketProducts.find(function (product) {
          return product.getId() === productId && product.comboCounter > 0;
        });

        if (foundProduct) {
          return foundProduct.lowerComboCounter();
        }
        throw new Error('Cannot lower combocounter');
      });
    }
  };

  /**
   *
   * @param {Array.Product} basketProducts
   * @param {Array.Array} discountCombinations
   * @returns {Array} - Array of keys from the found combination
   */
  Basket.prototype.findCombination = function (basketProductsIds, discountCombinations) {
    var combination = [];
    var copyBasketProducts = basketProductsIds.slice();
    // create an array with only the product id,s
    // [{id:1, amount: 3}, {id:2, amount: 1}] ==> [1,1,1,2]
    var validCombination = discountCombinations.every(function (row) {
      return row.some(function (item) {
        var indexFound = copyBasketProducts.indexOf(item);
        if (indexFound !== -1) {
          var product = copyBasketProducts.splice(indexFound, 1);
          combination.push(product[0]);
          return true;
        }
      });
    });
    if (validCombination) {
      return combination;
    }
  };

  /**
   * Calculate possible discounts.
   * @param {float} totalPrice the price which the discounts will be calculated from.
   * TODO SPLIT calculation with strategy pattern, use ES6
   */
  var calculateDiscounts = function calculateDiscounts() {
    var discounts = [];

    if (self.totalProducts.length == 0) {
      return discounts;
    }

    var _loop = function _loop(x) {
      var discount = restaurant.discounts[x];

      // Checks if the discount is available for today.
      if (!discount.isAvailable(Takeaway.Cache.serverDateTime)) {
        return 'continue';
      }

      // Check if the discount supports the selected delivery method.
      if (discount.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (discount.deliveryType !== self.deliveryType) {
          return 'continue';
        }
      }

      switch (Number(discount.type)) {
        case Takeaway.Discount.Type.Product:
          // console.log("Discount Product");
          for (var xx in self.basketProducts) {
            var basketProduct = self.basketProducts[xx];

            if (basketProduct.isDisabled) {
              continue;
            }

            isMaxAmountReached = false;


            for (var xxx in discount.productIds2D[0]) {
              var productId = discount.productIds2D[0][xxx];
              var basketProductId = basketProduct.id;
              if (basketProduct.size && basketProduct.size.id) {
                basketProductId = basketProduct.size.id;
              }
              if (basketProductId === productId) {
                for (var i = 0; i < basketProduct.count; i++) {
                  // Check whether the discount got a maximum or not. 0 means unlimited.
                  if (discount.number > 0) {
                    // Get the current total of this discount that is in the basket.
                    var amount = 0;
                    if (self.activeDiscounts.length > 0) {
                      amount = self.activeDiscounts.reduce(function (n, activeDiscount) {
                        return n + (activeDiscount.id === discount.id);
                      });
                    }
                    // console.log("amount of discounts: " + amount);
                    if (amount >= discount.number) {
                      // Maximum got reached, up to the next product.
                      isMaxAmountReached = true;
                      break;
                    }
                  }
                  // Whether side dish is included in the price or not.
                  price = discount.inclusiveSidedishes ? basketProduct.getPrice(self.deliveryType) : basketProduct.getBasePrice(self.deliveryType);
                  totalDiscount = calculateDiscountPrice(discount, price);

                  var _movPrice = calculateProductAndDiscountMOVPrice(basketProduct, discount, self.deliveryType);
                  addDiscount(discounts, discount, totalDiscount, _movPrice, [basketProduct.productName]);
                }
                if (isMaxAmountReached) {
                  break;
                }
              }
              if (isMaxAmountReached) {
                break;
              }
            }
          }
          break;
        case Takeaway.Discount.Type.Nth:
          // console.log("Discount Nth");
          nthValidProducts = [];
          discountNumber = Number(discount.number);


          for (var _xx in discount.productIds2D[0]) {
            var _productId = discount.productIds2D[0][_xx];
            for (var _xxx in self.basketProducts) {
              var _basketProduct = self.basketProducts[_xxx];

              if (_basketProduct.isDisabled) {
                continue;
              }
              var _basketProductId = _basketProduct.id;
              if (_basketProduct.size && _basketProduct.size.id) {
                _basketProductId = _basketProduct.size.id;
              }
              if (_basketProductId === _productId) {
                for (var _i = 0; _i < _basketProduct.count; _i++) {
                  // delivery / pickup price
                  nthValidProducts.push({
                    price: discount.inclusiveSidedishes ? _basketProduct.getPrice(self.deliveryType) : _basketProduct.getBasePrice(self.deliveryType),
                    product: _basketProduct
                  });
                }
              }
            }
          }

          // Doesn't meet the required number, break.
          if (nthValidProducts.length < discountNumber) {
            break;
          }

          // Sort prices ascending
          nthValidProducts.sort(function (a, b) {
            // console.log(a);
            return a.price - b.price;
          });

          // calculate the maximum possible discounts (rounding to floor is also possible of course, but this is faster).
          var maxPossibleDiscounts = (nthValidProducts.length - nthValidProducts.length % discountNumber) / discountNumber;
          // console.log("maxPossibleDiscounts: " + maxPossibleDiscounts);
          for (var _i2 = 0; _i2 < maxPossibleDiscounts; _i2++) {
            // The discount will be on the cheapest which starts at the beginning of the array.
            nthValidProduct = nthValidProducts[_i2];

            var _totalDiscount = calculateDiscountPrice(discount, nthValidProduct.price);

            // XFM sidedish
            var _movPrice2 = calculateProductAndDiscountMOVPrice(nthValidProduct.product, discount, self.deliveryType);
            addDiscount(discounts, discount, _totalDiscount, _movPrice2, [nthValidProduct.product.productName]);

            // If it's not a discount repeat, break.
            if (!discount.isDiscountRepeat) {
              break;
            }
          }
          break;
        case Takeaway.Discount.Type.Combination:
          if (self.basketProducts && Array.isArray(self.basketProducts)) {
            self.basketProducts.forEach(function (product) {
              return product.resetComboCounter();
            });
          }

          var discountCombinationFound = void 0;

          var _loop2 = function _loop2() {
            var basketProductIds = [];
            // Creates an array of each item in the basket with a comboCounter greater then 0;
            // At the beginning the combocounter is equal to the ammount of items.
            // After a discount is used the combocounter is lowered so the same items cannot be used again for another discount.
            // For example
            // Basket Products:
            // {ItemA { ammount: 3, comboCounter: 2}
            // {ItemB { ammount: 1, comboCounter: 1}
            // {ItemC { ammount: 3, comboCounter: 3}
            // basketProductIds = [ItemA, ItemA, ItemB, ItemC, ItemC, ItemC]
            self.basketProducts.forEach(function (product) {
              basketProductIds = basketProductIds.concat(Array(product.comboCounter).fill(product.getId()));
            });
            // The found discount combination found is an array of productIds
            discountCombinationFound = self.findCombination(basketProductIds, discount.productIds2D);

            var priceCombo = 0;
            var minimumOrderValuePrice = 0;
            if (discountCombinationFound) {
              var allComboNames = [];

              // The combocounter is lowered so the product cannot be used again for a combination.
              self.lowerComboCounter(discountCombinationFound);
              discountCombinationFound.forEach(function (productId) {
                var basketProduct = self.basketProducts.find(function (product) {
                  return product.getId() === productId;
                });
                if (basketProduct) {
                  // Whether side dish is included in the price or not. (Used for MOV)
                  var addPrice = discount.inclusiveSidedishes ? basketProduct.getPrice(self.deliveryType) : basketProduct.getBasePrice(self.deliveryType);
                  priceCombo = priceCombo + addPrice;
                  minimumOrderValuePrice = minimumOrderValuePrice + basketProduct.getMinimumOrderValueTotalPrice(discount.inclusiveSidedishes, self.deliveryType);
                  allComboNames.push(basketProduct.productName);
                }
              });
              var _movPrice3 = calculateDiscountPrice(discount, minimumOrderValuePrice);
              totalDiscount = calculateDiscountPrice(discount, priceCombo);
              addDiscount(discounts, discount, totalDiscount, _movPrice3, allComboNames);
            }
          };

          do {
            _loop2();
          } while (discountCombinationFound);
          break;
        case Takeaway.Discount.Type.Order:
          var totalPrice = self.totalPrice;
          // MOV
          var movProductPrice = getMOVPrice(self.basketProducts, self.deliveryType);
          var movPrice = calculateDiscountPrice(discount, movProductPrice);
          if (discount.from <= totalPrice) {
            var _totalDiscount2 = calculateDiscountPrice(discount, totalPrice);
            addDiscount(discounts, discount, _totalDiscount2, movPrice, []);
          }
          break;
        default:
          // console.log('Wrong discount type: ' + discount.type)
          break;
      }
    };

    for (var x in restaurant.discounts) {
      var isMaxAmountReached;
      var price;
      var totalDiscount;
      var nthValidProducts;
      var discountNumber;
      var nthValidProduct;

      var _ret = _loop(x);

      if (_ret === 'continue') continue;
    }
    return discounts;
  };

  /**
   * Calculate the discount price.
   * @param {Discount} discount model is from Restaurant.discount.
   * @param {float} price the price the discount will be calcualted on.
   * @return {float} the amount of discount.
   */
  var calculateDiscountPrice = function calculateDiscountPrice(discount, price) {
    var result = 0;
    // console.log("apply discount on price: " + price);
    if (discount.specialPrice) {
      result = Math.max(price - Number(discount.specialPrice), 0);
    } else if (discount.amount) {
      // console.log(discount.discountAmount);
      result = Math.max(Number(discount.amount), 0);
    } else if (discount.percentage) {
      // console.log(discount.percentage + "%");
      result = Takeaway.Utils.toMoney(parseFloat(price * Number(discount.percentage, 0) / 100), 2);
    }
    // console.log(result);
    return result;
  };

  /**
   * Creates a discount object.
   * @param {array} activeDiscounts a array of discounts
   * @param {Discount} discount object.
   * @param {float} price discount price
   * @param {float} xfmSideDishPrice exclusive discount sidedish price that doesn't count MOV
   * @param {Array<String>} productNames the names of the products
   */
  var addDiscount = function addDiscount(activeDiscounts, discount, price, movDiscount, productNames) {
    var filtered = activeDiscounts.filter(function (activeDiscount) {
      return activeDiscount.id === discount.id && activeDiscount.price === price && activeDiscount.movDiscount === movDiscount && activeDiscount.productNames.join(',') === productNames.join(',');
    });
    if (filtered.length > 0) {
      var activeDiscount = filtered[0];
      activeDiscount.count++;
      activeDiscount.updateTotalPrice();
    } else {
      var _activeDiscount = new Takeaway.ActiveDiscount();
      _activeDiscount.id = discount.id;
      _activeDiscount.price = price;
      _activeDiscount.movDiscount = movDiscount;
      _activeDiscount.discountName = discount.discountName;
      _activeDiscount.description = discount.description;
      _activeDiscount.count = 1;
      _activeDiscount.productNames = productNames;
      _activeDiscount.updateTotalPrice();
      activeDiscounts.push(_activeDiscount);
    }
  };

  /**
   * Calculate delivery costs
   * @param {float} totalPrice the amount of costs which the delivery costs needs to be calculated from.
   * WARNING: deliveryCosts.from and .till are generated by PHP which is a string. You need to parseFloat.
   */
  Basket.prototype.calculateDeliveryCosts = function (totalPrice) {
    if (this.deliveryArea === undefined) {
      return 0;
    }

    var costObject = void 0;
    var deliveryCosts = 0;

    if (totalPrice > 0) {
      for (var x in this.deliveryArea.deliveryCosts) {
        var cost = this.deliveryArea.deliveryCosts[x];
        var from = parseFloat(cost.from);
        var till = parseFloat(cost.till);

        if (totalPrice >= from && (totalPrice < till || till === 0)) {
          costObject = cost;
          break;
        }
      }
    }

    if (costObject) {
      deliveryCosts = parseFloat(costObject.costs);
    } else if ((typeof currentRestaurant === 'undefined' ? 'undefined' : _typeof(currentRestaurant)) === 'object' && currentRestaurant.hasOwnProperty('dynamicDeliveryCosts') && currentRestaurant.dynamicDeliveryCosts > 0) {
      deliveryCosts = parseFloat(currentRestaurant.dynamicDeliveryCosts);
    }
    return deliveryCosts;
  };

  var calculateProductTotalPrice = function calculateProductTotalPrice(basketProducts, deliveryType) {
    var result = 0;
    for (var i = 0; i < basketProducts.length; i++) {
      var basketProduct = basketProducts[i];
      if (basketProduct.isDisabled) {
        continue;
      }
      result += Takeaway.Utils.toMoney(basketProduct.getTotalPrice(deliveryType), 2);
    }
    return Takeaway.Utils.toMoney(result, 2);
  };

  var calculateTotalProducts = function calculateTotalProducts(basketProducts, deliveryType) {
    var result = 0;
    for (var i = 0; i < basketProducts.length; i++) {
      var basketProduct = basketProducts[i];
      if (basketProduct.isDisabled) {
        continue;
      }
      if (basketProduct.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (deliveryType !== basketProduct.deliveryType) {
          continue;
        }
      }
      result += basketProduct.count;
    }
    return result;
  };

  /**
   * Calculate auto add products.
   * @param {decimal} totalPrice the price which the auto add products needs to be calculated from.
   * @return {Array<Products>}
   */
  var calculateAutoAddProducts = function calculateAutoAddProducts(totalPrice) {
    var products = [];
    if (self.basketProducts.length === 0) {
      return products;
    }

    // WARNING, autoAddProducts is an object literal generated in PHP.
    for (var x in restaurant.autoAddProducts) {
      var item = restaurant.autoAddProducts[x];
      var type = parseInt(item.deliverytype);
      if (type !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (type !== self.deliveryType) {
          return products;
        }
      }
      var totalCount = 1;
      if (item.eachamount !== false && item.eachamount !== 0 && totalPrice > 0) {
        totalCount = Math.ceil(totalPrice / item.eachamount);
      }

      var totalPriceItem = 0;
      totalPriceItem = parseFloat(item.price * totalCount);
      // console.log("!: " + item.name);
      var autoAddProduct = new Takeaway.AutoAddProduct();
      autoAddProduct.productName = item.name;
      autoAddProduct.id = item.id;
      autoAddProduct.count = totalCount;
      autoAddProduct.price = item.price;
      autoAddProduct.pricePickup = item.price_pickup;
      autoAddProduct.deliveryType = parseInt(item.deliverytype);
      autoAddProduct.updateTotalPrice();
      products.push(autoAddProduct);
    }
    return products;
  };

  /**
   * Get the total auto add product price.
   * @param {Array<AutoAddProduct>} autoAddProducts
   * @param {Takeaway.DeliveryType} deliveryType
   * @return The total price of auto add product.
   */
  var calculateAutoAddProductPrice = function calculateAutoAddProductPrice(autoAddProducts, deliveryType) {
    var result = 0;
    for (var i = 0; i < autoAddProducts.length; i++) {
      var autoAddProduct = autoAddProducts[i];
      if (autoAddProduct.deliveryType === Takeaway.DeliveryMethod.Type.DeliveryAndPickup || autoAddProduct.deliveryType === deliveryType) {
        result += autoAddProduct.getTotalPrice(deliveryType);
      }
    }
    return Takeaway.Utils.toMoney(result, 2);
  };

  /**
   * Get the MOV from basket product and discount.
   * @param {Product} basketProduct
   * @param {Discount} discount
   * @param {Takeaway.DeliveryType} deliveryType
   * @return MOV price from the given product and discount.
   */
  var calculateProductAndDiscountMOVPrice = function calculateProductAndDiscountMOVPrice(basketProduct, discount, deliveryType) {
    var movProductPrice = basketProduct.getMinimumOrderValueTotalPrice(discount.inclusiveSidedishes, deliveryType);
    if (movProductPrice == 0) {
      return movProductPrice;
    }

    return calculateDiscountPrice(discount, movProductPrice);
  };

  /**
   * Get the total MOV price from basket products.
   * @param {Array<Product>} basketProducts
   * @param {Takeaway.DeliveryType} deliveryType
   */
  var getMOVPrice = function getMOVPrice(basketProducts, deliveryType) {
    var movPrice = 0;

    // Calculate the total XFM prices
    for (var i = 0; i < basketProducts.length; i++) {
      var basketProduct = basketProducts[i];
      if (basketProduct.isDisabled) {
        continue;
      }
      if (basketProduct.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (deliveryType !== basketProduct.deliveryType) {
          continue;
        }
      }
      if (basketProduct.ignoreMinimumOrderValue) {
        continue;
      }

      movPrice += basketProduct.getMinimumOrderValueTotalPrice(true, deliveryType) * basketProduct.count;
    }
    return movPrice;
  };

  /**
   * Get the MOV price by Total MOV - discounts.
   * @param {Array<Product>} basketProducts
   * @param {Array<Discount>} activeDiscounts
   * @param {Takeaway.DeliveryType} deliveryType
   */
  var calculateMOVPriceFromDiscount = function calculateMOVPriceFromDiscount(basketProducts, activeDiscounts, deliveryType) {
    // Calculate the total XFM prices
    var movPrice = getMOVPrice(basketProducts, deliveryType);

    // Active discount got its own rule what happened with XFM
    for (var i = 0; i < activeDiscounts.length; i++) {
      var discount = activeDiscounts[i];
      movPrice -= discount.movDiscount * discount.count;
    }
    // console.log(movPrice);
    return Takeaway.Utils.toMoney(movPrice, 2);
  };

  /**
   * Add product to the basket. If the product is already added, then the product count will be increased.
   * @param {Product} product object passed by the controller.
   * @return {Basket.PRODUCT} the result when trying to add a product.
   */
  Basket.prototype.addProduct = function (product) {

    if (restaurant.onlineStatus === Takeaway.Restaurant.OpeningStatus.Closed || restaurant.openingStatus === Takeaway.Restaurant.OpeningStatus.Closed) {
      return Takeaway.Basket.PRODUCT.RESTAURANT_CLOSED;
    }

    // It shouldn't be null, but the current implentation doesn't have categories.
    if (product.categoryId !== null) {
      var category = restaurant.getCategoryById(product.categoryId);
      if (category !== undefined) {
        if (category.status === Takeaway.Category.Status.Closed) {
          return Takeaway.Basket.PRODUCT.CATEGORY_UNAVAILABLE;
        }
      }
    }

    var uniqueId = generateProductOrderId(product);
    var filtered = this.basketProducts.filter(function (basketProduct) {
      return basketProduct.uniqueId === uniqueId;
    });

    if (filtered.length > 0) {
      var basketProduct = filtered[0];
      basketProduct.count += product.count;
      basketProduct.updateTotalPrice();
    } else {
      product.uniqueId = uniqueId;
      product.updateTotalPrice();
      // Copy the data from the original product.
      var _basketProduct2 = new Takeaway.Product(product);
      this.basketProducts.push(_basketProduct2);
    }
    this.saveBasket();
    this.calculateTotalPrice();
    if (window.app && window.app.components && window.app.components.cookieWall && window.app.components.cookieWall.closeCookieWallThisSession) {
      window.app.components.cookieWall.closeCookieWallThisSession();
    }
    return Takeaway.Basket.PRODUCT.SUCCESS;
  };

  /**
   * Increase product that is in the basket by 1.
   * @param {string} id The basket product id, which is unique (product id + side dishes ids).
   */
  Basket.prototype.increaseProduct = function (id) {
    var filtered = self.basketProducts.filter(function (product) {
      return product.uniqueId === id;
    });

    if (filtered.length > 0) {
      var product = filtered[0];
      product.count++;
      product.updateTotalPrice();
    }
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Decrease product that is in the basket by 1. If the product count is 1, remove them all.
   * @param {string} id The basket product id, which is unique (product id + side dishes ids).
   * @return {boolean} whether the product is removed or not.
   */
  Basket.prototype.decreaseProduct = function (id) {
    var filtered = self.basketProducts.filter(function (product) {
      return product.uniqueId === id;
    });

    if (filtered.length > 0) {
      var product = filtered[0];
      product.count--;
      if (product.count <= 0) {
        this.removeProduct(id);
      } else {
        product.updateTotalPrice();
      }
    }
    this.saveBasket();
    this.calculateTotalPrice();
    return product.count === 0;
  };

  /**
   * Remove product from the basket.
   * @param {string} id The basket product id, which is unique (product id + size + side dishes id).
   */
  Basket.prototype.removeProduct = function (id) {
    for (var i = 0; i < this.basketProducts.length; i++) {
      var product = self.basketProducts[i];
      if (product.uniqueId === id) {
        this.basketProducts.splice(i, 1);
        break;
      }
    }

    // TODO VOUCHER??? REMOVED?
    if (self.basketProducts.length == 0) {
      this.removeVoucher();
    }
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Add comment to a product. HTML tags will be stripped and white spaces will be trimmed, html tags will be removed and it will check on maximum length.
   * @param {string} id The basket product id, which is unique (product id + size + side dishes id).
   * @param {string} comment The comment that will be added to the product.
   */
  Basket.prototype.addComment = function (id, comment) {
    var filtered = self.basketProducts.filter(function (product) {
      return product.uniqueId === id;
    });

    if (filtered.length > 0) {
      var product = filtered[0];
      comment = comment.replace(/<(?:.|\n)*?>/gm, '');
      comment = comment.replace(/(^\s+|\s+$)/g, '');
      if (comment.length > Takeaway.Product.CommentMaxLength) {
        comment.substring(0, Takeaway.Product.CommentMaxLength);
      }
      product.comment = comment;
      this.saveBasket();
    }
  };

  /**
   * Get the comment of a product.
   * @param {string} id The basket product id, which is unique (product id + size + side dishes id).
   * @return {string} the commment of the product.
   */
  Basket.prototype.getComment = function (id) {
    var filtered = self.basketProducts.filter(function (product) {
      return product.uniqueId === id;
    });
    if (filtered.length > 0) {
      var product = filtered[0];
      return product.comment;
    }
    return null;
  };

  /**
   * Validate if the price meets the minimum requirement.
   * @param {float} price the price the minimum order amount must be validated on.
   * @return {boolean} Whether the validation is a success or not.
   */
  Basket.prototype.validateMinimumAmount = function (price) {
    if (this.deliveryArea === undefined) {
      return false;
    }

    if (self.totalProducts === 0) {
      return false;
    }

    if (this.deliveryType === Takeaway.DeliveryMethod.Type.Pickup) {
      return true;
    }

    return price >= this.deliveryArea.minimumOrderAmount;
  };

  /**
   * Checks if there is an minimumOrderAmount
   * @return {boolean} Is there an minimum order amount true/false
   */
  Basket.prototype.hasMinimumAmount = function () {
    return this.deliveryArea.minimumOrderAmount !== 0;
  };

  /**
   * Calculate the amount that is needed for minimum requirement by total price.
   * @param {number} price the price the minimum order amount must be calculated on.
   * @return {number} The difference between the total price and minimum order amount.
   * When it is a negative number, the sum will be 0.
   */
  Basket.prototype.calculateMinimumAmount = function (price) {
    if (price < this.deliveryArea.minimumOrderAmount) {
      return Takeaway.Utils.toMoney(this.deliveryArea.minimumOrderAmount - price, 2);
    }
    return 0;
  };

  /**
   * It validates if the products are available with the given time.
   * It will only return the first invalid category.
   * @param {moment} deliveryTime The time the user want to
   * @return {object} the invalid category and product if there is one.
   */
  Basket.prototype.validateDeliveryTime = function (deliveryTime) {
    for (var x in this.basketProducts) {
      var basketProduct = this.basketProducts[x];
      var category = restaurant.getCategoryById(basketProduct.categoryId);
      if (category !== undefined) {
        var status = category.validateOrderTime(deliveryTime, deliveryTime.day());
        if (status !== Takeaway.Category.Status.Open && (basketProduct.deliveryType === Takeaway.DeliveryMethod.Type.DeliveryAndPickup || basketProduct.deliveryType === this.deliveryType)) {
          return { category: category, product: basketProduct };
        }
      }
    }
    return null;
  };

  /**
   * Set the voucher in the basket.
   * @param {Takeaway.Voucher} voucher object
   */
  Basket.prototype.addVoucher = function (voucher) {
    this.voucher = voucher;
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Remove the voucher from the basket.
   */
  Basket.prototype.removeVoucher = function () {
    this.voucher = null;
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Set the takeaway pay in the basket.
   * @param {Takeaway.TakeawayPay} takeawayPay object
   */
  Basket.prototype.updateTakeawayPay = function (_ref2) {
    var cardNumber = _ref2.cardNumber,
        allowance = _ref2.allowance,
        purchaseNumber = _ref2.purchaseNumber,
        projectNumber = _ref2.projectNumber;

    // try and find the item
    var found = this.takeawayPay.find(function (item) {
      return item.cardNumber === cardNumber;
    });
    if (!found) {
      this.takeawayPay = [].concat(_toConsumableArray(this.takeawayPay), [{
        totalCardAmount: Number(allowance),
        cardNumber: cardNumber,
        usedCardAmount: 0,
        purchaseNumber: purchaseNumber,
        projectNumber: projectNumber
      }]);
    } else {
      found.totalCardAmount = Number(allowance);
      found.purchaseNumber = purchaseNumber;
      found.projectNumber = projectNumber;
    }

    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Remove the takeaway from the basket.
   */
  Basket.prototype.removeTakeawayPay = function (_ref3) {
    var cardNumber = _ref3.cardNumber;

    this.takeawayPay = this.takeawayPay.filter(function (card) {
      return card.cardNumber !== cardNumber;
    });
    this.saveBasket();
    this.calculateTotalPrice();
  };
  /**
   * Set paymentmethod.
   * @param {PaymentMethod} paymentmethod
   */
  Basket.prototype.setPaymentMethod = function (id) {
    for (var i = 0; i < restaurant.paymentMethods.length; i++) {
      var paymentMethod = restaurant.paymentMethods[i];
      if (paymentMethod.id === id) {
        this.paymentMethod = paymentMethod;
        break;
      }
    }
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Remove paymentmethod.
   */
  Basket.prototype.removePaymentMethod = function () {
    this.paymentMethod = null;
    this.saveBasket();
    this.calculateTotalPrice();
  };

  /**
   * Save the basket into localstorage
   * // TODO move to BasketRepository
   */
  Basket.prototype.saveBasket = function () {
    // Delete helper that got added in Products.
    for (var x in this.basketProducts) {
      var value = this.basketProducts[x];
      delete value.comboCounter;
    }

    var content = JSON.parse(localStorage.getItem(Basket.Persistence.BASKET) || '{}');
    content[id] = {
      products: this.basketProducts,
      voucher: this.voucher,
      paymentMethod: this.paymentMethod,
      takeawayPay: this.takeawayPay,
      takeawayPayInitialized: this.takeawayPayInitialized
    };

    localStorage.setItem(Basket.Persistence.BASKET, JSON.stringify(content));
    localStorage.setItem(Basket.Persistence.LAST_INTERACTION_TIME, Date.now());
  };

  /**
   * Load basket from the local storage. If the max time has exceeded, then the basket will be cleared.
   * // TODO move to BasketRepository
   */
  Basket.prototype.loadBasket = function () {
    if (Date.now() > getLastInteractionTime() + Time.TTL) {
      this.clearBaskets();
    } else {
      clearBasket();
      localStorage.setItem(Basket.Persistence.LAST_INTERACTION_TIME, Date.now());
      var baskets = JSON.parse(localStorage.getItem(Basket.Persistence.BASKET) || '{}');

      if (baskets.hasOwnProperty(id)) {
        var basket = baskets[id];
        var products = basket.products;
        for (var i = 0; i < products.length; i++) {
          var basketProduct = new Takeaway.Product(products[i]);
          basketProduct.updateTotalPrice();
          this.basketProducts.push(basketProduct);
        }

        if (basket.paymentMethod !== null) {
          this.paymentMethod = new Takeaway.PaymentMethod(basket.paymentMethod);
        }

        if (basket.takeawayPay) {
          console.log('Set TakeawayPay from LocalStorage basket');
          this.takeawayPay = basket.takeawayPay;
        }

        if (basket.takeawayPayInitialized) {
          this.takeawayPayInitialized = basket.takeawayPayInitialized;
        }

        if (basket.voucher) {
          // ask to server first
          console.log('Check voucher!', basket.voucher);
          this.validateVoucher(basket.voucher.code);
          this.voucher = new Takeaway.Voucher(basket.voucher);
        }

        if (basket.isReorder) {
          var areAllProductsAvailable = basket.areAllProductsAvailable,
              _basket$unavailabilit = basket.unavailabilityNotificationMessage,
              unavailabilityNotificationMessage = _basket$unavailabilit === undefined ? '' : _basket$unavailabilit;


          if (!areAllProductsAvailable) {
            window.app.helpers.notifyErrorWithIconSad(unavailabilityNotificationMessage);
            basket.unavailabilityNotificationMessage = '';
          } else {
            basket.isReorder = false;
            baskets[id] = basket;
            localStorage.setItem(Basket.Persistence.BASKET, JSON.stringify(baskets));
            if (window.app.services.mediaQueryService.respondTo('<=tablet-landscape')) {
              window.app.components.basketContainer.openPopup();
            }
          }
        }
      }
    }
  };

  /**
   * Clear the basket, products, auto added products, voucher.
   */
  var clearBasket = function clearBasket() {
    self.basketProducts = [];
    self.autoAddProducts = [];
    self.takeawayPay = [];
    self.voucher = null;
    self.paymentMethod = null;
  };

  /**
   * Clear all baskets in the local storage.
   * TODO: move to BasketRepository
   */
  Basket.prototype.clearBaskets = function () {
    localStorage.setItem(Basket.Persistence.BASKET, '{}');
    clearBasket();
  };

  /**
   * Get total products.
   * @param {string} id The id of the restaurant.
   * @return the number of products in the basket.
   */
  Basket.prototype.getTotalProducts = function () {
    var count = 0;
    for (var i = 0; i < this.basketProducts.length; i++) {
      var basketProduct = this.basketProducts[i];
      count += basketProduct.count;
    }
    return count;
  };

  /**
   * Returns total MOV products.
   * @return {int} total MOV products.
   */
  Basket.prototype.getTotalProductsMOVOnly = function () {
    var count = 0;
    for (var i = 0; i < this.basketProducts.length; i++) {
      var basketProduct = this.basketProducts[i];
      if (basketProduct.ignoreMinimumOrderValue) {
        continue;
      }
      count += basketProduct.count;
    }
    return count;
  };

  /**
   * Get total products by restaurant id.
   * @param {string} id The id of the restaurant.
   * @return the number of products in the basket.
   */
  Basket.prototype.getTotalProductsByRestaurantId = function (id) {
    var count = 0;
    if (Date.now() > getLastInteractionTime() + Time.TTL) {
      this.clearBaskets();
      return count;
    } else {
      var baskets = JSON.parse(localStorage.getItem(Basket.Persistence.BASKET) || '{}');
      if (baskets.hasOwnProperty(id)) {
        var products = baskets[id].products;
        for (var i = 0; i < products.length; i++) {
          count += products[i].count;
        }
        return count;
      }
      return count;
    }
  };

  /**
   * Whether the basket contains products that exclude minimum order value.
   * @return {boolean}
   */
  Basket.prototype.containsExcludeProduct = function () {
    if (this.deliveryType == Takeaway.DeliveryMethod.Type.Pickup) {
      return false;
    }

    for (var x in this.basketProducts) {
      var basketProduct = this.basketProducts[x];
      if (basketProduct.ignoreMinimumOrderValue) {
        return true;
      }

      if (basketProduct.size !== null) {
        if (basketProduct.size.ignoreMinimumOrderValue) {
          return true;
        }
        for (var xx in basketProduct.size.sideDishes) {
          var sideDish = basketProduct.size.sideDishes[xx];
          if (sideDish.ignoreMinimumOrderValue) {
            return true;
          }
        }
      }
    }
    return false;
  };

  /**
   * Validate restaurant if it is possible to switch delivery method.
   * @param {Takeaway.DeliveryMethod.Type} deliveryType
   */
  Basket.prototype.validateRestaurant = function (deliveryType) {
    var result = false;
    var validTypes = [];
    if (restaurant.deliveryType === Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
      validTypes.push(Takeaway.DeliveryMethod.Type.Delivery);
      validTypes.push(Takeaway.DeliveryMethod.Type.Pickup);
    } else {
      validTypes.push(restaurant.deliveryType);
    }

    if (validTypes.indexOf(deliveryType) !== -1) {
      result = true;
    }

    return {
      restaurantSupportedDeliveryType: result
    };
  };

  /**
   * Products will be validated if they are available when switched delivery method.
   * @param {Takeaway.DeliveryType} deliveryType
   */
  Basket.prototype.validateBasket = function (deliveryType) {
    var unsupportedDeliveryType = [];
    var priceDifference = [];
    for (var x in this.basketProducts) {
      var basketProduct = this.basketProducts[x];
      var isUnsupportedHelper = false;
      // Check wether the product is valid for the delivery type.
      if (basketProduct.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        if (basketProduct.size !== null) {
          if (basketProduct.size.deliveryType !== deliveryType) {
            unsupportedDeliveryType.push(basketProduct);
          }
        } else if (basketProduct.deliveryType !== deliveryType) {
          unsupportedDeliveryType.push(basketProduct);
          isUnsupportedHelper = true;
        }
      }

      // We don't need to check the price difference if the product is unsupported.
      if (isUnsupportedHelper) {
        continue;
      }

      // We don't need to check the price difference if the product only supports once delivery type,
      if (basketProduct.deliveryType !== Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        continue;
      }

      // Check whether the product got the same base price on diffent delivery methods.
      if (basketProduct.basePrice !== basketProduct.basePricePickup) {
        priceDifference.push(basketProduct);
      }
    }

    return {
      unsupportedDeliveryType: unsupportedDeliveryType,
      priceDifference: priceDifference
    };
  };

  /**
   * Parse reorder data and saves it. Recalculate based on the current delivery method.
   * There is no invalid check, because that is already done in processreorder.js.
   * Warning the data comes from PHP and it is not parsed.
   * @param {json} data
   */
  Basket.prototype.reorder = function (data) {
    // Clear the basket first
    clearBasket();

    // Put it in the localstorage and load it again
    var content = JSON.parse(localStorage.getItem(Basket.Persistence.BASKET) || '{}');
    content[id] = data[id];
    localStorage.setItem(Basket.Persistence.BASKET, JSON.stringify(content));
    this.loadBasket();
    this.switchDeliveryType(this.deliveryType, true);
    this.saveBasket();
  };

  /**
   * The data comes from the server and it contains the correct values.
   * When a product is mismatched the price will be corrected.
   * When a product is missing the product will be removed from the basket.
   * Warning the data comes from PHP and it is not parsed.
   * @param {json} data
   */
  Basket.prototype.updateBasketAfterValidation = function (data) {
    var _this3 = this;

    this.productMismatches = [];
    this.productMissings = [];
    if (data.productMismatch) {
      for (var x in data.productMismatches) {
        var productMismatch = data.productMismatches[x];
        this.productMismatches.push(parseProductMismatch(productMismatch));
      }
    }

    if (data.productMissing) {
      var i = data.productMissings.length;
      while (i--) {
        var productMissingId = data.productMissings[i];
        var productMissing = this.basketProducts.filter(function (x) {
          return x.uniqueId === productMissingId;
        })[0];

        if (productMissing === undefined) {
          continue;
        }

        this.productMissings.push(productMissing);
        this.removeProduct(productMissing.uniqueId);
      }
    }
    // Last check if the basket is still complete.
    var count = 0;

    var _loop3 = function _loop3(_i3) {
      basketProduct = _this3.basketProducts.filter(function (x) {
        if (x.uniqueId === data.productExistingIds[_i3]) {
          count++;
        }
      }.bind(_this3));
    };

    for (var _i3 in data.productExistingIds) {
      var basketProduct;

      _loop3(_i3);
    }
    if (count !== data.productExistingIds.length) {
      // console.log('Something went wrong with the validation, basket got expired probably')
    }

    this.calculateTotalPrice();
    this.saveBasket();
  };

  Basket.prototype.validateVoucher = function (voucherCode) {
    $.ajax({
      type: 'POST',
      url: site.local + 'checkVoucher.php',
      data: JSON.stringify({
        vouchercode: voucherCode,
        basket: JSON.parse(this.getBasketJson()),
        email: $(document).find("input[name='email']").val(),
        lastName: $(document).find("input[name='surname']").val(),
        phoneNumber: $(document).find("input[name='phonenumber']").val(),
        address: $(document).find("input[name='address']").val()
      }),
      context: this
    }).done(function (response) {
      response = JSON.parse(response);
      if (response.hasOwnProperty('status')) {
        if (response.status === 'success') {
          var voucher = new Takeaway.Voucher();
          voucher.voucherName = response.voucherobj.vouchername;
          voucher.description = response.voucherobj.voucherdescription;
          voucher.code = response.voucherobj.vouchercode;
          voucher.type = parseInt(response.voucherobj.vouchertype);
          voucher.initialCredit = parseFloat(response.voucherobj.voucheramount);
          voucher.currentCredit = parseFloat(response.voucherobj.vouchercredit);
          voucher.amount = parseFloat(response.voucherobj.voucherdiscountamount);
          voucher.percentage = parseFloat(response.voucherobj.voucherdiscountpercentage);
          voucher.minimumOrderAmount = parseFloat(response.voucherobj.voucherdiscountfrom);
          voucher.productId = response.voucherobj.productid;
          voucher.productName = response.voucherobj.productname;
          this.addVoucher(voucher);

          if ($('body').hasClass('step4')) {
            var paymentMethod = basket.getPaymentMethod();
            var selectPaymentMethod = false;

            if (typeof paymentMethod.id !== 'undefined') {
              var $paymentMethodElement = $('.paymentmethod' + paymentMethod.id);

              if ($paymentMethodElement.hasClass('payment-method-type-online')) {
                selectPaymentMethod = paymentMethod.id;
              }
            }

            if (selectPaymentMethod !== false) {
              $('.paymentmethod' + selectPaymentMethod)[0].click();
              $('.paymentmethod' + selectPaymentMethod + ' input')[0].click();
            } else {
              $('.paymentbuttonwrapper.payment-method-type-online')[0].click();
              $('.paymentbuttonwrapper.payment-method-type-online input')[0].click();
            }
          }
        } else if (response.status === 'error') {
          for (var i = 0; i < response.markfields.length; i++) {
            if (response.markfields[i] === 'ivouchercode') {
              console.log('REMOVE VOUCHER');
              var elt = document.getElementById('ivoucherpopuplink');
              if (elt) {
                elt.className = 'smalltextright';
              }

              elt = document.getElementById('ivouchercontainer');
              if (elt) {
                elt.innerHTML = '';
              }

              basket.removeVoucher();

              $('#ivouchercontainerr').show();
              $('.paymentnormal').show();
            }
            var mfield = document.getElementById(response.markfields[i]);
            if (mfield) {
              var teststr = mfield.className;
              if (teststr.substr(teststr.length - 7) !== ' marked') {
                mfield.className = mfield.className + ' marked';
              }
            }
          }
          $('#ivouchermessage')[0].innerHTML = response.value;
        }
        this.updateBasketAfterValidation(response.basketResponse);
      }
    });
  };

  var parseProductMismatch = function parseProductMismatch(productMismatch) {
    var basketProduct = self.basketProducts.filter(function (x) {
      return x.uniqueId === productMismatch.uniqueId;
    })[0];

    if (basketProduct === undefined) {
      return;
    }

    // The data doesn't distinct product and size.
    if (basketProduct.size !== null) {
      basketProduct.size.price = productMismatch.singlePrice;
      basketProduct.size.pricePickup = productMismatch.singlePricePickup;
      basketProduct.deliveryType = parseInt(productMismatch.deliveryType);
      basketProduct.ignoreMinimumOrderValue = productMismatch.ignoreMinimumOrderValue;
    } else {
      basketProduct.basePrice = productMismatch.singlePrice;
      basketProduct.basePricePickup = productMismatch.singlePricePickup;
      basketProduct.deliveryType = parseInt(productMismatch.deliveryType);
      basketProduct.ignoreMinimumOrderValue = productMismatch.ignoreMinimumOrderValue;
    }

    for (var x in productMismatch.sideDishes) {
      var sideDishMismatch = productMismatch.sideDishes[x];
      basketProduct.size.sideDishes.filter(function (s) {
        if (s.id === sideDishMismatch.id) {
          s.price = parseFloat(sideDishMismatch.price);
          s.pricePickup = parseFloat(sideDishMismatch.price_pickup);
          s.ignoreMinimumOrderValue = sideDishMismatch.ignoreMinimumOrderValue;
        }
      });
    }
    basketProduct.updateTotalPrice();
    return basketProduct;
  };

  /**
   * Clear the basket validation data.
   */
  Basket.prototype.clearBasketValidationData = function () {
    this.productMismatches = [];
    this.productMissings = [];
  };

  /**
   * Unused, because the validation will be done with form submit.
   * Products will be send to the server for validation.
   * TODO Should be put in seperate class that handle webservice requests.
   * @param {function} callback will be called when the request is done.
   */
  Basket.prototype.validateBasketByServer = function (callback) {
    if (restaurant.openingStatus == Takeaway.Restaurant.OpeningStatus.Closed) {
      return;
    }

    if (!this.isValidateBasketByServer) {
      this.isValidateBasketByServer = true;
    }

    var basketJson = this.getBasketJson();
    var result;
    $.ajax({
      type: 'POST',
      url: restaurant.cartUrl,
      contentType: 'application/json; charset=utf-8',
      dataType: 'json',
      data: basketJson,
      success: function success(response, status, jqXHR) {
        result = response;
      },
      error: function error(jqXHR, status, _error) {
        // TODO nice error message
        // error from the server.
        // console.log('checkout failed', status, error)
      }
    }).always = function () {
      this.isValidateBasketByServer = false;
      callback(result);
    }.bind(this);
  };

  /**
   * Get the current basket but then data that is only need for validation.
   * @return {object}
   */
  Basket.prototype.getBasketJson = function () {
    var products = [];

    for (var x in this.basketProducts) {
      var basketProduct = this.basketProducts[x];
      var product = {
        uniqueId: basketProduct.uniqueId,
        categoryId: basketProduct.categoryId,
        productId: basketProduct.id,
        productName: basketProduct.productName,
        count: basketProduct.count,
        totalPrice: basketProduct.totalPrice,
        totalPricePickup: basketProduct.totalPricePickup,
        comment: basketProduct.comment
      };

      if (basketProduct.size !== null) {
        product.sizeId = basketProduct.size.id;
        product.sizeName = basketProduct.size.sizeName;

        product.sideDishes = [];
        for (var xx in basketProduct.size.sideDishes) {
          var sideDish = basketProduct.size.sideDishes[xx];
          product.sideDishes.push({
            sideDishId: sideDish.id,
            sideDishName: sideDish.sideDishName
          });
        }
      }
      products.push(product);
    }

    var paymentMethodId = this.paymentMethod.id;
    if (this.voucher !== null) {
      if (this.totalPrice === 0) {
        paymentMethodId = Takeaway.PaymentMethod.ID.Voucher;
      }
    }

    // Remove unused cards and only send the used amount
    // the total Amount of the card will be checked serverside
    var takeawayPay = this.takeawayPay.filter(function (_ref4) {
      var cardnumber = _ref4.cardnumber,
          usedCardAmount = _ref4.usedCardAmount;
      return usedCardAmount;
    }).map(function (_ref5) {
      var usedCardAmount = _ref5.usedCardAmount,
          cardNumber = _ref5.cardNumber,
          purchaseNumber = _ref5.purchaseNumber,
          projectNumber = _ref5.projectNumber;
      return {
        usedCardAmount: usedCardAmount,
        cardNumber: cardNumber,
        purchaseNumber: purchaseNumber,
        projectNumber: projectNumber
      };
    });

    var basketObject = {
      deliveryAreaId: restaurant.deliveryAreaId,
      deliveryType: this.deliveryType,
      paymentMethod: paymentMethodId,
      products: products,
      restaurantId: id,
      takeawayPay: takeawayPay,
      totalPrice: this.totalPrice
    };

    return JSON.stringify(basketObject);
  };

  /**
   * Get the last interaction time of the basket.
   * If it doesn't have a last interaction time, then a new Date will be returned.
   * @return {int} time in seconds.
   */
  var getLastInteractionTime = function getLastInteractionTime() {
    var time = localStorage.getItem(Basket.Persistence.LAST_INTERACTION_TIME);
    if (time) {
      return parseInt(time);
    } else {
      return new Date().getTime();
    }
  };

  /**
   * Generate unique id based on product and side dish ids.
   * @param {Product} product object.
   */
  var generateProductOrderId = function generateProductOrderId(product) {
    if (product.size === null) {
      return product.id;
    }

    var uniqueId = product.size.id;
    var sideDishes = product.size.sideDishes;
    if (sideDishes === undefined) {
      return uniqueId;
    }

    for (var i = 0; i < sideDishes.length; i++) {
      uniqueId += '-' + sideDishes[i].id;
    }
    return uniqueId;
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Basket;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.Basket = Basket;
  } else {
    Takeaway.Basket = Basket;
  }
})(undefined);
/* global
  $,
  app,
  Cookies,
  currentRestaurant,
  isDeliveryPossible,
  MenucardCategories,
  moment,
  Pickup,
  selectFirstPossiblePaymentMethod,
  selectPaymentMethodById,
  Takeaway,
*/
$.fn.serializeObject = function () {
  var o = {};
  var a = this.serializeArray();
  $.each(a, function () {
    if (o[this.name] !== undefined) {
      if (!o[this.name].push) {
        o[this.name] = [o[this.name]];
      }
      o[this.name].push(this.value || '');
    } else {
      o[this.name] = this.value || '';
    }
  });
  return o;
};

// Initializes a new instance of the StringBuilder class
// and appends the given value if supplied
function StringBuilder(value) {
  this.string = '';
  this.append(value);
}

// Appends the given value to the end of this instance.
StringBuilder.prototype.append = function (value) {
  if (value) {
    this.string += value;
  }
  return this;
};

// Clears the string buffer
StringBuilder.prototype.clear = function () {
  this.string = '';
  return this;
};

// Returns the string
StringBuilder.prototype.toString = function () {
  return this.string;
};

var parseOpeningTimes = function parseOpeningTimes(datas) {
  var openingTimes = [];
  for (var x in datas) {
    var data = datas[x];
    for (var xx in data) {
      var openingTime = data[xx];
      var timeWindow = new Takeaway.TimeWindow();
      timeWindow.weekDay = parseInt(x);
      timeWindow.startTime = moment(openingTime.starttime, 'HH:mm');
      timeWindow.endTime = moment(openingTime.endtime, 'HH:mm');
      openingTimes.push(timeWindow);
    }
  }
  return openingTimes;
};

var parseExceptionTimes = function parseExceptionTimes(datas) {
  var openingTimes = [];
  for (var x in datas) {
    var openingTime = datas[x];
    var start = moment(openingTime.starttime * 1000);
    var end = moment(openingTime.endtime * 1000);
    var timeWindow = new Takeaway.TimeWindow();
    timeWindow.date = Takeaway.Utils.getDate(start);
    timeWindow.startTime = moment({ hour: start.hours(), minute: start.minutes() });
    timeWindow.endTime = moment({ hour: end.hours(), minute: end.minutes() });
    openingTimes.push(timeWindow);
  }
  return openingTimes;
};

var toast = function toast(text) {
  var tooltip = $('#tooltip');
  tooltip.html(text);
  tooltip.show();
  tooltip.delay(3000).fadeOut(200, function () {
    tooltip.text('');
  });
  if (tooltip.length > 0) {
    var link = tooltip[0].querySelector('a');
    if (link) {
      link.focus();
    }
  }
};

/**
 * Select the payment method that is set in local storage.
 * If payment method is not set, select the last payment method from cookies
 *
 * @default select the first possible payment method.
 */
var selectPaymentMethodByLocalStorage = function selectPaymentMethodByLocalStorage() {
  var lastChosenPaymentDetailsCookie = Cookies.get('lastChosenPaymentDetails');
  var lastChosenPaymentCompleteId = '';

  if (basket.getPaymentMethod() !== null) {
    var isPaymentMethodAvailable = currentRestaurant.Settings.PaymentMethods.find(function (item) {
      return item.id === basket.getPaymentMethod().id;
    });
    if (isPaymentMethodAvailable) {
      selectPaymentMethodById(basket.getPaymentMethod().id);
    } else {
      selectFirstPossiblePaymentMethod();
    }
  } else if (lastChosenPaymentDetailsCookie) {
    var _JSON$parse = JSON.parse(lastChosenPaymentDetailsCookie),
        lastUsedPaymentMethod = _JSON$parse.paymentMethod,
        lastUsedPaymentMethodSub = _JSON$parse.paymentMethodSub,
        lastUsedIdealBank = _JSON$parse.idealBank;

    if (lastUsedPaymentMethod === '6') {
      lastChosenPaymentCompleteId = lastUsedPaymentMethod + '_' + lastUsedPaymentMethodSub;
    } else {
      lastChosenPaymentCompleteId = lastUsedPaymentMethod;
    }
    var _isPaymentMethodAvailable = currentRestaurant.Settings.PaymentMethods.find(function (item) {
      return item.id === lastChosenPaymentCompleteId;
    });
    if (_isPaymentMethodAvailable) {
      selectPaymentMethodById(lastChosenPaymentCompleteId);

      if (lastUsedPaymentMethod === '3') {
        var $idealBank = document.querySelector('#iidealbank');
        if ($idealBank && $idealBank.querySelector('option[value="' + lastUsedIdealBank + '"]')) {
          $idealBank.value = lastUsedIdealBank;
        }
      }
    } else {
      // This is from Checkout.js.
      selectFirstPossiblePaymentMethod();
    }
  } else {
    // This is from Checkout.js.
    selectFirstPossiblePaymentMethod();
  }
};

$.when($.ready).then(function () {
  // Clear the basket on step 5
  if ($(document.body).hasClass('step5')) {
    localStorage.removeItem(Takeaway.Basket.Persistence.BASKET);
    localStorage.removeItem(Takeaway.Basket.Persistence.LAST_INTERACTION_TIME);
    return;
  }

  if (!$(document.body).hasClass('step3') && !$(document.body).hasClass('step4')) {
    return;
  }

  parseRestaurantData();
});

var basket;
var parseRestaurantData = function parseRestaurantData() {
  var _app$getState = app.getState(),
      normalizedServerTime = _app$getState.normalizedServerTime;

  Takeaway.Cache.serverDateTime = normalizedServerTime;

  var deliveryType;
  if (Pickup.getCurrentStatus() === undefined || Pickup.isTakeawayStatus()) {
    deliveryType = Takeaway.DeliveryMethod.Type.Delivery;
  } else {
    deliveryType = Takeaway.DeliveryMethod.Type.Pickup;
  }

  var currentDelivery = isDeliveryPossible();

  var restaurant = new Takeaway.Restaurant();
  restaurant.id = currentRestaurant.Id;
  restaurant.name = currentRestaurant.Name;
  restaurant.url = currentRestaurant.Urls.Restaurant;
  restaurant.cartUrl = currentRestaurant.Urls.Cart;
  restaurant.orderUrl = currentRestaurant.Urls.OrderUrl;
  restaurant.domain = currentRestaurant.Urls.Domain;
  restaurant.onlineStatus = parseInt(currentRestaurant.Open);
  restaurant.deliveryType = currentRestaurant.Pickup;
  restaurant.deliveryAreaId = currentDelivery ? currentDelivery.postcode : null;
  restaurant.autoAddProducts = currentRestaurant.Settings.AutoAddedProducts;
  restaurant.translations = currentRestaurant.Translations;
  restaurant.currency = currentRestaurant.Currency;

  // Category opening and exception times
  var categories = [];
  for (var id in MenucardCategories) {
    var data = MenucardCategories[id];
    var category = new Takeaway.Category();
    var timeWindow = void 0;
    category.id = id;
    for (var x in data) {
      if (x === 'exceptions') {
        var exceptions = data[x];
        for (var xx in exceptions) {
          var exception = exceptions[xx];
          timeWindow = new Takeaway.TimeWindow();
          timeWindow.date = Takeaway.Utils.getDate(moment(exception.date));
          timeWindow.startTime = moment(exception.startTime, 'HH:mm:ss');
          timeWindow.endTime = moment(exception.endTime, 'HH:mm:ss');
          category.exceptionTimes.push(timeWindow);
        }
        continue;
      }
      var orderTime = data[x];
      timeWindow = new Takeaway.TimeWindow();
      timeWindow.weekDay = orderTime.weekDay;
      timeWindow.startTime = moment(orderTime.startTime, 'HH:mm:ss');
      timeWindow.endTime = moment(orderTime.endTime, 'HH:mm:ss');
      category.orderTimes.push(timeWindow);
    }
    categories.push(category);
  }
  restaurant.categories = categories;
  restaurant.validateCategoriesOrderTime(Takeaway.Cache.serverDateTime);

  // Restaurant opening and exception times.
  restaurant.openingTimes = parseOpeningTimes(currentRestaurant.Times.deliveryopentimes);
  restaurant.pickupOpeningTimes = parseOpeningTimes(currentRestaurant.Times.pickupopentimes);
  restaurant.exceptionTimes = parseExceptionTimes(currentRestaurant.Times.exceptionsdelivery);
  restaurant.pickupExceptionTimes = parseExceptionTimes(currentRestaurant.Times.exceptionspickup);

  /**
   *
   * Set delivery areas of the restaurant
   *
   */

  if (currentDelivery) {
    var deliveryAreas = [];
    var deliveryAreasSource = [];

    if (currentDelivery.searchType === 'postcode') {
      // Postcode search
      deliveryAreasSource = currentRestaurant.Locations;
    } else if (currentDelivery.searchType === 'address') {
      // Polygon/address search
      deliveryAreasSource = [currentRestaurant.Polygons[currentDelivery.polygonIndex]];
    }
    console.log('currentDeliverySearchType', currentDelivery.searchType);
    console.log('deliveryAreasSource', deliveryAreasSource);
    console.log('country is Vietnam', !currentRestaurant.Settings.PostcodeSupport);

    for (var _x in deliveryAreasSource) {
      var _data = deliveryAreasSource[_x];
      var deliveryArea = new Takeaway.DeliveryArea();
      deliveryArea.id = _data.deliveryareaid.toString();
      deliveryArea.minimumOrderAmount = _data.minimumcosts;
      deliveryArea.deliveryCosts = _data.costs;
      deliveryArea.amountNeededForFreeDelivery = deliveryArea.getAmountNeededForFreeDelivery(deliveryArea.deliveryCosts);
      deliveryAreas.push(deliveryArea);
    }

    restaurant.deliveryAreas = deliveryAreas;
    console.log('restaurant.deliveryAreas', restaurant.deliveryAreas);
  }

  /**
   *
   * Set payment methods
   *
   */

  var paymentMethods = [];
  if (currentRestaurant.Settings.PaymentMethods !== undefined) {
    for (var _x2 in currentRestaurant.Settings.PaymentMethods) {
      var paymentDetail = currentRestaurant.Settings.PaymentMethods[_x2];
      var paymentMethod = new Takeaway.PaymentMethod();
      paymentMethod.id = paymentDetail.id;
      paymentMethod.mainId = paymentDetail.mainId;
      paymentMethod.subId = paymentDetail.subId;
      paymentMethod.name = paymentDetail.name;
      paymentMethod.transactionFixed = paymentDetail.fixed;
      paymentMethod.transactionPercentage = paymentDetail.percentage;
      paymentMethods.push(paymentMethod);
    }
  }
  restaurant.paymentMethods = paymentMethods;

  var discount = void 0;
  for (var _x3 in currentRestaurant.Settings.Discounts) {
    var value = currentRestaurant.Settings.Discounts[_x3];
    discount = new Takeaway.Discount();
    discount.id = value.id;
    discount.type = parseInt(value.type);
    discount.deliveryType = parseInt(value.deliverytype);
    discount.amount = value.discountamount;
    discount.from = value.discountfrom;
    discount.number = value.discountnumber;
    discount.percentage = value.discountpercentage;
    discount.specialPrice = value.discountprice;
    discount.productIds2D = value.productsids;
    discount.description = value.text;
    discount.discountName = value.title;
    discount.isDiscountRepeat = value.anynumber;
    discount.inclusiveSidedishes = value.includeSidedishes;
    var date = new Takeaway.TimeWindow();
    date.weekDay = value.day !== null ? parseInt(value.day) : -1;
    discount.date = date;
    restaurant.discounts.push(discount);
  }

  basket = new Takeaway.BasketController(restaurant, deliveryType);

  if ($(document.body).hasClass('step4')) {
    selectPaymentMethodByLocalStorage();

    // Adding eventhandlers for Takeaway Pay checkboxes
    basket.initTakeawayPay();
  }

  // Bad code
  // Check if there is a basketValidationResponse and update the basket with it.
  if (window.basketValidationResponse !== undefined) {
    basket.updateBasketAfterValidation(window.basketValidationResponse);
  } else {
    basket.updateUI();
  }
};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global
  $,
  format_price,
  StringBuilder,
  Pickup,
  toast,
  moment,
  MenucardProducts,
  site,
  hideAllPaymentMethods,
  hideOfflinePaymentMethods,
  showOnlinePaymentMethodsExceptBusiness,
  showOnlinePaymentMethods,
  showAllPaymentMethods,
  selectPaymentMethodById,
  getUsersDeliveryAreaId,
  app
  currentRestaurant
*/

/**
 * @author Ka Wing Chin <kawing.chin@takeaway.com>
 * @class Takeaway.BasketController
 */
if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
  var Takeaway = require('./Product');
}
(function () {
  'use strict';

  /**
   * Constructor
   * @param {Restaurant} restaurant object
   * @param {DeliveryMethod.Type} deliveryType
   * @param {int} step The current step of the flow. Not a good logic to put it here.
   */

  var BasketController = function BasketController(restaurant, deliveryType) {
    self = this;
    this.restaurant = restaurant;
    basket = new Takeaway.Basket(restaurant, deliveryType);
  };

  /**
   * @private
   */
  var basket = void 0;
  /**
   * The selected product for adding comment.
   * @private
   */
  BasketController.prototype.selectedProductCommentId = null;
  /**
   * @property {string} selectedProductComment The comment of the selected product comment.
   * It is used for temporary caching. Why? When you have a comment open and you change the basket.
   * The UI will be refreshed because of jQuery. This variable will remember what the text was.
   */
  var selectedProductComment = null;
  /**
   * @property {Restaurant}
   */
  var self = void 0;

  /**
   * First setup to have the takeaway pay logic in a separate file
   */
  var TakeawayPay = function () {
    var elements = {};
    var selectors = {
      allowancesContainer: 'js-tp-allowances-container',
      allowanceContainer: 'js-tp-single-allowance-container',
      checkbox: 'js-takeaway-pay-checkbox',
      purchaseNumber: 'js-tp-purchase-number',
      projectNumber: 'js-tp-project-number'
    };

    var cssClasses = {
      allowanceContainerDisabled: 'tp-allowance-container-disabled'
    };

    var resetElementBuffer = function resetElementBuffer() {
      elements.allowancesContainer = null;
      elements.allowanceContainers = [];
      elements.checkboxes = [];
      elements.purchaseNumberInputs = [];
      elements.projectNumberInputs = [];
    };

    /**
     * Finds the main allowances container. Which has all the allowances
     * Uses a buffer
     * @returns {Element<div>|null}
     */
    var findAllowancesContainer = function findAllowancesContainer() {
      if (!elements.allowancesContainer) {
        elements.allowancesContainer = document.querySelector('.' + selectors.allowancesContainer);
      }
      return elements.allowancesContainer;
    };

    /**
     * Finds a takeaway allowance container by card number. This is the main container per allowance
     * Uses a buffer
     * @param cardNumber
     * @returns {Element<div>|null}
     */
    var findAllowanceContainerByCardNumber = function findAllowanceContainerByCardNumber(cardNumber) {
      if (typeof elements.allowanceContainers[cardNumber] === 'undefined') {
        elements.allowanceContainers[cardNumber] = null; // Same result as not found by querySelector
        var container = findAllowancesContainer();
        if (container) {
          elements.allowanceContainers[cardNumber] = container.querySelector('[data-allowance-container="' + cardNumber + '"]');
        }
      }
      return elements.allowanceContainers[cardNumber];
    };

    /**
     * Find an element and put it in a buffer
     * @param {Int} cardNumber
     * @param {String} bufferName
     * @param {String} selector
     * @returns {Element|null}
     */
    var findElementByCardNumber = function findElementByCardNumber(cardNumber, bufferName, selector) {
      if (_typeof(elements[bufferName]) === 'object' && elements[bufferName].hasOwnProperty('length') && // check if it is an array
      typeof elements[bufferName][cardNumber] === 'undefined') {
        elements[bufferName][cardNumber] = null;
        var allowanceContainer = findAllowanceContainerByCardNumber(cardNumber);
        if (allowanceContainer) {
          elements[bufferName][cardNumber] = allowanceContainer.querySelector(selector);
        }
      }
      return elements[bufferName][cardNumber];
    };

    /**
     * Finds the checkbox element by using a card number
     * Uses a buffer
     * @param cardNumber
     * @returns {Element|null}
     */
    var findCheckboxByCardNumber = function findCheckboxByCardNumber(cardNumber) {
      return findElementByCardNumber(cardNumber, 'checkboxes', '.' + selectors.checkbox);
    };

    /**
     * Finds the purchase number input field by using a card number.
     * Uses a buffer.
     * @param cardNumber
     * @returns {Element|null}
     */
    var findPurchaseNumberInputByCardNumber = function findPurchaseNumberInputByCardNumber(cardNumber) {
      return findElementByCardNumber(cardNumber, 'purchaseNumberInputs', '.' + selectors.purchaseNumber);
    };

    /**
     * Finds the project number input field by using a card number.
     * Uses a buffer
     * @param cardNumber
     * @returns {Element|null}
     */
    var findProjectNumberInputByCardNumber = function findProjectNumberInputByCardNumber(cardNumber) {
      return findElementByCardNumber(cardNumber, 'projectNumberInputs', '.' + selectors.projectNumber);
    };

    /**
     * Update the checkout (takeaway pay) form on init
     */
    var setCheckedStatesFromLocalStorage = function setCheckedStatesFromLocalStorage() {
      var takeawayPayContainer = findAllowancesContainer();
      if (takeawayPayContainer) {
        var currentTakeawayPayAllowances = basket.takeawayPay;
        // if we visit step4 for the first time, takeawayPayInitialized should be false
        // therefore we need to check all the takeaway pay allowances.
        // basket.takeawayPayInitialized = false
        if (basket.takeawayPayInitialized !== true) {
          var checkboxElements = takeawayPayContainer.querySelectorAll('.' + selectors.checkbox);
          checkboxElements.forEach(function (checkboxElement) {
            checkboxElement.checked = true;
          });

          basket.takeawayPayInitialized = true;
        } else if (currentTakeawayPayAllowances && currentTakeawayPayAllowances.length > 0) {
          currentTakeawayPayAllowances.forEach(function (_ref) {
            var cardNumber = _ref.cardNumber;

            var checkboxElement = findCheckboxByCardNumber(cardNumber);
            if (checkboxElement) {
              checkboxElement.checked = true;
            } else {
              // should be removed, it is in the basket, but there is no checkbox, meaning 0 value
              basket.removeTakeawayPay({ cardNumber: cardNumber });
            }
            var takeawayPayItem = currentTakeawayPayAllowances.find(function (item) {
              return item.cardNumber === cardNumber;
            });
            if (takeawayPayItem) {
              var purchaseNumberInput = findPurchaseNumberInputByCardNumber(cardNumber);
              if (takeawayPayItem.hasOwnProperty('purchaseNumber') && purchaseNumberInput) {
                purchaseNumberInput.value = takeawayPayItem.purchaseNumber;
              }
              var projectNumberInput = findProjectNumberInputByCardNumber(cardNumber);
              if (takeawayPayItem.hasOwnProperty('projectNumber') && projectNumberInput) {
                projectNumberInput.value = takeawayPayItem.projectNumber;
              }
            }
          });
        }
      }
    };

    /**
     * Add the event handlers to the takeaway pay elements.
     * Theses are the checkboxes, purchase and project number fields, and the 'open' link
     */
    var addEventHandlers = function addEventHandlers() {
      var allowanceContainer = findAllowancesContainer();
      if (allowanceContainer) {
        var $checkBoxes = allowanceContainer.querySelectorAll('.' + selectors.checkbox);
        var $purchaseNumberInputs = allowanceContainer.querySelectorAll('.' + selectors.purchaseNumber);
        var $projectNumberInputs = allowanceContainer.querySelectorAll('.' + selectors.projectNumber);

        $checkBoxes.forEach(function ($checkBox) {
          $checkBox.addEventListener('change', updateTakeawayPayValues);
        });

        $purchaseNumberInputs.forEach(function ($input) {
          $input.addEventListener('keyup', updateTakeawayPayValues);
          var maxLength = $input.getAttribute('maxlength');
          $input.addEventListener('input', function (e) {
            updateConditionsToPurchaseNumberInput(e.target, maxLength);
          });
        });

        $projectNumberInputs.forEach(function ($input) {
          $input.addEventListener('keyup', updateTakeawayPayValues);
        });
      }
    };

    var updateConditionsToPurchaseNumberInput = function updateConditionsToPurchaseNumberInput(input, maxLength) {
      if (input && maxLength) {
        // Re-add the max length
        input.setAttribute('maxlength', maxLength);
        // substring this value
        input.value = input.value.substr(0, maxLength);
      }
    };

    /**
     * Fired after every click or input field update. Syncs the form to the local storage
     * @param event
     */
    var updateTakeawayPayValues = function updateTakeawayPayValues(event) {
      var allowancesContainer = findAllowancesContainer();
      var isCheckboxClick = event && event.target && event.target.classList.contains(selectors.checkbox);
      var checkedOnChange = false;
      if (allowancesContainer) {
        var $offlineOnly = hasOfflinePaymentMethodsOnly();
        // Find all inputs and put them together
        var $checkBoxes = allowancesContainer.querySelectorAll('.' + selectors.checkbox);
        $checkBoxes.forEach(function ($checkbox) {
          var cardNumber = $checkbox.value;
          // add it, with the purchase number and project number
          var purchaseNumber = null;
          var purchaseNumberInput = findPurchaseNumberInputByCardNumber(cardNumber);
          if (purchaseNumberInput) {
            purchaseNumber = purchaseNumberInput.value;
          }

          var projectNumber = null;
          var projectNumberInput = findProjectNumberInputByCardNumber(cardNumber);
          if (projectNumberInput) {
            projectNumber = projectNumberInput.value;
          }

          if (isCheckboxClick === false && (purchaseNumber || projectNumber) && !$checkbox.checked) {
            $checkbox.checked = true; // check the allowance if a value can be found
            checkedOnChange = true;
          }

          if ($offlineOnly === false && $checkbox.checked) {
            var allowance = $checkbox.dataset['allowance'];

            basket.updateTakeawayPay({ cardNumber: cardNumber, allowance: allowance, purchaseNumber: purchaseNumber, projectNumber: projectNumber });
          } else {
            basket.removeTakeawayPay({ cardNumber: cardNumber });
          }
        });

        if (isCheckboxClick || checkedOnChange) {
          self.updateUI();

          if (basket.getTakeawayPayDiscount()) {
            setDefaultOnlinePayment();
          } else {
            selectPaymentMethodById(self.getPaymentMethod().id);
          }
        }
      }
    };

    /**
     * Disables all checkboxes and input fields. Fired if there are only offline payment methods (like cash)
     */
    var disableUITakeawayPayCheckboxes = function disableUITakeawayPayCheckboxes() {
      var allowancesContainer = findAllowancesContainer();
      if (allowancesContainer) {
        allowancesContainer.classList.add('tp-allowances-disabled');
        var checkboxes = allowancesContainer.querySelectorAll('.' + selectors.checkbox);
        var purchaseNumberFields = allowancesContainer.querySelectorAll('.' + selectors.purchaseNumber);
        var projectNumberFields = allowancesContainer.querySelectorAll('.' + selectors.projectNumber);
        checkboxes.forEach(function (checkbox) {
          // chose disabled, could also be removed, but should already be removed
          checkbox.setAttribute('disabled', true);
        });
        purchaseNumberFields.forEach(function (purchaseNumberField) {
          purchaseNumberField.setAttribute('disabled', true);
        });
        projectNumberFields.forEach(function (projectNumberField) {
          projectNumberField.setAttribute('disabled', true);
        });
      }
    };

    /**
     * Render the Takeaway Pay element in the Basket
     */
    var updateUI = function updateUI() {
      var $totalElement = document.querySelector('.js-total-costs-row');
      var $transactionCosts = document.querySelector('.js-basket-sum .js-basket-transaction-costs');
      var discountValue = self.getTakeawayPayDiscount();
      // disable Takeaway Pay on cash only restaurant or when allowance is 0
      if (hasOfflinePaymentMethodsOnly() === true) {
        disableUITakeawayPayCheckboxes();
      } else {
        // disable zero allowance elements
        var allowanceContainers = document.querySelectorAll('.' + selectors.allowanceContainer);
        // Disable if no checkbox can be found
        allowanceContainers.forEach(function (allowanceContainer) {
          var checkbox = allowanceContainer.querySelector('.' + selectors.checkbox);
          if (!checkbox) {
            allowanceContainer.classList.add(cssClasses.allowanceContainerDisabled);
          } else {
            allowanceContainer.classList.remove(cssClasses.allowanceContainerDisabled);
          }
        });
      }

      // No payments found on Step3
      // If there is no discount don't show it
      if (discountValue) {
        // Get the html template
        var $takeawayPayElement = document.querySelector('.js-takeaway-pay-template').cloneNode(true);
        $takeawayPayElement.style.display = 'flex';
        $takeawayPayElement.innerHTML = $takeawayPayElement.innerHTML.replace('{{price}}', discountValue);
        if ($transactionCosts) {
          // If there are transaction costs place the takeway pay above the transaction costs.
          $transactionCosts.parentNode.insertBefore($takeawayPayElement, $transactionCosts);
        } else {
          // If there are no transaction costs place the takeway pay above the Total
          $totalElement.parentNode.insertBefore($takeawayPayElement, $totalElement);
        }
      }
    };

    /**
     * Checks if restaurant has only offline payment methods
     * @returns {null|boolean}
     */
    var hasOfflinePaymentMethodsOnly = function hasOfflinePaymentMethodsOnly() {
      var takeawayPayContainer = document.querySelector('.js-takeaway-pay');
      if (!takeawayPayContainer) {
        return null;
      }

      var dataFromContainer = takeawayPayContainer.getAttribute('data-hasOfflinePaymentMethodsOnly');
      if (!dataFromContainer) {
        return null;
      }

      return dataFromContainer === 'true';
    };

    /**
     * Expose what is needed
     */
    return {
      resetElementBuffer: resetElementBuffer,
      setCheckedStatesFromLocalStorage: setCheckedStatesFromLocalStorage,
      addEventHandlers: addEventHandlers,
      updateTakeawayPayValues: updateTakeawayPayValues,
      updateUI: updateUI
    };
  }();

  BasketController.prototype.showRestaurantIsClosed = function () {
    var deliveryAreaId = this.restaurant.deliveryAreaId;

    // When Pickup mode on, restaurant.deliveryAreaId is undefined, therefore getUsersDeliveryAreaId() from MenuCard.js is used
    // instead of filling in restaurant.deliveryAreaId which could possibly cause other areas to fail.
    if (!deliveryAreaId) {
      deliveryAreaId = getUsersDeliveryAreaId();

      // If there's still no deliveryAreaId, we need a fallback, fetch data from the go back button
      if (deliveryAreaId === null) {
        deliveryAreaId = document.querySelector('.js-go-back-button').href;
      } else {
        // Still going wrong, report to Instana
        app.services.report.error('[STEP3 - REDIRECT ERROR] - Could not find any proper location, unable to redirect');
      }
    }

    var sb = new StringBuilder();
    sb.append(this.restaurant.name).append(' ').append(this.restaurant.translations.restaurantClosed2).append(' ').append('<a href=\'').append(deliveryAreaId).append('\' class=\'link\'>').append(this.restaurant.translations.restaurantClosed3).append('</a>').append('.');
    toast(sb.toString());
  };

  BasketController.prototype.addProduct = function (id) {
    var product = getProduct(id);
    if (product === null) {
      console.log('failed to add product, trying to cheat by calling the method?');
      return;
    }
    var result = basket.addProduct(product);
    switch (result) {
      case Takeaway.Basket.PRODUCT.SUCCESS:
        this.updateUI();
        break;
      case Takeaway.Basket.PRODUCT.RESTAURANT_CLOSED:
        this.showRestaurantIsClosed();
        break;
      case Takeaway.Basket.PRODUCT.CATEGORY_UNAVAILABLE:
        var category = this.restaurant.getCategoryById(product.categoryId);
        var sb = new StringBuilder();
        sb.append(this.restaurant.translations.categoryClosed1).append(' ').append(category.currentOrderTime.endTime.format('HH:mm')).append(this.restaurant.translations.categoryClosed2);
        toast(sb.toString());
        break;
      default:
        console.log('Unknown error adding product');
        break;
    }
  };

  BasketController.prototype.removeProduct = function (event, id) {
    event.stopPropagation();
    basket.removeProduct(id);
    if (id === this.selectedProductCommentId) {
      this.selectedProductCommentId = null;
      selectedProductComment = null;
    }

    var voucherContainer = document.getElementById('ivouchercontainerr');

    // Remove voucher. This is bad code to handle it like this. Global.
    if (basket.totalProducts === 0 && voucherContainer !== null) {
      window.removeVoucher();
    }
    this.updateUI();
  };

  BasketController.prototype.increaseProduct = function (event, id) {
    event.stopPropagation();
    basket.increaseProduct(id);
    this.updateUI();
    // put the focus back on the button
    var addButton = this.getCartRowButton(id, '.cart-meal-edit-add');
    if (addButton) {
      addButton.focus();
    }
  };

  BasketController.prototype.getCartRowButton = function (id, selector) {
    var cartRow = document.getElementById(id);
    return cartRow ? cartRow.querySelector(selector) : null;
  };

  BasketController.prototype.decreaseProduct = function (event, id) {
    event.stopPropagation();
    if (basket.decreaseProduct(id)) {
      if (id === this.selectedProductCommentId) {
        this.selectedProductCommentId = null;
        selectedProductComment = null;
      }

      var voucherContainer = document.getElementById('ivouchercontainerr');

      // Remove voucher. This is bad code to handle it like this. Global.
      if (basket.totalProducts === 0 && voucherContainer !== null) {
        window.removeVoucher();
      }
    }
    this.updateUI();
    var addButton = this.getCartRowButton(id, '.cart-meal-edit-delete');
    if (addButton) {
      addButton.focus();
    }
  };

  /**
   * @param event
   * @param id
   * @param {boolean} skip Skip the validation and get the comment from the local variable instead of the local storage.
   */
  BasketController.prototype.openProductComment = function (event, id, skip) {
    if (event) {
      event.stopPropagation();
    }
    if (!skip) {
      if (this.selectedProductCommentId === id) {
        this.closeProductComment(event, id, true);
        return;
      } else if (this.selectedProductCommentId !== null) {
        this.closeProductComment(event, this.selectedProductCommentId, true);
      }
    }

    // close other opened product comment.
    $('.cart-row.commentinput').hide();

    this.selectedProductCommentId = id;
    var comment = skip ? selectedProductComment : basket.getComment(id);
    selectedProductComment = comment;
    var commentInput = $('#commentinput-' + id);

    // cross browser solution to put the mouse cursor at the end.
    commentInput.show();
    commentInput.find('textarea').focus();
    if (comment) {
      commentInput.find('textarea').val('');
      commentInput.find('textarea').val(comment);
    }
  };

  BasketController.prototype.closeProductComment = function (event, id, save) {
    // Ugly check, becasuse of UtilityBar.js or split the method in a handler and UI logic
    if (id === null) {
      return;
    }
    // stopPropagation() should be after null check, otherwise it breaks many click event handlers (payment icons,
    // location panel, vouchers etc.)
    if (event) {
      event.stopPropagation();
    }

    var commentInput = $('#commentinput-' + id);
    if (save) {
      var comment = commentInput.find('textarea').val().replace(/<(?:.|\n)*?>/gm, '');
      basket.addComment(id, comment);
      this.selectedProductCommentId = null;
      updateBasketUI();
    } else {
      commentInput.find('textarea').val('');
      commentInput.hide();
      this.selectedProductCommentId = null;
    }
  };

  BasketController.prototype.deleteProductComment = function (event, id) {
    if (event) {
      event.stopPropagation();
    }
    var commentInput = $('#commentinput-' + id);
    commentInput.find('textarea').val('');
    basket.addComment(id, '');
    this.selectedProductCommentId = null;
    selectedProductComment = null;
    updateBasketUI();
  };

  /**
   * It only set the text in a cache. A bit cheaty, but see doc about selectedProductComment
   */
  BasketController.prototype.addProductComment = function (event, id) {
    var commentInput = $('#commentinput-' + id);
    selectedProductComment = commentInput.find('textarea').val();
  };

  /**
   * Get the delivery type that is set
   * @return {Takeaway.DeliveryMethod.Type} which is an int.
   */
  BasketController.prototype.getDeliveryMethod = function () {
    return basket.deliveryType;
  };

  /**
   * Switch delivery type.
   * @param {DeliveryMethod.Type} deliveryType Takeaway.DeliveryMethod.Type
   */
  BasketController.prototype.switchDeliveryType = function (deliveryType, force) {
    return basket.switchDeliveryType(deliveryType, force);
  };

  BasketController.prototype.getBasketJson = function () {
    return basket.getBasketJson();
  };

  /**
   * Validate the selected delivery or pickup time. If there is an invalid category, only the first one will be returned.
   * @param {String} deliveryTimeString The time the user selected.
   */
  BasketController.prototype.validateDeliveryTime = function (deliveryTimeString) {
    var deliveryTimeNotification = $('#deliverytime-notification');
    deliveryTimeNotification.text('');
    deliveryTimeNotification.addClass('hidden');
    var deliveryTime = void 0;
    if (deliveryTimeString === 'asap') {
      deliveryTime = Takeaway.Cache.serverDateTime.time;
    } else {
      deliveryTime = Takeaway.Utils.timeToToday(moment(deliveryTimeString, 'HH:mm'), Takeaway.Cache.serverDateTime.time);
    }

    var obj = basket.validateDeliveryTime(deliveryTime);
    if (obj === null) {
      return;
    }

    var translations = self.restaurant.translations;

    var sb = new StringBuilder();
    sb.append(translations.timedProduct1).append(' \'').append(obj.product.productName).append('\' ').append(translations.timedProduct2).append(' ').append(obj.category.currentOrderTime.startTime.format('HH:mm')).append(' ').append(translations.timedProduct3).append(' ').append(obj.category.currentOrderTime.endTime.format('HH:mm')).append(translations.timedProduct4).append(' ').append('<a href=\'/' + self.restaurant.url + '\'>').append(translations.timedProduct5).append('</a>').append(' ').append(translations.timedProduct6);
    $('#deliverytime-notification').html(sb.toString());
    $('#deliverytime-notification').removeClass('hidden');
  };

  BasketController.prototype.proceedCheckout = function () {
    if (window.app.services.headerService.pickupDisabled(Pickup.isPickupStatus())) {
      return;
    }

    // Before we proceed with checkout, we want to save possibly open product comments, so these don't get lost
    this.closeProductComment(null, this.selectedProductCommentId, true);

    if (basket.isCheckoutValid() === true) {
      document.location = this.restaurant.orderUrl;
    }
  };

  BasketController.prototype.calculateTotalPrice = function () {
    basket.calculateTotalPrice();
  };

  BasketController.prototype.resetTakeawayPayInitialized = function () {
    basket.resetTakeawayPayInitialized();
  };

  BasketController.prototype.updateBasketAfterValidation = function (data) {
    // Business logic for updating and removing products.
    basket.updateBasketAfterValidation(data);
    this.updateUI();
  };

  BasketController.prototype.saveBasket = function () {
    basket.saveBasket();
  };

  /**
   * Products will be send to the server for validation.
   * Unused.
   */
  BasketController.prototype.validateBasket = function (callback) {
    if (basket.deliveryType === Takeaway.DeliveryMethod.Delivery) {
      if (this.restaurant.deliveryAreaId === undefined) {
        console.log('postcode is missing');
        if (callback !== undefined && callback !== null) {
          callback(false);
        }
        return false;
      }
    }

    if (!basket.isCheckoutAllowed || basket.isValidateBasketByServer) {
      if (callback !== undefined && callback !== null) {
        callback(false);
      }
      return false;
    }

    basket.validateBasketByServer(function (result) {
      var _this = this;

      if (result.productMismatch) {
        for (var x in result.productMismatches) {
          var productMismatch = result.productMismatches[x];
          parseProductMismatch(productMismatch);
        }
      }

      if (result.productMissing) {
        var sb = new StringBuilder();
        var i = result.productMissings.length;

        var _loop = function _loop() {
          var productMissingId = result.productMissings[i];
          var productMissing = basket.basketProducts.filter(function (x) {
            return x.uniqueId === productMissingId;
          })[0];

          if (productMissing === undefined) {
            return 'continue';
          }

          sb.append(productMissing.productName).append('<br />');

          if (productMissing.size !== null) {
            var sideDishesUI = [];
            if (productMissing.productName !== productMissing.size.sizeName) {
              sideDishesUI.push(productMissing.size.sizeName);
            }

            if (productMissing.size.sideDishes.length > 0) {
              sideDishesUI.push(generateSideDishString(productMissing.size.sideDishes));
            }
            sb.append(sideDishesUI.join(', ')).append('<br />');
          }
          sb.append('<br />');
          basket.removeProduct(productMissing.uniqueId);
        };

        while (i--) {
          var _ret = _loop();

          if (_ret === 'continue') continue;
        }
      }

      // Last check if the basket is still complete.
      var count = 0;

      var _loop2 = function _loop2(_i) {
        var basketProduct = basket.basketProducts.filter(function (x) {
          if (x.uniqueId === result.productExistingIds[_i]) {
            count++;
          }
        }.bind(_this));
      };

      for (var _i in result.productExistingIds) {
        _loop2(_i);
      }
      if (count !== result.productExistingIds.length) {
        throw new Error('Something went wrong with the validation');
      }

      basket.calculateTotalPrice();
      basket.saveBasket();
      this.updateUI();

      var endResult = {
        isValid: !result.productMismatch && !result.productMissing,
        isMismatch: result.productMismatch,
        isMissing: result.productMissing,
        errorMessage: result.message,
        redirectUrl: result.url
      };

      if (callback !== undefined && callback !== null) {
        callback(endResult);
      }
    }.bind(this));
  };

  // @delete
  var parseProductMismatch = function parseProductMismatch(productMismatch) {
    var basketProduct = basket.basketProducts.filter(function (x) {
      return x.uniqueId === productMismatch.uniqueId;
    })[0];

    if (basketProduct === undefined) {
      return;
    }

    // The data doesn't distinct product and size.
    if (basketProduct.size !== null) {
      basketProduct.size.price = productMismatch.singlePrice;
      basketProduct.size.pricePickup = productMismatch.singlePricePickup;
      basketProduct.deliveryType = parseInt(productMismatch.deliveryType);
      basketProduct.ignoreMinimumOrderValue = productMismatch.ignoreMinimumOrderValue;
    } else {
      basketProduct.basePrice = productMismatch.singlePrice;
      basketProduct.basePricePickup = productMismatch.singlePricePickup;
      basketProduct.deliveryType = parseInt(productMismatch.deliveryType);
      basketProduct.ignoreMinimumOrderValue = productMismatch.ignoreMinimumOrderValue;
    }

    var _loop3 = function _loop3(x) {
      var sideDishMismatch = productMismatch.sideDishes[x];
      basketProduct.size.sideDishes.filter(function (s) {
        if (s.id === sideDishMismatch.id) {
          s.price = parseFloat(sideDishMismatch.price);
          s.pricePickup = parseFloat(sideDishMismatch.price_pickup);
          s.ignoreMinimumOrderValue = sideDishMismatch.ignoreMinimumOrderValue;
        }
      });
    };

    for (var x in productMismatch.sideDishes) {
      _loop3(x);
    }
    basketProduct.updateTotalPrice();
    return basketProduct;
  };

  /**
   * Set payment method.
   * @param {string} id of the payment method
   */
  BasketController.prototype.setPaymentMethod = function (id) {
    basket.setPaymentMethod(id);
    this.updateUI();
  };

  /**
   * Get the current payment method.
   * @return the current selected payment method.
   */
  BasketController.prototype.getPaymentMethod = function () {
    return basket.paymentMethod;
  };

  BasketController.prototype.getTakeawayPayDiscount = function () {
    var discount = basket.getTakeawayPayDiscount();
    if (discount) {
      return format_price(discount, self.restaurant.currency);
    }
  };

  BasketController.prototype.initTakeawayPay = function () {
    TakeawayPay.resetElementBuffer();
    TakeawayPay.setCheckedStatesFromLocalStorage();
    TakeawayPay.addEventHandlers();
    TakeawayPay.updateTakeawayPayValues(); // fire it once for updating
    self.calculateTotalPrice();
    self.updateUI();
  };

  BasketController.prototype.addVoucher = function (voucherObj) {
    basket.addVoucher(voucherObj);
    this.updateUI();
  };

  BasketController.prototype.removeVoucher = function () {
    basket.removeVoucher();
    this.updateUI();
  };

  BasketController.prototype.resetTakeawayPay = function () {
    basket.resetTakeawayPay();
  };

  /**
   * Retrieve the product data from object literal.
   * @return Product
   */
  var getProduct = function getProduct(id) {
    for (var x in MenucardProducts) {
      var dataProduct = MenucardProducts[x];
      if (dataProduct.productId === id && dataProduct.categoryId !== '0') {
        var product = new Takeaway.Product();
        product.id = dataProduct.productId;
        product.productName = dataProduct.name;
        product.count = getProductCount(dataProduct);
        product.basePrice = dataProduct.price;
        product.basePricePickup = dataProduct.price_pickup;
        product.categoryId = dataProduct.categoryId;
        product.deliveryType = dataProduct.deliverymethod;
        product.ignoreMinimumOrderValue = !dataProduct.is_meal;

        if (dataProduct.hasSizes) {
          if (dataProduct.sizes === undefined) {
            return null;
          }

          for (var xx in dataProduct.sizes) {
            var dataSize = dataProduct.sizes[xx];
            if (dataSize.isSelected) {
              var size = new Takeaway.ProductSize();
              size.id = dataSize.id;
              size.sizeName = dataSize.name;
              size.price = dataSize.price;
              size.pricePickup = dataSize.price_pickup;
              size.sideDishes = [];
              size.deliveryType = parseInt(dataSize.deliverytype);
              size.ignoreMinimumOrderValue = !dataSize.is_meal;
              for (var xxx in dataSize.sidedishgroups) {
                var dataGroup = dataSize.sidedishgroups[xxx];
                for (var xxxx in dataGroup.sidedishes) {
                  var dataSidedish = dataGroup.sidedishes[xxxx];
                  if (dataSidedish.isSelected) {
                    var sideDish = new Takeaway.SideDish();
                    sideDish.id = dataSidedish.id;
                    sideDish.sideDishName = dataSidedish.name;
                    sideDish.price = dataSidedish.price;
                    sideDish.pricePickup = dataSidedish.price_pickup;
                    sideDish.ignoreMinimumOrderValue = !dataSidedish.is_meal;
                    size.sideDishes.push(sideDish);
                  }
                }
              }
              product.size = size;
              break;
            }
          }
        }
        return product;
      }
    }
    return null;
  };

  var getProductCount = function getProductCount(product) {
    if (!product.hasSizes) {
      return 1;
    }

    var count = 1;
    for (var x in product.sizes) {
      var size = product.sizes[x];
      if (size.isSelected) {
        count = $('#iproductnumber' + size.id).attr('value');
        break;
      }
    }
    if (count !== undefined) {
      return parseInt(count, 10);
    }
    return count;
  };

  /**
   * Update basket UI
   */
  BasketController.prototype.updateUI = function () {
    updateBasketUtilityBar();
    updateBasketUI();
    updateBasketMissingUI();
    updatePaymentUI();
    updateVoucherUI();
    TakeawayPay.updateUI();
    updateLeaveAtDoor();
  };

  var updateLeaveAtDoor = function updateLeaveAtDoor() {
    if (!document.querySelector('.payment-method-type-online') || Pickup.isPickupStatus()) {
      return;
    }

    // main criteria for showing msg
    var onlinePaymentMethodSelected = document.getElementsByClassName('payment-method-type-online paymentbuttonchecked').length > 0 ? true : false;
    // certain edge cases (empty session first land on checkout) onlinePaymentMethodSelected is not valid fed-14329
    var takeawayPayCoversTotal = basket.totalPrice === 0 && basket.getTakeawayPayDiscount() > 0;

    if (onlinePaymentMethodSelected || takeawayPayCoversTotal) {
      $('.step4 .checkout-orderbutton .leave-at-door').show();
      $('.step4 .checkout-orderbutton .leave-at-door-select-online').hide();
    } else {
      $('.step4 .checkout-orderbutton .leave-at-door').hide();
      $('.step4 .checkout-orderbutton .leave-at-door-select-online').show();
    }
  };

  var setDefaultOnlinePayment = function setDefaultOnlinePayment() {
    var buttonCheckedClass = 'paymentbuttonchecked';
    var onlinePaymentClass = 'payment-method-type-online';
    var offlinePaymentClass = 'payment-method-type-offline';

    var paymentMethodElement = document.querySelector('.' + onlinePaymentClass + '.' + buttonCheckedClass);
    var businessPMethodElementChecked = document.querySelector('.' + onlinePaymentClass + '.paymentmethod7.' + buttonCheckedClass);
    // if the current selected payment method is not a online payment method
    // we check the first online payment method

    // If the current payment is already an online payment
    // we can leave it at the current payment
    if (paymentMethodElement && !businessPMethodElementChecked) {
      return;
    }
    var paymentMethodsClass = 'paymentmethods';
    var onlinePaymentElement = document.querySelector('.' + paymentMethodsClass + ' .' + onlinePaymentClass);
    var offlinePaymentElement = document.querySelector('.' + paymentMethodsClass + ' .' + offlinePaymentClass);

    var firstPaymentMethod = onlinePaymentElement || offlinePaymentElement;
    var newId = firstPaymentMethod.querySelector('input');
    if (newId) {
      // Remove all checked values
      var checkedButtons = Array.from(document.querySelectorAll('.' + buttonCheckedClass));
      checkedButtons.forEach(function ($checkedButton) {
        return $checkedButton.classList.remove(buttonCheckedClass);
      });

      // Select the first payment icon
      firstPaymentMethod.classList.add(buttonCheckedClass);

      // For mobile we use the dropdown, we select the first mobile value here
      var dropdownPayment = document.querySelector('#iselectpayment');
      dropdownPayment.value = newId.value;
      // Set the first element to checked
      newId.checked = true;
      self.setPaymentMethod(newId.value);
    }
  };

  /**
   * Update the UI of the utility bar
   */
  var updateBasketUtilityBar = function updateBasketUtilityBar() {
    var productCount = void 0;
    var $basketButton = $('.js-basket-button');

    if ($basketButton.length > 0) {
      var $amountElement = $basketButton.find('.js-btn-cart-amount');
      var $basketIcon = $basketButton.find('.js-btn-cart-icon');
      var $priceElement = $basketButton.find('.js-btn-cart-price');

      productCount = basket.totalProducts;

      $priceElement.html('(' + format_price(basket.totalPrice, self.restaurant.currency) + ')');
      $amountElement.html(productCount);

      if (productCount > 0) {
        $basketButton.addClass('btn-basket-products');

        if ($basketButton.parent().hasClass('basket-status-empty')) {
          $basketButton.parent().removeClass('basket-status-empty');
        }

        $basketIcon.addClass('pulse-button');
        setTimeout(function () {
          $basketButton.find('.js-btn-cart-icon').removeClass('pulse-button');
        }, 250);

        $basketButton.addClass('highlight');
        setTimeout(function () {
          $basketButton.removeClass('highlight');
        }, 1000);
      } else {
        $basketButton.removeClass('btn-basket-products');

        if (!$basketButton.parent().hasClass('basket-status-empty')) {
          $basketButton.parent().addClass('basket-status-empty');
        }
      }
    }
  };

  var generateSideDishString = function generateSideDishString(sideDishes) {
    var stringBuilder = [];
    for (var x in sideDishes) {
      var sideDish = sideDishes[x];

      var paranthesesMatches = sideDish.sideDishName.match(/(\(.*?\))/g); // remove sidedish price string
      var nameFixed = sideDish.sideDishName;
      if (paranthesesMatches && paranthesesMatches.length > 0) {
        nameFixed = sideDish.sideDishName.replace(paranthesesMatches[paranthesesMatches.length - 1], '');
      }
      nameFixed = nameFixed.replace(/(^\s+|\s+$)/g, '');
      if (basket.deliveryType === Takeaway.DeliveryMethod.Type.Delivery && sideDish.ignoreMinimumOrderValue) {
        nameFixed = '<span class=\'cart-meal-exclude\' title=\'' + self.restaurant.translations.minimumExclusionProducts + '\'>' + nameFixed + '</span>';
      }
      stringBuilder.push(nameFixed);
    }
    return stringBuilder.join(', ');
  };

  var updateBasketUISum = function updateBasketUISum() {
    var $basketSum = $('#ibasket #sum');
    var identifierClass = 'js-subtotal-row';
    $basketSum.find('.' + identifierClass).remove(); // remove the old row if found
    var entry = $('#cart-subtotal-template').clone();
    entry.removeAttr('id');
    entry.addClass(identifierClass);
    entry.find('.cart-sum-price').html(format_price(basket.baseTotalPrice, self.restaurant.currency));
    $basketSum.append(entry.show().css('display', 'flex'));
  };

  var updateBasketUIDeliveryCosts = function updateBasketUIDeliveryCosts() {
    if (basket.deliveryType === Takeaway.DeliveryMethod.Type.Delivery && basket.totalProducts > 0) {
      var $basketSum = $('#ibasket #sum');
      var identifierClass = 'js-delivery-costs-row';
      $basketSum.find('.' + identifierClass).remove(); // remove the old row if found
      var entry = $('#cart-deliverycosts-template').clone();
      entry.removeAttr('id');
      entry.addClass(identifierClass);
      var cartSumPrice = self.restaurant.translations.free;
      if (basket.deliveryCosts > 0) {
        cartSumPrice = format_price(basket.deliveryCosts, self.restaurant.currency);
      }
      entry.find('.cart-sum-price').html(cartSumPrice);

      $basketSum.append(entry.show().css('display', 'flex'));
    }
  };

  var updateBasketUITotal = function updateBasketUITotal() {
    var $basketSum = $('#ibasket #sum');
    var identifierClass = 'js-total-costs-row';
    $basketSum.find('.' + identifierClass).remove(); // remove the old row if found
    var entry = $('#cart-totalprice-template').clone();
    entry.removeAttr('id');
    entry.addClass(identifierClass);
    entry.find('.cart-sum-price').html(format_price(basket.totalPrice, self.restaurant.currency));
    $basketSum.append(entry.show().css('display', 'flex'));
  };

  var updateBasketUIMOV = function updateBasketUIMOV() {
    // todo: check this
    var $basketSum = $('#ibasket #sum');
    var identifierClass = 'js-to-reach-minimum-row';
    $basketSum.find('.' + identifierClass).remove(); // remove the old row if found
    var isTakeawayStatus = Pickup.isTakeawayStatus();
    var deliveryAreaSet = basket.deliveryArea !== undefined;
    var movText = '';
    if (deliveryAreaSet) {
      if (isTakeawayStatus && basket.deliveryArea.minimumOrderAmount > 0) {
        movText = self.restaurant.translations.minimumReached.replace('{costs}', format_price(basket.deliveryArea.minimumOrderAmount, self.restaurant.currency));
      }
      var requirement = basket.calculateMinimumAmount(basket.minimumOrderValueTotalPrice);
      if (requirement > 0) {
        if (requirement !== basket.deliveryArea.minimumOrderAmount) {
          var entry = $('#cart-minimum-template').clone();
          entry.removeAttr('id');
          entry.addClass(identifierClass);
          entry.find('.cart-sum-price').html(format_price(requirement, self.restaurant.currency));
          $basketSum.append(entry.show().css('display', 'flex'));
        }
        if (isTakeawayStatus) {
          movText = self.restaurant.translations.minimumNotReached.replace('{restaurant}', self.restaurant.name);
          movText = movText.replace('{costs}', format_price(basket.deliveryArea.minimumOrderAmount, self.restaurant.currency));
        }
      }
    }
    var $minimumOrderAmountReached = $('.minimumorderamount-reached');
    if (isTakeawayStatus) {
      $minimumOrderAmountReached.html(movText);
    }
    if ($minimumOrderAmountReached.html().trim() === '') {
      $minimumOrderAmountReached.hide();
    } else {
      $minimumOrderAmountReached.show();
    }
  };

  /**
   * Update the UI of the basket menu.
   * So bad using jQuery
   */
  var updateBasketUI = function updateBasketUI() {
    // Reset the UI of the basket and page.
    var $missing = $('.missing');
    var $basketEl = $('#ibasket');
    var $basketCartButton = $basketEl.find('.cartbutton-button');
    var $basketSum = $basketEl.find('#sum');
    var $minimumOrderAmountReached = $('.minimumorderamount-reached');

    $missing.find('.missing_products').text('');
    $missing.hide();
    $('.mismatch').hide();
    $('#products').empty();
    $basketEl.find('#discounts').empty();
    $('#autoaddproducts').empty();
    $('#voucher').empty().hide();
    $('#cart-exclusive').hide();
    $('#cart-exclusive-only').hide();

    $basketCartButton.addClass('btn-disabled');
    $basketCartButton.attr('href', '#');
    $basketCartButton.on('click', function () {
      return false;
    });
    $('.meal-error-mismatch').hide();
    $('.meal-error-missing').hide();

    // Always show the sum
    $basketSum.empty();
    updateBasketUISum(); // shows empty result
    updateBasketUIDeliveryCosts(); // shows empty (free) result
    updateBasketUITotal(); // shows empty result
    updateBasketUIMOV(); // default text
    var $emptyText = $('#empty');
    if (basket.totalProducts === 0) {
      $emptyText.show();
      return;
    }

    $emptyText.hide();
    // Products, side dishes and comments
    for (var x in basket.basketProducts) {
      var basketProduct = basket.basketProducts[x];
      if (basketProduct.isDisabled) {
        continue;
      }

      var entry = $('#cart-single-meal-template').clone();
      entry.removeAttr('id');
      var $cartRow = entry.find('.cart-row');
      $cartRow.attr('id', basketProduct.uniqueId);
      $cartRow.data('id', basketProduct.uniqueId);
      $cartRow.data('amount', basketProduct.count);
      entry.find('.cart-meal-amount').html(basketProduct.count + 'x');
      entry.find('.cart-meal-name').html(basketProduct.productName);
      var price = entry.find('.cart-meal-price');
      price.html(format_price(basketProduct.getTotalPrice(basket.deliveryType), self.restaurant.currency));

      if (basket.deliveryType === Takeaway.DeliveryMethod.Type.Delivery && basketProduct.ignoreMinimumOrderValue) {
        price.addClass('cart-meal-exclude');
        price.attr('title', self.restaurant.translations.minimumExclusionProducts);
      }

      if (basketProduct.size !== null) {
        var sideDishesUI = [];
        if (basketProduct.productName !== basketProduct.size.sizeName) {
          sideDishesUI.push(basketProduct.size.sizeName);
        }

        if (basketProduct.size.sideDishes.length > 0) {
          sideDishesUI.push(generateSideDishString(basketProduct.size.sideDishes));
        }

        entry.find('.cart-meal-extra').html(sideDishesUI.join(', ')).show();
      }

      var commentInput = entry.find('.cart-row.commentinput');
      commentInput.find('.cart-meal-btns').children().hide();
      commentInput.attr('id', 'commentinput-' + basketProduct.uniqueId);

      if (basketProduct.comment !== null && basketProduct.comment !== '') {
        entry.find('.cart-meal-comment').html(basketProduct.comment).show();
        entry.find('.cart-meal-edit-comment').addClass('hascomment');
        commentInput.find('.cart-meal-btn.delete').show();
        commentInput.find('.cart-meal-btn.edit').show();
      } else {
        commentInput.find('.cart-meal-btn.add').show();
        commentInput.find('.cart-meal-btn.cancel').show();
      }

      if (currentRestaurant.Settings.RemarksDisabled === true) {
        entry.find('.cart-meal-edit-comment').remove();
      }

      // Create ids for mismatching and missing so it can be found with jQuery.
      // entry.find(".mismatch").attr("id", "mismatch-" + basketProduct.uniqueId);
      // entry.find(".missing").attr("id", "missing-" + basketProduct.uniqueId);

      $basketEl.find('#products').append(entry.show());
    }

    // Open the selected product comment when it was opened
    if (self.selectedProductCommentId !== null) {
      self.openProductComment(null, self.selectedProductCommentId, true);
    }

    // Discounts
    for (var _x in basket.activeDiscounts) {
      var discount = basket.activeDiscounts[_x];
      if (discount.totalPrice === 0) {
        continue;
      }

      var _entry = $('#cart-discount-template').clone();
      _entry.removeAttr('id');
      _entry.find('.cart-meal-amount').html(discount.count + 'x');

      var sb = new StringBuilder();
      sb.append(discount.discountName);
      if (discount.productNames.length > 0) {
        sb.append(' (').append(discount.productNames.join(' + ')).append(')');
      }
      _entry.find('.cart-meal-name').html(sb.toString());
      _entry.find('.cart-meal-price').html('-' + format_price(discount.totalPrice, self.restaurant.currency));
      $basketEl.find('#discounts').append(_entry.show());
    }

    // Auto add products
    for (var _x2 in basket.autoAddProducts) {
      var autoAddProduct = basket.autoAddProducts[_x2];
      var _entry2 = $('#cart-autoaddproduct-template').clone();
      _entry2.removeAttr('id');
      _entry2.find('.cart-row').data('id', autoAddProduct.id);
      _entry2.find('.cart-meal-amount').html(autoAddProduct.count + 'x');
      _entry2.find('.cart-meal-name').html(autoAddProduct.productName);
      _entry2.find('.cart-meal-price').html(format_price(autoAddProduct.getTotalPrice(basket.deliveryType), self.restaurant.currency)); // pickup support
      $basketEl.find('#autoaddproducts').append(_entry2.show());
    }

    if (basket.basketProducts.length > 0) {
      updateBasketUISum();
      updateBasketUIDeliveryCosts();

      // Delivery costs
      // Voucher
      if (basket.voucher !== null) {
        if (basket.voucherValidation.productRequired && basket.voucherValidation.minimumAmount) {
          var _entry3 = $('#cart-voucher-template').clone();
          _entry3.removeAttr('id');
          _entry3.find('.cart-sum-price').html('-' + format_price(basket.voucher.discount, self.restaurant.currency));
          $basketSum.append(_entry3.show().css('display', 'flex'));
        }
      }

      // Transaction costs
      if (basket.transactionCosts !== 0 && basket.transactionCosts !== undefined) {
        var _entry4 = $('#cart-transactioncosts-template').clone();
        _entry4.removeAttr('id');
        var _sb = new StringBuilder();
        _sb.append(self.restaurant.translations.transactionCosts);

        if (self.restaurant.translations.transactionCostsTextAlternative !== true) {
          _sb.append(' (').append(basket.paymentMethod.name).append(')');
        }

        _entry4.find('.cart-sum-name').text(_sb.toString());
        _entry4.find('.cart-sum-price').text(format_price(basket.transactionCosts, self.restaurant.currency));
        $basketSum.append(_entry4.show().css('display', 'flex'));
      }

      updateBasketUITotal();

      // Free delivery costs from
      if (basket.deliveryCosts > 0 && basket.deliveryArea.amountNeededForFreeDelivery > 0) {
        var amountNeededForFreeDelivery = format_price(basket.deliveryArea.amountNeededForFreeDelivery, self.restaurant.currency);
        var _entry5 = $('#cart-freedeliveryfrom-template').clone();
        _entry5.find('.cart-sum-name').html(_entry5.text().replace('{costs}', amountNeededForFreeDelivery));
        _entry5.removeAttr('id');
        $basketSum.append(_entry5.show());
      }
    }

    if (basket.deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      if (basket.isCheckoutAllowed) {
        $('.cartbutton-button').removeClass('btn-disabled');
        $minimumOrderAmountReached.html(self.restaurant.translations.minimumReached);
      }

      if (basket.deliveryArea !== undefined) {
        // MOV only
        if (basket.getTotalProductsMOVOnly() === 0) {
          $('#cart-exclusive-only').removeClass('hidden').css('display', 'flex');
        }
        // Minimum order amount
        updateBasketUIMOV();
      }
    } else if (basket.isCheckoutAllowed) {
      $('.cartbutton-button').removeClass('btn-disabled');
    }

    if (basket.containsExcludeProduct()) {
      $('#cart-exclusive').removeClass('hidden').show();
    }
  };

  var updateBasketMissingUI = function updateBasketMissingUI() {
    if (!$(document.body).hasClass('step4')) {
      return;
    }

    for (var x in basket.productMismatches) {
      var productMismatch = basket.productMismatches[x];
      $('#' + productMismatch.uniqueId).closest('.cart-single-meal').addClass('highlight');
    }

    for (var _x3 in basket.productMissings) {
      var _productMissing = basket.productMissings[_x3];

      var sb = new StringBuilder();
      sb.append('<strong>').append(_productMissing.productName).append('</strong>').append('<br />');

      if (_productMissing.size !== null) {
        var sideDishesUI = [];
        if (_productMissing.productName !== _productMissing.size.sizeName) {
          sideDishesUI.push(_productMissing.size.sizeName);
        }

        if (_productMissing.size.sideDishes.length > 0) {
          sideDishesUI.push(generateSideDishString(_productMissing.size.sideDishes));
        }
        sb.append('<i>').append(sideDishesUI.join(', ')).append('</i>').append('<br />');
      }
      sb.append('<br />');

      $('.missing .missing_products').append(sb.toString());
    }

    var t = self.restaurant.translations;
    if (basket.productMissings.length > 0) {
      // In the basket
      var text = basket.productMissings.length === 1 ? t.productMissingBasketSingular : t.productMissingBasketPlural;
      $('.missing .cart-meal-error').html(text);
      $('.missing').removeClass('hidden').show();

      // Show it below the order button on step 4.
      text = basket.productMissings.length === 1 ? t.productMissingSingular : t.productMissingPlural;
      $('.meal-error-missing').html(text).show();
    }

    if (basket.productMismatches.length > 0) {
      // In the basket
      var _text = basket.productMismatches.length === 1 ? t.productMismatchSingular : t.productMismatchPlural;
      $('.mismatch .cart-meal-error').html(_text);
      $('.mismatch').removeClass('hidden').show();

      // Show it below the order button on step 4.
      _text = basket.productMismatches.length === 1 ? t.productMismatchSingular : t.productMismatchPlural;
      $('.meal-error-mismatch').html(_text).show();
    }

    // Clear basket validation data
    basket.clearBasketValidationData();
  };

  /**
   * Lame. Hides the warning messages on the basket UI.
   */
  BasketController.prototype.hideWarnings = function () {
    $('#products .warning').hide();
    $('#ibasket .basketmismatch').hide();
    $('#ibasket .basketmissing').hide();
  };

  /**
   * Not good to put it here. The basket controller shouldn't handle the UI of the page.
   */
  var updateVoucherUI = function updateVoucherUI() {
    if (basket.voucher === null) {
      $('#ivouchercontainerr').show();
      $('#ivouchercontainer').empty();
      $('.paymentnormal').show();
      return;
    }
    $('#ivouchercontainerr').hide();
    var translations = self.restaurant.translations;
    var voucher = basket.voucher;
    var sb = new StringBuilder();

    if (!basket.voucherValidation.productRequired) {
      sb.append(translations.voucherProductError1).append(' <b>').append(voucher.productName).append(' </b>').append(translations.voucherProductError2).append(' ').append('<a href=\'/' + self.restaurant.url + '\'>').append(translations.voucherProductError3).append('</a>').append(' ').append(translations.voucherProductError4).append('<div class="removevoucherbutton">').append('<a class="button_white button_white_checkvoucher" href="#" onclick="removeVoucher(); return false;">').append('<span>').append(self.restaurant.translations.voucherRemove).append('</span>').append('</a>').append('</div>').append('</div>');
      $('#ivouchercontainer').html(sb.toString());
      return;
    }

    if (!basket.voucherValidation.minimumAmount) {
      sb.append(translations.voucherMinimumError1).append(' ').append('<b>').append(format_price(voucher.minimumOrderAmount, self.restaurant.currency)).append('</b> ').append(translations.voucherMinimumError2).append(' ').append('<a href=\'/' + self.restaurant.url + '\'>').append(translations.voucherMinimumError3).append('</a>').append(' ').append(translations.voucherMinimumError4).append('<div class="removevoucherbutton">').append('<a class="button_white button_white_checkvoucher" href="#" onclick="removeVoucher(); return false;">').append('<span>').append(self.restaurant.translations.voucherRemove).append('</span>').append('</a>').append('</div>').append('</div>');
      $('#ivouchercontainer').html(sb.toString());
      return;
    }

    switch (Number(voucher.type)) {
      case Takeaway.Voucher.Type.Credit:
        sb.append(translations.voucherSummary1).append(' ').append('<b>').append(format_price(voucher.initialCredit, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary2).append(' ').append(translations.voucherSummary7).append(' ').append('<b>').append(format_price(voucher.currentCredit, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary8).append(' ');
        if (voucher.remainingPayment > 0) {
          sb.append(translations.voucherSummary5).append(' ').append('<b>').append(format_price(voucher.remainingPayment, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary6);
        } else {
          sb.append(translations.voucherSummary3).append(' ').append('<b>').append(format_price(voucher.basedOnTotalPrice, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary4);
        }
        break;
      case Takeaway.Voucher.Type.Discount:
        if (voucher.amount > 0) {
          sb.append(translations.voucherSummary1).append(' ').append('<b>').append(format_price(voucher.amount, self.restaurant.currency)).append(' ');
        } else {
          sb.append(translations.voucherSummary1).append(' ').append('<b>').append(voucher.percentage, self.restaurant.currency).append('% ');
        }
        sb.append('</b>').append(' ').append(translations.voucherSummary2).append(' ').append(translations.voucherSummary3).append(' ').append('<b>').append(format_price(voucher.discount, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary4).append(' ');

        if (voucher.remainingPayment > 0) {
          sb.append(translations.voucherSummary5).append(' ').append('<b>').append(format_price(voucher.remainingPayment, self.restaurant.currency)).append('</b>').append(' ').append(translations.voucherSummary6);
        }
        break;
    }

    var message = sb.toString();
    sb.clear();
    sb.append('<div class=\'vouchersummary\'>').append('<b>').append(self.restaurant.translations.voucherAdded).append('</b>').append('<p>').append(message).append('</p>').append('<div class="removevoucherbutton">').append('<a class="button_white button_white_checkvoucher" href="#" onclick="removeVoucher(); return false;">').append('<span>').append(self.restaurant.translations.voucherRemove).append('</span>').append('</a>').append('</div>').append('</div>');

    $('#ivouchercontainer').html(sb.toString());
  };

  /**
   * Not good to put it here. The basket controller shouldn't handle the UI of the page.
   */
  var updatePaymentUI = function updatePaymentUI() {
    if (!$(document.body).hasClass('step4')) {
      return;
    }

    if (basket.paymentMethod === null) {
      return;
    }

    switch (basket.paymentMethod.id) {
      case Takeaway.PaymentMethod.ID.Cash:
        var countryCode = site.cc ? parseInt(site.cc) : null;
        var possiblePayments = Takeaway.Utils.getPossibleCashPayments(basket.totalPrice, Takeaway.Utils.getDenominations(countryCode));
        // remove the default 'select option' option
        $('#ipayswith option:gt(0)').remove();
        var $el = $('#ipayswith');
        $el.empty();
        for (var x in possiblePayments) {
          var value = possiblePayments[x];
          var label = format_price(value, self.restaurant.currency);
          // send empty value so checkout.inc knows it is the exact amount being paid with
          if (x === '0') {
            $el.append($('<option></option>').attr('value', '').addClass('pulldown').html(self.restaurant.translations.exactCash + ': ' + label));
          } else {
            $el.append($('<option></option>').attr('value', value).addClass('pulldown').html(label));
          }
        }
        break;
      default:
        break;
    }
    $('.paymentdetailsbox').children().hide();
    var paymentMethodId = basket.paymentMethod.id;
    if (basket.paymentMethod.mainId !== undefined) {
      paymentMethodId = basket.paymentMethod.mainId;
    }
    var el = $('#payment-case-' + paymentMethodId);
    el.show();
    var payment = el.find('.var-payment-method');
    payment.text(basket.paymentMethod.name);
    var costs = el.find('.var-costs');
    costs.html(format_price(basket.transactionCosts, self.restaurant.currency));
    var percentage = el.find('.js-var-costs-percentage');
    if (percentage.length > 0) {
      percentage.text(basket.paymentMethod.transactionPercentage);
    }
    var transActionCostHolder = $('.transaction-cost-holder');
    if (basket.transactionCosts > 0) {
      transActionCostHolder.show();
    } else {
      transActionCostHolder.hide();
    }

    // pickup should hide delivery only methods.
    if (basket.deliveryType === Takeaway.DeliveryMethod.Type.Delivery) {
      if (!isVoucherActive()) {
        $('.paymentmethod-delivery-only').show();
      }
    } else {
      if (!isVoucherActive()) {
        $('.paymentmethod-delivery-only').hide();
      }
    }
  };

  var isVoucherActive = function isVoucherActive() {
    var takeawayPayDiscount = basket.getTakeawayPayDiscount();
    if (basket.voucher !== null || takeawayPayDiscount) {
      if (basket.totalPrice === 0) {
        hideAllPaymentMethods();
        // Determine if the amount is covered by the voucher or takeaway pay
        // Or both, then it will show takeaway pay
        // Show message that everything is paid with the voucher
        // should only be there if it is used
        if (takeawayPayDiscount) {
          var coveredByTakeawayPayText = document.querySelector('.js-covered-by-takeaway-pay');
          if (coveredByTakeawayPayText) {
            coveredByTakeawayPayText.style.display = 'block';
          }
        } else {
          var coveredByVoucherText = document.querySelector('.js-covered-by-voucher');
          if (coveredByVoucherText) {
            coveredByVoucherText.style.display = 'block';
          }
        }
      } else {
        hideOfflinePaymentMethods();
        // TakeawayPay and businessPayment not to be combined
        if (takeawayPayDiscount) {
          showOnlinePaymentMethodsExceptBusiness();
        } else {
          showOnlinePaymentMethods();
        }
      }
      return true;
    } else {
      showAllPaymentMethods();
      return false;
    }
  };

  if (typeof exports !== 'undefined') {
    // Support Node.js specific `module.exports` (which can be a function)
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = BasketController;
    }
    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
    exports.BasketController = BasketController;
  } else {
    Takeaway.BasketController = BasketController;
  }
})();
/* global
  axios,
  site,
  moment,
  Takeaway
*/

var setTime = function setTime(time) {
  var normalizedServerTime = Takeaway.Utils.normalizeServerTime(time);
  window.app.setState({ normalizedServerTime: normalizedServerTime });
  console.log('=== setTime() normalizedServerTime', normalizedServerTime);
};

var setTimeByServerTime = function setTimeByServerTime() {
  var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

  var maxAttempts = 2;
  var timeout = 500; // In miliseconds
  var url = site.aPath + 'xHttp/get-server-time';
  var config = { timeout: timeout };
  console.log('=== setTimeByServerTime() retry', retry);

  axios.get(url, config).then(function (response) {
    var date = response.headers.date;
    console.log('=== setTimeByServerTime() Using response date', date);
    setTime(Takeaway.Utils.dateToTimestamp(date));
  }).catch(function (error) {
    var date = error.response && error.response.headers.date;
    // Even if we get 4xx, 5xx responses, we can use its header time
    if (date) {
      console.log('=== setTimeByServerTime() Using error response date', date);
      setTime(Takeaway.Utils.dateToTimestamp(date));
      return;
    }
    // If it's a timeout error, retry if possible by calling itself recursively
    if (retry < maxAttempts) {
      setTimeByServerTime(retry + 1);
    }
  });
};

// Config
moment.tz.add(site.tzData);
moment.tz.setDefault(site.tz);
// Set default time using browser time as a fallback method
setTime(moment.now());
// Try to update time via server's time
setTimeByServerTime();
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global $, Cookies, site */

var Helper = { // eslint-disable-line no-unused-vars
  /**
   * Php equivalent of htmlspecialchars
   * @param text {string}
   * @return {string}
   */
  escapeHtml: function escapeHtml(text) {
    var map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text ? text.replace(/[&<>"']/g, function (m) {
      return map[m];
    }) : '';
  },

  /**
   * Decoder for Php function htmlentities
   * @param text {string}
   * @return {string}
   */
  decodeHtmlEntities: function decodeHtmlEntities(text) {
    var tempElement = document.createElement('canvas');
    tempElement.insertAdjacentHTML('beforeend', text);
    var result = tempElement.textContent;
    tempElement.remove();
    return result;
  },

  groupBy: function groupBy(array, callback) {
    return array.reduce(function (groups, item) {
      var val = callback(item);
      groups[val] = groups[val] || [];
      groups[val].push(item);
      return groups;
    }, {});
  },

  /**
   * Returns whether body has given class
   * document.body is not defined until the document.readyState is interactive. That's why we should use invariant() to
   * check. But "app" and "invariant" are globally defined in window.app.js file and sometimes the file is not loaded for a
   * reason we don't know yet. Maybe slow connection... So that's why we get "invariant is not defined" errors on
   * production. If one day we can fix "app is not defined" errors, we can retry to use invariant().
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
   * @param page {string}
   * @returns {boolean}
   */
  isPage: function isPage(page) {
    var $body = document.body;
    // invariant($body instanceof HTMLElement, 'document.body is not an instance of HTMLElement')
    return $body instanceof HTMLElement ? $body.classList.contains(page) : false;
  },

  /**
   * Returns whether tracking is allowed for the country
   * @returns {boolean}
   */
  isTrackingAllowed: function isTrackingAllowed() {
    if (site.cookieWall) {
      return Cookies.get('cookieConsent') === 'full';
    } else {
      return true;
    }
  },

  /**
   * Returns whether tracking is enabled for the browser
   * @returns {boolean}
   */
  isTrackingAvailable: function isTrackingAvailable() {
    return _typeof(window.dataLayer) === 'object';
  },

  /**
   * $(document).ready equivalent for the project
   * TODO Put every JS file/code just before the closing </body> tag,
   * TODO  then we won't need this ready function
   * @param fn
   */
  ready: function ready(fn) {
    if (document.readyState !== 'loading') {
      fn();
    } else {
      document.addEventListener('DOMContentLoaded', fn);
    }
  },

  loaded: function loaded(fn) {
    window.addEventListener('load', fn);
  },

  /**
   * Simple helper which returns if IE 10/11 is used.
   * @returns {boolean}
   */
  isInternetExplorer: function isInternetExplorer() {
    return window.navigator.userAgent.indexOf('Trident') !== -1;
  },

  /**
   * UI related helpers
   * @TODO: They may depend on jQuery but we'll remove it
   */
  UI: {
    /**
     * Shows a toast
     * @depends jQuery
     * @param text
     * @param duration
     */
    toast: function toast(text) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;

      $('.deliveryareaerror').fadeOut(20).html(text).fadeIn().delay(duration).fadeOut();
    },

    /**
     * Counts up from 0
     * @param end
     * @param duration
     * @param target
     */
    countUp: function countUp(end, duration, target) {
      var range = end - 0;
      var increment = end > 0 ? 1 : -1;
      var stepTime = Math.abs(Math.floor(duration / range));
      var current = 0;
      var timer = setInterval(function () {
        current += increment;
        target.text(current.toString());

        if (current === end) {
          clearInterval(timer);
        }
      }, stepTime);
    }
  }
};
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global restaurant, polygons, currentRestaurant, isDeliveryPossible */
/** ***************************************************************************
 *
 * Old variables for the old jQuery-based AUTOCOMPLETE extension
 *
 * TODO: Delete them after refactoring everything
 *
 *****************************************************************************/

/* global Address, $, jQuery, Cookies, google, ADDRESS, site, Helper, app, GeoLocationResponse */

var service = false;
if ((typeof google === 'undefined' ? 'undefined' : _typeof(google)) === 'object' && _typeof(google.maps) === 'object') {
  service = new google.maps.places.AutocompleteService();
}
var searchString = false;
var dropdown = '.lp__places-container';
var button = 'div:not(.lp-popup__wrapper) .lp__search-button';
var dropdownOutput = '.auto-complete-drop-down-content';
var AutoComplete = {};
var delayTime = 400;
var delayTimer;

/** ***************************************************************************
 *
 * Global jQuery caches
 *
 * TODO: This may be moved into another file as we need them globally
 *
 *****************************************************************************/
var $doc = $(document);

/** ***************************************************************************
 *
 * KeyCodes
 *
 * TODO: This may be moved into another file as they are global variables/constants
 *
 *****************************************************************************/

var keyCode = {
  DOWN: 40,
  ENTER: 13,
  ESCAPE: 27,
  RIGHT: 39,
  SPACE: 32,
  UP: 38

  /** ***************************************************************************
   *
   * Global locationPanel class/object
   *
   *****************************************************************************/
};var locationPanel;
$doc.ready(function () {
  // Cache all locationPanel elements
  locationPanel = {
    selector: '.dropdown-location',
    $: $('.dropdown-location'),

    /**
     * Elements of the panel
     */
    searchInput: {
      selector: '.lp__input',
      $: $('.lp__input')
    },
    searchInputAndButtonContainer: {
      selector: '#deliveryareapanelwrap',
      $: $('#deliveryareapanelwrap')
    },
    // =======================================
    searchResults: {
      selector: '.lp__places-container',
      $: $('.lp__places-container')
    },
    warning: {
      selector: '.lp__warning',
      // When popup is open, eliminate cached results by using a return func
      $: function $() {
        return document.querySelectorAll('.lp__warning');
      }
    },
    // =======================================
    geoaddress: {
      selector: '.lp__place--geoaddress',
      $: function $() {
        return document.querySelectorAll('.lp__place--geoaddress');
      }
    },
    recentaddress: {
      selector: '.lp__place--address',
      $: function $() {
        return document.querySelectorAll('.lp__place--address');
      }
    },

    /**
     * Translations
     *
     * TODO Take these translations from an object/service etc. Not from DOM/jQuery
     */
    i18n: {
      ENTER_STREET_AND_NUMBER: $('.lp__warning').text()
    }

    /** ***************************************************************************
     *
     * New class/object for locationPanel, without being a jQuery extension.
     * These must be pure functions. If you don't know the principles, please do not
     * touch or add functions. You can ask Emre for more info.
     *
     *****************************************************************************/

    /**
     * Hides red info (Please enter your street and house number) on AT/BE/DE etc
     */
  };locationPanel.hideWarning = function () {
    // We need forEach because popup container also has the same node element
    this.warning.$().forEach(function (node) {
      node._hide();
    });
  };

  /**
   * Shows red info (Please enter your street and house number) on AT/BE/DE etc
   */
  locationPanel.showWarning = function (text) {
    // We need forEach because popup container also has the same node element
    window.app.services.tracking.send({
      eventName: 'hasSearchError',
      eventData: {
        searchType: 'location',
        searchErrorType: 'address preferred'
      },
      onlyTrackOnce: true
    });
    this.warning.$().forEach(function (node) {
      node.innerHTML = text;
      node._show();
    });
  };

  /** ***************************************************************************
   *
   * Old jQuery-based AUTOCOMPLETE extension & its functions
   *
   * TODO: This extension may be refactored into locationPanel class/object and deleted eventually
   *
   *****************************************************************************/

  (function ($) {
    $.autoComplete = function (el, options) {
      var defaults = {
        lat: '',
        lng: '',
        country: '',
        language: '',
        pcMatch: '',
        active: true,
        popupmode: false,
        onSomeEvent: function onSomeEvent() {}
      };
      var autocomplete = this;
      var predictions;
      autocomplete.settings = {};

      var init = function init() {
        autocomplete.settings = $.extend({}, defaults, options);
        autocomplete.el = el;
        if ((typeof google === 'undefined' ? 'undefined' : _typeof(google)) === 'object' && _typeof(google.maps) === 'object') {
          autocomplete.settings.sessionToken = new google.maps.places.AutocompleteSessionToken();
          console.log('Session token: ' + autocomplete.settings.sessionToken);
        }
        if (autocomplete.settings.findGeoLocation !== 'false') {
          window.app.services.user.getGeolocation();
        }
      };

      var mapAddressFields = function mapAddressFields(data) {
        var fullAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var addressObject = {};

        if (data && data.address_components && Array.isArray(data.address_components)) {
          data.address_components.forEach(function (item) {
            addressObject[item.types[0]] = item.long_name;
          });
        }

        if (fullAddress !== false) {
          var splittedSearchterm = fullAddress.split(',');

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = splittedSearchterm[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var addressPart = _step.value;

              var matchFor = addressObject.route + ' ' + addressObject.street_number;

              if (addressPart !== matchFor && addressPart.indexOf(matchFor) > -1) {
                addressObject.affix = addressPart.substring(matchFor.length);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        console.log('Set SelectedAddress', addressObject);
        window.localStorage.setItem('SelectedAddress', JSON.stringify(addressObject));
        return addressObject;
      };

      /**
       * @param searchTerm
       * @returns {string}|undefined
       */
      var getPostcodeFromSearchTerm = function getPostcodeFromSearchTerm(searchTerm) {
        if (typeof searchTerm === 'string' && site.fullPostcodePattern) {
          var regex = new RegExp(site.fullPostcodePattern);
          // In NL the regex also needs letters, we don't use them but just add them
          // So we check if adding them is still a valid postcode
          console.log(site.fullPostcodePattern, searchTerm, regex.test(searchTerm));
          if (regex.test(searchTerm)) {
            var result = regex.exec(searchTerm);
            if (result[0]) {
              return result[0];
            }
          }
        }
      };

      autocomplete.findGeolocator = function (_ref) {
        var lat = _ref.lat,
            lng = _ref.lng,
            mySearch = _ref.mySearch,
            searchString = _ref.searchString,
            city = _ref.city,
            postalCode = _ref.postalCode;

        // If we have restaurant id, return back to menu card page when popup selector is open
        var bid = false;
        var redirect = false;
        var chainIdValue = false;
        var self = this;

        if ((typeof restaurant === 'undefined' ? 'undefined' : _typeof(restaurant)) === 'object' && restaurant.hasOwnProperty('id') && autocomplete.isRedirect('.deliveryareapanelpopupmode #ideliveryareaform')) {
          bid = restaurant.id;
          redirect = 'menucard';
        }

        if (typeof window.chainId !== 'undefined' && $('body').hasClass('chains')) {
          chainIdValue = window.chainId;
        }

        var postData = {
          latlng: lat + ',' + lng,
          type: 'geolocation',
          ck: 'true',
          mysearchstring: searchString,
          redirect: redirect,
          bid: bid,
          clickSource: window.app.components.locationPanel.UI.getClickSource(),
          chainId: chainIdValue
        };

        if (typeof mySearch !== 'undefined' && mySearch !== false) {
          postData.mysearch = mySearch;
        }

        var searchValue = window.app.components.locationPanel ? window.app.components.locationPanel.UI.val() : null;

        function rebuildSearchStringMapper() {
          var searchstringmapper = Cookies.get('searchstringmapper');
          if (typeof searchstringmapper !== 'undefined' && searchstringmapper.length > 0) {
            try {
              searchstringmapper = JSON.parse(searchstringmapper);
            } catch (exception) {
              console.log('Error in the parsing the searchstringmapper in LocationPanel - findGeolocator, content: ' + Cookies.get('searchstringmapper'));
            }
          }
          var components = null;
          if (searchstringmapper !== null && (typeof searchstringmapper === 'undefined' ? 'undefined' : _typeof(searchstringmapper)) === 'object' && searchstringmapper.hasOwnProperty('components')) {
            components = searchstringmapper.components;
          }

          // store location with lat/lng information
          searchstringmapper = {
            location: searchValue,
            latitude: lat,
            longitude: lng
          };
          self.updateSearchStringMapper(searchstringmapper);
          self.updateComponentInSearchStringMapper(components);
          Cookies.set('searchstringmapper', JSON.stringify(searchstringmapper), {
            expires: 60,
            path: site.path,
            secure: true
          });
        }

        function fireOldFindGeolocation(postData) {
          $.post(site.local + 'findGeoLocation.php', postData, function (data) {
            var obj = $.parseJSON(data);

            searchValue = searchValue || obj['search'];

            if (obj.type === 'POSTCODE') {
              Cookies.set('searchstring', searchValue, {
                expires: 365,
                path: site.path,
                secure: true
              });
              rebuildSearchStringMapper();

              Cookies.remove('sortby');

              // Switch back to delivery when a delivery area is selected
              Cookies.remove('pickup');

              window.top.location = obj.value;
            }
            if (obj.type === 'html' || obj.type === 'HTML' || obj.type === 'SPLIT_PC') {
              $(dropdownOutput).html(obj['value']);
              $(dropdown).show();
            }
            if (obj.type === 'error') {
              console.log('findGeolocator(): error');
              Helper.UI.toast(obj.value);
            }
          });
        }

        var isGeoLocationServiceActive = app.services.feature.isActive(app.enums.FEATURES.GEO_LOCATION_SERVICE);
        if (typeof city !== 'undefined' && isGeoLocationServiceActive) {
          console.log('firing new geolocation service');
          app.services.geoLocationService.getGeoLocation({ lat: lat, long: lng, city: city, postalCode: postalCode }).then(function (GeoLocationResponse) {
            // A bit of *guessing*, tried to make the logic the same as for findGeoLocation.php
            Cookies.set('searchstring', searchValue, {
              expires: 365,
              path: site.path,
              secure: true
            });
            Cookies.set('latitude', lat, {
              expires: 365,
              path: site.path,
              secure: true
            });
            Cookies.set('longitude', lng, {
              expires: 365,
              path: site.path,
              secure: true
            });
            if (GeoLocationResponse.postalCode) {
              Cookies.set('postcode', GeoLocationResponse.postalCode, {
                expires: 365,
                path: site.path,
                secure: true
              });
            }
            rebuildSearchStringMapper();

            window.top.location = GeoLocationResponse.slug;
          }).catch(function (e) {
            console.log('firing old geolocation, found error: ' + e);
            fireOldFindGeolocation(postData);
          });
        } else {
          console.log('firing old geolocation', 'city: ' + city + ', active: ' + isGeoLocationServiceActive);
          fireOldFindGeolocation(postData);
        }
      };

      autocomplete.inputSearchField = function (input) {
        var activeEl = $(document.activeElement)[0].id;
        searchString = input.toUpperCase();

        if (searchString.length === 0 && activeEl === 'imysearchstring') {
          // Show red info (Please enter your street and house number) on AT/DE etc
          if (autocomplete.settings.specifyCustomerLocation === true) {
            locationPanel.showWarning(locationPanel.i18n.ENTER_STREET_AND_NUMBER);
          }

          AutoComplete.parseJsonData('', '', 'OK');
          return false;
        } else if (searchString.length >= 1) {
          if (autocomplete.settings.pcMatch && autocomplete.settings.specifyLocation === false && $.trim(searchString).match(autocomplete.settings.pcMatch) && window.app.services.feature.isActive(window.app.enums.FEATURES.SHOW_POSTCODE_USING_GEOCODING_IN_LOCATION_PANEL_SUGGESTIONS) === false) {
            window.clearTimeout(delayTimer);
            console.log('createPostcodeOutput');
            autocomplete.createPostcodeOutput(searchString);
            return false;
          }

          /**
           * ********* Famous delay timer part, using setTimeout() *********
           */
          if (delayTimer !== null) {
            window.clearTimeout(delayTimer);
          }

          delayTimer = window.setTimeout(AutoComplete.collectPrediction.bind(null, searchString), delayTime);
          return false;
        }
      };

      autocomplete.createPostcodeOutput = function (postcode) {
        var predictions = {};
        if (autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND || parseInt(postcode, 10) !== 0) {
          var myPrediction = [{
            description: ', ' + postcode.toUpperCase() + ',',
            id: false,
            matched_substrings: false,
            reference: 'postcode',
            terms: false,
            types: false,
            length: 1
          }];
          predictions = myPrediction;

          autocomplete.setCollectedPrediction(predictions);
          autocomplete.setDropdown(predictions, postcode);
        }
      };

      autocomplete.collectPrediction = function (query) {
        // predictions should only be fetched if query isn't a valid postcode
        // therefore check below using pregmatch if we got a zipcode or not
        console.log({ collectPredictions: query });
        var validZip = false;
        if ($.trim(query).match(autocomplete.settings.pcMatch) !== null) {
          validZip = true;
        }

        if (query === '') {
          autocomplete.parseJsonData(false, query, status);
          return false;
        }

        if ($.trim(query.match(autocomplete.settings.PcMatch))) {
          query = query.replace(/ /g, '');
        }
        var request = {};
        if (AutoComplete.settings.countrycode === window.app.enums.COUNTRY_CODES.NETHERLANDS) {
          request = {
            input: query,
            componentRestrictions: { country: autocomplete.settings.country },
            bounds: new google.maps.LatLngBounds(new google.maps.LatLng(), new google.maps.LatLng()),
            sessionToken: autocomplete.settings.sessionToken
          };
        } else {
          request = {
            input: query,
            bounds: new google.maps.LatLngBounds(new google.maps.LatLng(), new google.maps.LatLng()),
            componentRestrictions: { country: autocomplete.settings.country }
          };
        }

        if (autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND) {
          // Fix 'generic results' problem for Poland, ask only for addresses
          request.types = ['geocode'];
        }

        /*
        * only query Google API if we don't have a valid postalcode
        */
        if ((typeof service === 'undefined' ? 'undefined' : _typeof(service)) === 'object' && (validZip === false ||
        // We do want use the geocoder for countries which only use geocoding
        // combined with postal codes, because we need to send the
        // LAT/LNG to the backend
        window.app.services.feature.isActive(window.app.enums.FEATURES.SHOW_POSTCODE_USING_GEOCODING_IN_LOCATION_PANEL_SUGGESTIONS) === true)) {
          console.log('Google API is called', { request: request });
          service.getPlacePredictions(request, function (predictions, status) {
            // remove zipcodes from predictions is specifyCustomerLocation is true
            if (autocomplete.settings.specifyCustomerLocation && predictions != null) {
              var i = predictions.length;
              while (i--) {
                if (predictions[i].types[0] === 'postal_code') {
                  predictions.splice(i, 1);
                }
              }
            }
            autocomplete.parseJsonData(predictions, query, status);
          });
        } else {
          autocomplete.parseJsonData(predictions, query, status);
        }
      };

      autocomplete.parseJsonData = function (predictions, query, status) {
        var validPc = false;
        var collectedpredictions = [];

        if (autocomplete.settings.pcMatch && autocomplete.settings.specifyCustomerLocation === false) {
          if ($.trim(query).match(autocomplete.settings.pcMatch)) {
            // pregmatch valid postalcode
            validPc = query;
          }
        }

        if (autocomplete.settings.pcMatch && autocomplete.settings.specifyCustomerLocation === true) {
          if ($.trim(query).match(autocomplete.settings.pcMatch)) {
            // pregmatch valid postalcode
            validPc = query;
            autocomplete.setCollectedPrediction(collectedpredictions);
            autocomplete.setDropdown(collectedpredictions, validPc);
            return;
          }
        }

        if (status === 'OK') {
          if ((typeof predictions === 'undefined' ? 'undefined' : _typeof(predictions)) === 'object' && predictions != null) {
            collectedpredictions = predictions.concat(collectedpredictions);
          }
        }

        // we have a valid pc, add also to dropdown
        if (validPc && window.app.services.feature.isActive(window.app.enums.FEATURES.SHOW_POSTCODE_USING_GEOCODING_IN_LOCATION_PANEL_SUGGESTIONS) === false) {
          // don't accept all zero's
          if (autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND || parseInt(validPc, 10) !== 0) {
            var myPrediction = [{
              description: ', ' + validPc.toUpperCase() + ',',
              id: false,
              matched_substrings: false,
              reference: 'postcode',
              terms: false,
              types: false,
              length: 1
            }];
            if ((typeof myPrediction === 'undefined' ? 'undefined' : _typeof(myPrediction)) === 'object') {
              collectedpredictions = myPrediction.concat(collectedpredictions);
            }
          }
        }

        autocomplete.setCollectedPrediction(collectedpredictions);
        autocomplete.setDropdown(collectedpredictions, validPc);
      };

      autocomplete.setCollectedPrediction = function (obj) {
        autocomplete.settings.collectedpredictions = obj;
      };

      autocomplete.clickReference = function (cli) {
        console.log('clicked clickReference()');
        var $cli = $(cli);
        var suggestion = !(typeof $cli.attr('data-suggestion') === 'undefined' || !$cli.attr('data-suggestion'));
        var postcode = !(typeof $cli.attr('data-reference') === 'undefined' || !$cli.attr('data-reference'));

        if (postcode && suggestion) {
          autocomplete.clickReferenceSuggestion(cli);
        } else {
          autocomplete.clickReferenceGoogle(cli);
        }
      };

      autocomplete.clickDirectLink = function (cli) {
        console.log('clicked clickDirectLink()');
        if (typeof $(cli).attr('data-id') !== 'undefined') {
          AutoComplete.postLocation($(cli).attr('data-id'), false, false, 'undefined', 'customerdeliveryarea', false, $(cli).text());
        } else if (typeof $(cli).attr('data-href') !== 'undefined') {
          // Switch back to delivery when a delivery area is selected
          Cookies.remove('pickup');
          document.location = $(cli).attr('data-href');
        } else {
          AutoComplete.postLocation($(cli).text());
        }
      };

      autocomplete.clickReferenceSuggestion = function (cli) {
        console.log('clicked clickReferenceSuggestion()');
        var input = $(cli).attr('data-name');
        var suggestion = typeof $(cli).attr('data-suggestion') === 'undefined' || !$(cli).attr('data-suggestion') ? false : $(cli).attr('data-suggestion');
        var reference = typeof $(cli).attr('data-reference') === 'undefined' || !$(cli).attr('data-reference') ? false : $(cli).attr('data-reference');

        locationPanel.searchInput.$.val(suggestion);

        if (reference === 'postcode') {
          AutoComplete.postLocation(input, false, false, false, false, false, suggestion, suggestion);
        } else if (reference === 'latlng') {
          if (AutoComplete.settings.specific === true) {
            console.log('clickReferenceSuggestion() autocomplete.settings.specifyLocation');
            Helper.UI.toast(autocomplete.settings.specifyLocation);
          } else {
            var geo = input.split(',');
            AutoComplete.postLocation(false, geo[0], geo[1], false, false, false, suggestion, suggestion);
          }
        }
      };

      autocomplete.clickReferenceGoogle = function (cli) {
        console.log('clickReferenceGoogle() running, cli', cli);
        var clickReference = $(cli).attr('data-reference');
        var input = $(cli).attr('data-name');

        if (clickReference === 'directlink') {
          if (autocomplete.settings.countrycode === 4) {
            AutoComplete.clickDirectLink(cli);
          } else {
            if (typeof $(cli).attr('data-href') !== 'undefined') {
              // Switch back to delivery when a delivery area is selected
              Cookies.remove('pickup');
              document.location = $(cli).attr('data-href');
            }
          }
          return false;
        }

        if (clickReference === 'postcode' || clickReference === 'customerdeliveryarea') {
          var extra = false;
          if (clickReference === 'customerdeliveryarea') {
            AutoComplete.clickDirectLink(cli);
            return false;
          }

          locationPanel.searchInput.$.val(input);
          AutoComplete.postLocation(input, '', '', '', extra);
          $('#output').hide();
          return false;
        }

        autocomplete.geoCodeService($(cli).attr('data-name'), cli, true);
        return false;
      };

      autocomplete.updateComponentInSearchStringMapper = function (components) {
        var self = this;
        console.log('Full component list:' + JSON.stringify(components));
        var searchstringmapper = Cookies.get('searchstringmapper');
        if (typeof searchstringmapper !== 'undefined' && searchstringmapper.length > 0) {
          try {
            searchstringmapper = JSON.parse(searchstringmapper);
            if (searchstringmapper !== null && (typeof searchstringmapper === 'undefined' ? 'undefined' : _typeof(searchstringmapper)) === 'object' && searchstringmapper.hasOwnProperty('components')) {
              delete searchstringmapper.components;
            }
            if (typeof components !== 'undefined') {
              searchstringmapper.components = {};
              var items = ['street_number', 'route', 'locality'];
              for (var i in items) {
                var item = items[i];
                if (components.hasOwnProperty(item)) {
                  searchstringmapper.components[item] = components[item];
                }
              }
              console.log('updating components ' + JSON.stringify(searchstringmapper.components));
            } else {
              console.log('No components found');
            }
            self.updateSearchStringMapper(searchstringmapper);
          } catch (e) {
            console.log('Cannot parse the searchstring mapper');
            console.log(searchstringmapper);
            return null;
          }
        }
      };

      autocomplete.updateSearchStringMapper = function (object) {
        console.log('updating searchstring mapper with ' + JSON.stringify(object));
        Cookies.set('searchstringmapper', JSON.stringify(object), { expires: 60, path: site.path, secure: true });
      };

      autocomplete.geoCodeService = function (address, cli, PlacesService) {
        console.log('geoCodeService(), address', address);
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({
          address: address,
          // This is used for biasing to improve accuracy of reverse geo-coding, not a country-based restriction
          // Country-based restriction is done on Autocomplete phase
          region: Array.isArray(autocomplete.settings.country) ? autocomplete.settings.country.join('|') : autocomplete.settings.country
        }, function (place, status) {
          var places = [];
          $.each(place, function (key, item) {
            var components = mapAddressFields(item, address);
            // :TODO FED-11003 For BG & RO need to implement correct condition.
            if (components.locality || [window.app.enums.COUNTRY_CODES.AUSTRIA, window.app.enums.COUNTRY_CODES.BULGARIA, window.app.enums.COUNTRY_CODES.DENMARK, window.app.enums.COUNTRY_CODES.FRANCE, window.app.enums.COUNTRY_CODES.NORWAY, window.app.enums.COUNTRY_CODES.PORTUGAL, window.app.enums.COUNTRY_CODES.ROMANIA].includes(autocomplete.settings.countrycode)) {
              places.push(item);
            }
          });

          if (status === google.maps.GeocoderStatus.OK) {
            if (places.length > 1) {
              autocomplete.showSuggestions(places, address);
              return false;
            } else {
              if (places[0]) {
                var _place = places[0];
                var components = mapAddressFields(_place, address);

                if (AutoComplete.settings.specific === true && typeof components.postal_code === 'undefined') {
                  console.log('geoCodeService() error: specifyLocation = true && components.postal_code = undefined');
                  locationPanel.showWarning(locationPanel.i18n.ENTER_STREET_AND_NUMBER);
                  return false;
                } else {
                  locationPanel.searchInput.$.val(address);
                  AutoComplete.postLocation(components.postal_code, _place.geometry.location.lat(), _place.geometry.location.lng(), components.sublocality, false, components, address);
                }

                $('#output').hide();
              }
            }
          } else {
            console.log('geoCodeService() error: No location found');
            Helper.UI.toast(autocomplete.settings.invalidLocation, 5000);
          }
        });
      };

      autocomplete.reverseGeocoderLookup = function (lat, lng, address, cli) {
        console.log('reverseGeocoderLookup() running, lat', lat, 'lng', lng, 'address', address);
        var geocoder = new google.maps.Geocoder();
        var latlng = { lat: parseFloat(lat), lng: parseFloat(lng) };

        geocoder.geocode({ 'location': latlng }, function (places, status) {
          if (status === google.maps.GeocoderStatus.OK) {
            if (places[0]) {
              var place = places[0];
              var components = mapAddressFields(place, address);

              if (typeof components.postal_code === 'undefined') {
                components.postal_code = false; // fallback to findGeolocations
              }

              AutoComplete.postLocation(components.postal_code, place.geometry.location.lat(), place.geometry.location.lng(), components.sublocality, false, components, address);
              $('#output').hide();
            }
          } else {
            console.log('reverseGeocoderLookup() error: No location found');
            Helper.UI.toast(autocomplete.settings.invalidLocation, 5000);
          }
        });
      };

      autocomplete.showSuggestions = function (places, input) {
        $(dropdownOutput).html('');
        var dropitems = '';

        places.sort(function (a, b) {
          return a.formatted_address < b.formatted_address ? 1 : a.formatted_address > b.formatted_address ? -1 : 0;
        });
        window.localStorage.setItem('suggestedAddresses', '{}');
        var suggestedAddresses = {};
        $.each(places, function (key, place) {
          var components = mapAddressFields(place, input);
          suggestedAddresses[key] = components;
          // first remove countryname from formatted address
          var formattedAddress = place['formatted_address'].replace(', ' + autocomplete.settings.myCountry[autocomplete.settings.language], '');

          if (window.app.components.locationPanel.UI.hasLink(formattedAddress)) {
            console.log('showSuggestions(): Link already added, skipping. Title:', formattedAddress);
            return;
          }

          if (components.postal_code &&
          // FED-7231 In BG "Did you mean" results can't be 'postcode' links as we only use location-ids
          site.iso !== 'BG') {
            dropitems += '<a\n            href="#"\n            onclick="return false;"\n            class="lp__place notranslate"\n            id="reference"\n            data-suggest-id="' + key + '"\n            data-name="' + components.postal_code + '"\n            data-reference="postcode"\n            data-suggestion="' + formattedAddress + '">\n              ' + formattedAddress + '\n            </a>';
          } else {
            dropitems += '<a\n            href="#"\n            onclick="return false;"\n            class="lp__place notranslate"\n            id="reference"\n            data-suggest-id="' + key + '"\n            data-name="' + places[key].geometry.location.lat() + ',' + places[key].geometry.location.lng() + '"\n            data-reference="latlng"\n            data-route="' + Helper.escapeHtml(components.route) + '"\n            data-suggestion="' + Helper.escapeHtml(formattedAddress) + '">\n              ' + formattedAddress + '\n            </a>';
          }
        });

        window.localStorage.setItem('suggestedAddresses', JSON.stringify(suggestedAddresses));
        window.app.components.locationPanel.setRawLinks(dropitems);
        window.app.components.locationPanel.UI.renderLinks();
        // Ultra ugly fix: Append "Did you mean?" text
        var $didYouMeanText = $(dropdown + ' .suggestions').clone().css('display', 'block');
        var $suggestionsHeader = $(dropdown + ' .skip').first();
        $suggestionsHeader.after($didYouMeanText);
      };

      autocomplete.postCityDistrict = function (city, district, userlocationid, redirect, bid) {
        var postvars = {};

        if (userlocationid !== false) {
          postvars = { city: city, district: district, userlocationid: userlocationid };
        } else if (city && district) {
          postvars = { city: city, district: district, userlocationid: userlocationid };
        }

        var chainIdValue = false;

        if (typeof window.chainId !== 'undefined' && city && district) {
          if ($('body').hasClass('chains')) {
            chainIdValue = window.chainId;
          }
        }

        $.post(site.local + 'findRestaurants.php', {
          type: 'citydistrict',
          customerdeliveryarea: postvars.userlocationid,
          searchstring1: postvars.city,
          searchstring2: postvars.district,
          google_latitude: false,
          google_longitude: false,
          redirect: redirect,
          bid: bid,
          clickSource: window.app.components.locationPanel.UI.getClickSource(),
          chainId: chainIdValue
        }, function (data) {
          var obj = $.parseJSON(data);
          console.log('FIND RESTAURANT', data);
          if (obj.type === 'url') {
            if ($('.addresspulldown').length > 0 && !$('.addresspulldown').hasClass('hidden')) {
              Cookies.set('searchstring', $('#icustomerdeliveryarea option:selected').text(), {
                expires: 365,
                path: site.path,
                secure: true
              });
            } else {
              Cookies.set('searchstring', $('#isearchstring2 option:selected').text() + ', ' + $('#isearchstring1 option:selected').text(), {
                expires: 365,
                path: site.path,
                secure: true
              });
            }
            Cookies.remove('sortby');

            // Switch back to delivery when a delivery area is selected
            Cookies.remove('pickup');
            window.top.location = obj.value;
          }

          if (obj.type === 'html') {
            $(dropdownOutput).html(obj['value']);
            $(dropdown).show();
          }

          if (obj.type === 'error') {
            console.log('postCityDistrict() findRestaurants.php error');
            Helper.UI.toast(obj.value);
          }
        });
      };

      autocomplete.isRedirect = function (el) {
        var values = [];
        $.each($(el).serializeArray(), function (i, field) {
          values[field.name] = field.value;
        });
        if (values.bid && values.redirect === 'menucard') {
          autocomplete.settings.redirect = { 'redirect': 'menucard', 'bid': values.bid };
          return true;
        }
        return false;
      };

      autocomplete.postLocation = function (postcode, lat, lng, subLocality, extra, components, searchTerm, mySearchString) {
        $('.autoCompleteNotice').hide();
        var self = this;

        if (components) {
          self.updateComponentInSearchStringMapper(components);
        }

        var redirect = false;
        var bid = false;
        var categoryId = null;
        var subCategoryId = null;

        if (typeof postcode !== 'undefined' && postcode !== false) {
          postcode = postcode.replace(/\s/g, '').toUpperCase();
        }

        if (autocomplete.settings.popupmode === true) {
          // is user located at step3? then try to redirect it back to menucard instead of step2
          if (autocomplete.isRedirect('.deliveryareapanelpopupmode #ideliveryareaform')) {
            bid = autocomplete.settings.redirect.bid;
            redirect = autocomplete.settings.redirect.redirect;
          }
        } else {
          // is user located at step3? then try to redirect it back to menucard instead of step2
          if (autocomplete.isRedirect('#ideliveryareaform')) {
            bid = autocomplete.settings.redirect.bid;
            redirect = autocomplete.settings.redirect.redirect;
          }
        }

        // If we have restaurant id, return back to menu card page when popup selector is open
        if ((typeof restaurant === 'undefined' ? 'undefined' : _typeof(restaurant)) === 'object' && restaurant.hasOwnProperty('id') && autocomplete.isRedirect('.deliveryareapanelpopupmode #ideliveryareaform')) {
          bid = restaurant.id;
          redirect = 'menucard';
        }

        // submit correct searchterm to findRestaurant or findGeoLocation
        if (components) {
          if ('route' in components) {
            mySearchString = components.route + ', ' + components.locality;
          } else if ('sublocality_level_2' in components || 'sublocality' in components || 'sublocality_level_1' in components) {
            var searchterms = searchTerm.split(', ');
            searchterms.pop(); // pop city from searchterm
            var mylocality = searchterms[searchterms.length - 1]; // fetch last array item

            if (mylocality === components.sublocality_level_2) {
              mySearchString = components.sublocality_level_2 + ', ' + components.locality;
            } else if (mylocality === components.sublocality) {
              mySearchString = components.sublocality + ', ' + components.locality;
            } else if (mylocality === components.sublocality_level_1) {
              mySearchString = components.sublocality_level_1 + ', ' + components.locality;
            }
          }
        }

        var geolocation = false;
        if (extra) {
          if (extra.description !== '') {
            geolocation = true;
          }
        }

        if (postcode && lat && lng && autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND) {
          // just disable postcode always for Pyszne
          // and fallback to findGeoLocation.php to fetch postcode from our geopc_eu table
          postcode = false;
        }

        // determine if restaurant has polygon data or not
        AutoComplete.isPolygonRestaurant();

        // Chain Selector for chainpages
        // Forward customer directly to menucard page if we have a valid match
        var chainId = false;
        if (typeof chainId !== 'undefined' && (postcode || $.isNumeric(lat) && $.isNumeric(lng)) && $('body').hasClass('chains')) {
          chainId = window.chainId;
        }

        var selectedCategoryIdInput = document.querySelector('input[name="selectedCategoryId"]');
        if (selectedCategoryIdInput && selectedCategoryIdInput.value) {
          categoryId = selectedCategoryIdInput.value;
        }

        var selectedSubCategoryIdInput = document.querySelector('input[name="selectedSubCategoryId"]');
        if (selectedSubCategoryIdInput && selectedSubCategoryIdInput.value) {
          subCategoryId = selectedSubCategoryIdInput.value;
        }

        // settings.geocoder -> always post lat lng to backend, never try to post zipcode
        // This is introduced because of Romania
        if (postcode && extra === 'customerdeliveryarea' && autocomplete.settings.geocoder === false) {
          var postData = {
            searchstring: postcode,
            type: 'postcode',
            mysearch: false,
            customerdeliveryarea: postcode,
            google_latitude: false,
            google_longitude: false,
            redirect: redirect,
            bid: bid,
            clickSource: window.app.components.locationPanel.UI.getClickSource(),
            chainId: chainId,
            categoryId: categoryId,
            subCategoryId: subCategoryId,
            mysearchstring: false
          };

          if (AutoComplete.settings.isPolygonRestaurant) {
            postData.isPolygonRestaurant = true;
          }

          $.post(site.local + 'findRestaurants.php', postData, function (data) {
            var obj = $.parseJSON(data);
            console.log('FindRestaurants:', data);
            if (obj.type === 'url') {
              var newSearchStringValue = postcode;
              if (typeof searchTerm !== 'undefined' && searchTerm !== false) {
                newSearchStringValue = searchTerm;
              }
              Cookies.set('searchstring', newSearchStringValue, {
                expires: 365,
                path: site.path,
                secure: true
              });
              Cookies.remove('sortby');

              // Switch back to delivery when a delivery area is selected
              Cookies.remove('pickup');

              window.top.location = obj.value;
            }

            if (obj.type === 'html') {
              $(dropdownOutput).html(obj['value']);
              $(dropdown).show();
            }

            if (obj.type === 'error') {
              console.log('postLocation() findRestaurants.php error: extra = "customerdeliveryarea"');
              Helper.UI.toast(obj.value);
            }
          });
        } else if (postcode && autocomplete.settings.geocoder === false) {
          var deliveryareaid = '';
          var customlat = false;
          var customlng = false;

          if (extra && extra.description === 'customerdeliveryarea') {
            deliveryareaid = extra.id;
          }

          if (autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.NETHERLANDS && typeof subLocality !== 'undefined' && subLocality) {
            subLocality = subLocality.replace(/ /g, '');
          }

          if (lat && lng) {
            customlat = lat;
            customlng = lng;
            geolocation = true;
          } else if ($('#data-lattitude').html() !== '' && $('#data-longitude').html() !== '') {
            customlat = $('#data-lattitude').html();
            customlng = $('#data-longitude').html();
            geolocation = true;
          }

          var _postData = {
            searchstring: postcode,
            type: 'postcode',
            mysearch: subLocality,
            customerdeliveryarea: deliveryareaid,
            google_latitude: customlat,
            google_longitude: customlng,
            redirect: redirect,
            bid: bid,
            clickSource: window.app.components.locationPanel.UI.getClickSource(),
            chainId: chainId,
            categoryId: categoryId,
            subCategoryId: subCategoryId,
            mysearchstring: mySearchString,
            geo: geolocation
          };

          if (components) {
            if (components.hasOwnProperty('route')) {
              _postData.streetName = components.route;
            }

            if (components.hasOwnProperty('street_number')) {
              _postData.streetNumber = components.street_number;
            }
          }

          if (AutoComplete.settings.isPolygonRestaurant) {
            _postData.isPolygonRestaurant = true;
          }

          $.post(site.local + 'findRestaurants.php', _postData, function (data) {
            var obj = $.parseJSON(data);
            if (obj.type === 'url') {
              var newSearchStringValue = postcode;
              if (typeof searchTerm !== 'undefined' && searchTerm !== false) {
                newSearchStringValue = searchTerm;
              }
              Cookies.set('searchstring', newSearchStringValue, { expires: 365, path: site.path, secure: true });
              // store location with lat/lng information
              if (geolocation === true) {
                var searchstringmapper = {
                  location: $('#ideliveryareaform #imysearchstring').val(),
                  latitude: customlat,
                  longitude: customlng,
                  city: AutoComplete.settings.city,
                  placeId: AutoComplete.settings.placeId
                  // TODO - add city
                };Cookies.set('searchstringmapper', JSON.stringify(searchstringmapper), {
                  expires: 365,
                  path: site.path,
                  secure: true
                });
              }
              // Update the polygons for the userlocation.
              window.app.services.user.setLocation();

              /*
               * GA linker param addition to URL before redirection
               * from takeaway.com/ch to eat.ch
               *
               * @TODO: Remove this part after full migration
               *   of takeaway.com/ch into eat.ch
               */
              if (AutoComplete.settings.countrycode === window.app.enums.SWITZERLAND && window.location.hostname.endsWith('takeaway.com') && window.ga) {
                try {
                  var trackers = window.ga.getAll();
                  if (trackers.length) {
                    var gaLinkerParam = trackers[0].get('linkerParam');
                    if (gaLinkerParam) {
                      var tempUrl = new URL(obj.value, document.location);
                      gaLinkerParam.split('&').map(function (item) {
                        return item.split('=');
                      }).forEach(function (_ref2) {
                        var _ref3 = _slicedToArray(_ref2, 2),
                            key = _ref3[0],
                            value = _ref3[1];

                        tempUrl.searchParams.set(key, value);
                      });
                      obj.value = tempUrl.pathname + tempUrl.search;
                    }
                  }
                } catch (e) {
                  console.log('Google Analytics object error: ', e);
                }
              }

              if (typeof currentRestaurant !== 'undefined' && window.app.components.locationPanel.UI.getClickSource() === 'meal' && isDeliveryPossible()) {
                // Because cookies are set
                // and we need to handle different situations
                // like show price based on location,
                // update the basket there is no safer way
                // then reloading the current page
                window.location.reload();
              } else {
                Cookies.remove('sortby');
                // Switch back to delivery when a delivery area is selected
                Cookies.remove('pickup');
                window.top.location = obj.value;
              }
            } else if (obj.type === 'html') {
              $(dropdown + ' .auto-complete-drop-down-content').html(obj.value);
              $(dropdown).show();
              $('.popupoptions a').first().focus();
            }

            if (obj.type === 'error') {
              console.log('postLocation() findRestaurants.php error: Postcode not exist/valid');
              window.app.services.tracking.send({
                eventName: 'hasSearchError',
                eventData: {
                  searchType: 'location',
                  searchErrorType: 'activeAddressInvalidAddressError'
                }
              });
              Helper.UI.toast(obj.value);
            }
          });
        } else if ($.isNumeric(lat) && $.isNumeric(lng)) {
          // convert lat,lng to numbers if those are still in someway declared as string
          lat = parseFloat(lat);
          lng = parseFloat(lng);
          // BG: For some lat/lng values, our geolocation DB is outdated,
          //     so we'll use Google geocode reverse
          if (AutoComplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND) {
            var geocoder = new google.maps.Geocoder();
            var latlng = { lat: lat, lng: lng };
            var _searchString = $('#ideliveryareaform #imysearchstring').val();

            var geoCodeSearch = { 'location': latlng };
            var postcodeFromSearchTerm = getPostcodeFromSearchTerm(searchTerm);
            if (postcodeFromSearchTerm) {
              geoCodeSearch.address = searchTerm;
            }

            // FED-17230 Added address: searchTerm for more accurate results
            console.log('using geocodeSearch: ' + JSON.stringify(geoCodeSearch));
            geocoder.geocode(geoCodeSearch, function (results, status) {
              results.forEach(function (item) {
                console.log(item);
                console.log(JSON.stringify(item));
              });
              if (status === 'OK' && results[0]) {
                var _components = mapAddressFields(results[0], _searchString);
                console.log('maf result', JSON.stringify(_components));
                var city = _components.hasOwnProperty('locality') ? _components.locality : null;
                var _postcode = false;
                if (!(AutoComplete.settings.countrycode === window.app.enums.COUNTRY_CODES.BULGARIA || AutoComplete.settings.countrycode === window.app.enums.COUNTRY_CODES.POLAND)) {
                  _postcode = _components.postal_code;
                }

                if (_postcode) {
                  console.log('BG: run postLocation()', _postcode, lat, lng, _searchString);
                  console.log('subLocality', subLocality);
                  console.log('mysearchstring', _searchString);
                  AutoComplete.postLocation(_postcode, lat, lng, false, false, false, _searchString);
                } else {
                  var mySearch = subLocality;
                  console.log('BG: run findGeolocator()', lat, lng, mySearch, _searchString, city, _postcode);
                  autocomplete.findGeolocator({ lat: lat, lng: lng, mySearch: mySearch, searchString: _searchString, city: city, postalCode: _components.postal_code });
                }
              } else {
                var _mySearch = subLocality;
                console.log('BG: No results found or Geocoder failed, using findGeolocator()', lat, lng, _mySearch, _searchString);
                autocomplete.findGeolocator({ lat: lat, lng: lng, mySearch: _mySearch, searchString: _searchString });
              }
            });
          } else {
            // All other countries
            var mySearch = subLocality;
            var _searchString2 = mySearchString;
            console.log('ALL except BG: run findGeolocator()', lat, lng, mySearch, _searchString2);
            autocomplete.findGeolocator({ lat: lat, lng: lng, mySearch: mySearch, searchString: _searchString2 });
          }
        } else {
          $.post(site.local + 'findRestaurants.php', {
            searchstring: postcode,
            type: 'postcode',
            mysearchstring: mySearchString
          }, function (data) {
            var obj = $.parseJSON(data);

            if (obj.type === 'error') {
              console.log('postLocation() findRestaurants.php error: We\'re inside the last else case');
              window.app.services.tracking.send({
                eventName: 'hasSearchError',
                eventData: {
                  searchType: 'location',
                  searchErrorType: 'activeAddressInvalidAddressError'
                }
              });
              Helper.UI.toast(obj.value);
            }
          });
        }
      };

      autocomplete.resetDropdown = function () {
        $(dropdownOutput).html('');
        $(dropdown).fadeIn(100);
      };

      autocomplete.isPolygonRestaurant = function () {
        // Static Basket does not use polygons variable, but currentRestaurant.Polygons
        if (typeof polygons === 'undefined') {
          polygons = typeof currentRestaurant !== 'undefined' && currentRestaurant.Polygons.length > 0;
        }

        if ($('body').hasClass('step3') && polygons !== false) {
          // do we have a restaurant which has polygons?
          autocomplete.settings.isPolygonRestaurant = true;
        }
      };

      autocomplete.setDropdown = function (predictions) {
        if (predictions !== null) {
          localStorage.removeItem('searchPredictions[0]');

          if (predictions.length === 0 && autocomplete.settings.specifyCustomerLocation === true && locationPanel.searchInput.$.val() !== '') {
            locationPanel.showWarning(locationPanel.i18n.ENTER_STREET_AND_NUMBER);
            autocomplete.resetDropdown();
            return false;
          }
        }

        // Don't replace the predictions if the user typed a mistake.
        // We just show the previous result.
        if (predictions.length > 0) {
          console.warn(predictions);
          var searchPredictionsHTML = Object.values(predictions || {}).filter(function (_ref4) {
            var firstType = _ref4.types[0],
                reference = _ref4.reference;
            return (
              // We don't want to return any cities. So we filter them out
              !['locality', 'country'].includes(firstType)
            );
          }).map(function (_ref5, index) {
            var terms = _ref5.terms,
                placeId = _ref5.place_id,
                reference = _ref5.reference,
                firstType = _ref5.types[0],
                description = _ref5.description;

            var rawPrediction = '';
            var addressPart = '';
            if (Array.isArray(terms)) {
              // In most cases we remove the country from the description
              var removeCountry = true;
              var descriptionParts = description.split(',');

              var _terms = _slicedToArray(terms, 2),
                  term1 = _terms[0].value,
                  term2 = _terms[1].value;

              // Some location has the same name as the city.
              // For example Almelo, Almelo
              // In that case we want to show only one of them.


              if (term1 === term2) {
                descriptionParts.shift();
              }

              if (autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.LUXEMBOURG && ['route', 'postal_code', 'sublocality_level_1'].includes(firstType) && terms.length >= 2 ||
              // IN France in some cases we leave the country because the country
              // can also be Monaco in all other cases we remove it
              autocomplete.settings.countrycode === window.app.enums.COUNTRY_CODES.FRANCE && descriptionParts.length === 2) {
                removeCountry = false;
              }

              if (removeCountry === true) {
                descriptionParts.pop();
              }
              // When the item is a trainstation or other place type
              // it might say Almelo, Almelo in that case we just show it once

              rawPrediction = descriptionParts.join(',');
              addressPart = descriptionParts[0];
            }
            // When a postcode is found we don't have a complete address
            // And don't get back any terms. We then strip the description of the comma's
            if (reference === 'postcode') {
              rawPrediction = description.replace(/,/g, '').trim();
            }
            // First prediction save it to localstorage
            // This is saved for when the user clicks outside of location panel en the
            // user still wants to hit the search button
            if (index === 0) {
              localStorage.setItem('searchPredictions[0]', rawPrediction);
            }

            // Addresses like 'Aleja "Solidarności", Warszawa' breaks the html, escape double quotes
            var predictionsDescriptionCleaned = Helper.escapeHtml(rawPrediction);

            return '<a\n              class="lp__place notranslate"\n              data-name="' + predictionsDescriptionCleaned + '"\n              data-place="' + placeId + '"\n              data-reference="' + reference + '"\n              data-route="' + Helper.escapeHtml(addressPart) + '"\n              >' + predictionsDescriptionCleaned + '</a>';
          }).join('');
          if (searchPredictionsHTML === '') {
            locationPanel.showWarning(locationPanel.i18n.ENTER_STREET_AND_NUMBER);
          } else {
            window.app.components.locationPanel.setRawLinks(searchPredictionsHTML);
            window.app.components.locationPanel.UI.renderLinks();
            window.app.components.locationPanel.UI.showPlacesContainer();
          }
        }
      };
      autocomplete.showDropdown = function (dropdown, html) {
        $(dropdown).show();
        $(html).html(html);
      };

      autocomplete.hideDropdown = function (dropdown, html) {
        $(dropdown).hide();
        $(html).html('');
        $('#splash').removeAttr('style');
      };

      autocomplete.focusPopupPanel = function () {
        if ($('#imysearchstring_popupmode').length > 0) {
          $('#close_smartbnr').click();
          $('#imysearchstring_popupmode').keyup().focus().val('');
        }
      };

      init();
    };
  })(jQuery);

  $.fn.isVisible = function () {
    return $.expr.filters.visible(this[0]);
  };

  /** ***************************************************************************
   *
   * Old event handlers
   *
   * TODO: Refactor them too
   *
   *****************************************************************************/

  // CLICK EVENT ON SUBMIT BTN
  $(document).on('click', '#ideliveryareaform .extralargebutton, #ideliveryareaform_popup .extralargebutton', function (e) {
    console.log('eventSubmit on LocationPanel.js:');

    window.app.services.tracking.send({
      eventName: 'hasUsedSelectedLocation',
      onlyTrackOnce: true
    });

    // Handle geo address
    if (window.app.services.user.hasAddress(ADDRESS.GEO)) {
      // Just because we need toString() method, I'll create a new Address
      var address = new Address(window.app.services.user.getAddress(ADDRESS.GEO));

      if (address.toString() === window.app.components.locationPanel.UI.val()) {
        console.log('[OLD LocationPanel] "user > addresses > geo > string" === "search string" => searchAddress(geolocation)', address);

        if (address.postcode) {
          // Set the localStorage object for prefill
          window.app.components.locationPanel.userService.setSelectedAddressByGeo(address);
          window.app.components.locationPanel.searchAddress(address);
          return;
        }
        // TODO is there Romania exception? Ask Ugur
      }
    }

    var deliveryareaform = $(e.target).closest('form');

    AutoComplete.settings.popupmode = $(this).hasClass('popupmode');

    var firstSearchPrediction = localStorage.getItem('searchPredictions[0]');
    localStorage.removeItem('searchPredictions[0]');

    if (Cookies.get('searchstring') === $(locationPanel.searchInput.selector, deliveryareaform).val()) {
      var postcode = $('#isearchstring', deliveryareaform).val();
      var mysearchstring = Cookies.get('searchstring');
      var longitude = false;
      var latitude = false;

      // if searchstring is not a zipcode, then add it to postlocation. Otherwise ignore it
      if (!$.trim(mysearchstring).match(AutoComplete.settings.pcMatch)) {
        if (Cookies.get('searchstringmapper')) {
          var searchstringmapper = JSON.parse(Cookies.get('searchstringmapper'));
          if (searchstringmapper !== null && (typeof searchstringmapper === 'undefined' ? 'undefined' : _typeof(searchstringmapper)) === 'object') {
            if (searchstringmapper.location === mysearchstring) {
              latitude = searchstringmapper.latitude;
              longitude = searchstringmapper.longitude;
            }
          }
        }
        if (latitude === false && longitude === false) {
          if ($.isNumeric(Cookies.get('latitude')) && $.isNumeric(Cookies.get('longitude'))) {
            latitude = Cookies.get('latitude');
            longitude = Cookies.get('longitude');
          }
        }
        AutoComplete.postLocation(postcode, latitude, longitude, false, false, false, mysearchstring, mysearchstring);
      } else {
        AutoComplete.postLocation($('#isearchstring', deliveryareaform).val());
      }
      return false;
    } else if (firstSearchPrediction) {
      AutoComplete.geoCodeService(firstSearchPrediction);
      return false;
    } else if (locationPanel.searchInput.$.val() !== '') {
      AutoComplete.postLocation(locationPanel.searchInput.$.val());
      return false;
    } else if ($(dropdownOutput + ' #reference:first-child').length === 0) {
      AutoComplete.postLocation('');
      return false;
    } else if (locationPanel.searchInput.$.val() === '') {
      AutoComplete.postLocation('');
      return false;
    }
    return false;
  });

  // focus change in dropdown should select the item too
  $(dropdown).on('focus', '*', function (e) {
    if ($(dropdown).is(':visible') && $(e.currentTarget).hasClass('lp__place') && !$(e.currentTarget).hasClass('selected')) {
      $('a', dropdown).removeClass('selected');
      $(e.currentTarget).addClass('selected');
    }
  });

  // <editor-fold desc="REFACTORED EVENT HANDLERS, USING $doc">

  $doc.on('click', locationPanel.searchResults.selector + ' a', function (e) {
    var geolocationItem = document.querySelector(locationPanel.geoaddress.selector);
    var recentItem = document.querySelector(locationPanel.recentaddress.selector);
    var selectedItem = 'suggestions';
    if (geolocationItem !== null && geolocationItem.classList.contains('selected')) {
      selectedItem = 'my location';
    } else if (recentItem !== null && recentItem.classList.contains('selected')) {
      selectedItem = 'recent';
    }
    window.app.services.tracking.send({
      eventName: 'hasUsedSelectedLocation',
      onlyTrackOnce: true
    });

    window.app.services.tracking.send({
      eventName: 'hasSubmittedLocation',
      eventData: {
        resultType: selectedItem
      },
      onlyTrackOnce: true
    });
    // For Roy's prefill address
    console.log('click(), Removing last address search');
    window.localStorage.removeItem('SelectedAddress');
    window.localStorage.removeItem('lastSelectedAddress');

    var link = this;

    // Set savedAddressId to cookies for checking it on CS side. For more details please check - FED-12312.

    var _window$app$getState = window.app.getState(),
        savedAddresses = _window$app$getState.savedAddresses;

    var savedAddressId = savedAddresses && link.dataset.savedaddressid && savedAddresses[link.dataset.savedaddressid].savedAddressId;
    if (link.classList.contains('js-saved-address') && savedAddressId) {
      Cookies.set('savedAddressId', encodeURIComponent(savedAddressId), { secure: true });
    } else {
      if (Cookies.get('savedAddressId')) {
        Cookies.remove('savedAddressId');
      }
    }

    // For Roy's prefill address
    if (link.dataset.suggestId) {
      var suggestedAddresses = window.localStorage.getItem('suggestedAddresses') || '{}';
      var suggestions = JSON.parse(suggestedAddresses);
      window.localStorage.setItem('SelectedAddress', JSON.stringify(suggestions[link.dataset.suggestId]));
    }

    if (link.dataset.address) {
      // Get the addresses from store.js if isset, use the old method otherwise
      var parsedAddress = link.dataset.savedaddressid && window.app.getState().savedAddresses && window.app.getState().savedAddresses[link.dataset.savedaddressid] ? window.app.getState().savedAddresses[link.dataset.savedaddressid] : JSON.parse(link.dataset.address);

      var searchAddress = new Address(parsedAddress);

      if (searchAddress.toString().replace(/\s/g, '') !== '') {
        AutoComplete.geoCodeService(searchAddress.toString(), $(this), true);
      } else {
        window.app.components.locationPanel.userService.setSelectedAddressByGeo(parsedAddress);
        window.app.components.locationPanel.searchAddress(parsedAddress);
      }
    } else {
      AutoComplete.clickReference($(this));
    }
  });

  $doc.on('click', locationPanel.searchInput.selector, function (e) {
    e.preventDefault();

    if ($(dropdownOutput).length > 0) {
      $(dropdown).show();
      locationPanel.searchInput.$.addClass('open');
      if ($(button).parents('.lp-popup__wrapper').length === 0) {
        $(button).hide();
      }
    }

    /**
     * If search input is clicked, check for geolocation address, if it is the value, remove it just like
     * regular searches so that user can enter own search text. This only happens in step1, as we add the string
     * on component/locationPanel > eventGeolocationFound()
     */
    if (window.app.services.user.hasAddress(ADDRESS.GEO)) {
      // Just because we need toString() method, I'll create a new Address
      var address = new Address(window.app.services.user.getAddress(ADDRESS.GEO));

      if (address.toString() === window.app.components.locationPanel.UI.val()) {
        console.log('[OLD LocationPanel] "user > addresses > geo > string" === "search string" => clear input field');
        window.app.components.locationPanel.UI.val('');

        // User may be logged in, if the input is empty (e.g. on popup) and user clicks the empty input, get "My Addresses" list.
        // To make this, send BACKSPACE char to Google :( This may be improved, this is only a workaround
        window.app.components.locationPanel.UI.renderLinks();
        return;
      }
    }

    if ($(this).val() !== '' && $(this).val() === AutoComplete.settings.searchfield) {
      // Search if there is a value inside the input
      AutoComplete.inputSearchField($(this).val());
      // Clear the input to let user write
      $(this).val('');
    } else if ($(this).val() === '' && AutoComplete.settings.searchfield === '') {
      // User may be logged in, if the input is empty (e.g. on popup) and user clicks the empty input, get "My Addresses" list.
      // To make this, send BACKSPACE char to Google :( This may be improved, this is only a workaround
      window.app.components.locationPanel.UI.renderLinks();
    }

    if ($('#smartbnr').length > 0) {
      // close smartbanner, interferes to much
      $('#close_smartbnr').click();
    }
  });

  /**
   * Hide the location panel popup when user presses ESC key
   */
  $doc.on('keydown', 'body', function (e) {
    if (e.which === keyCode.ESCAPE && $('.lp-popup').is(':visible')) {
      window.app.components.locationPanel.UI.closePopup();
    }
  });

  /**
   * Key bindings for searchResults: ENTER, UP, DOWN, RIGHT
   */
  $doc.keyup(function (e) {
    // If the panel is not visible/focused, skip the whole logic
    if (!locationPanel.searchInput.$.is(':visible') || document.body.classList.contains('step1') && !locationPanel.searchInput.$.is(':focus')) {
      return;
    }

    var itemsFound = $('a', locationPanel.searchResults.selector).length;

    // If pressed ENTER
    if (e.which === keyCode.ENTER) {
      // Prevent default submit behaviour
      e.preventDefault();

      // Get and trim the search string
      var searchString = locationPanel.searchInput.$.val() !== undefined ? locationPanel.searchInput.$.val().trim() : '';

      // Check if the string is a postcode and postcode does not have multiple options
      // (If there are multiple options of a postcode, findRestaurants.php returns an HTML, containing ".popupcontent" div)
      if (searchString.match(AutoComplete.settings.pcMatch) &&
      // For this feature we don't want to end up in findRestaurants.
      window.app.services.feature.isActive(window.app.enums.FEATURES.SHOW_POSTCODE_USING_GEOCODING_IN_LOCATION_PANEL_SUGGESTIONS) === false && $('.popupcontent', locationPanel.searchResults.selector).length === 0) {
        // We need to clearTimeout before sending it, because there is a timeout bind for collectPrediction() func
        window.clearTimeout(delayTimer);
        // Now we can send
        AutoComplete.postLocation(searchString);
        console.log('Selecting postcode: Removing last address search');
        window.localStorage.removeItem('SelectedAddress');
        window.localStorage.removeItem('lastAddress');

        window.app.services.tracking.send({
          eventName: 'hasSubmittedLocation',
          eventData: {
            resultType: 'suggestion'
          },
          onlyTrackOnce: true
        });
        window.app.services.tracking.send({
          eventName: 'hasUsedSelectedLocation',
          onlyTrackOnce: true
        });
        return false;
      } else if (itemsFound > 0) {
        // Prevent default behaviour
        e.preventDefault();
        // Go to selected search result
        window.app.services.tracking.send({
          eventName: 'hasUsedSelectedLocation',
          onlyTrackOnce: true
        });
        $('a.selected', locationPanel.searchResults.selector).click();
        return false;
      }
    } else if (e.which === keyCode.DOWN && itemsFound > 1) {
      // Prevent default behaviour
      e.preventDefault();
      // Selected search result. When popup is open, eliminate hidden results of the main location panel with ':visible'
      var selected = $('a.selected', locationPanel.searchResults.selector);
      // Unselect results
      $('a', locationPanel.searchResults.selector).removeClass('selected');
      // Go next
      if (selected.nextAll('a').first().length > 0) {
        selected.nextAll('a').first().addClass('selected').focus();
        // If there is more than one result, return to the first
      } else if (selected.prevAll('a').first().length > 0) {
        selected.siblings('a').first().addClass('selected').focus();
      }
    } else if (e.which === keyCode.UP && itemsFound > 1) {
      // Prevent default behaviour
      e.preventDefault();
      // Selected search result
      var _selected = $('a.selected', locationPanel.searchResults.selector);
      // Unselect results
      $('a', locationPanel.searchResults.selector).removeClass('selected');
      // Go to previous
      if (_selected.prevAll('a').first().length > 0) {
        _selected.prevAll('a').first().addClass('selected').focus();
        // If there is more than one result, go to the last
      } else if (_selected.nextAll('a').first().length > 0) {
        _selected.siblings('a').last().addClass('selected').focus();
      }
      // If only one result is available, let user select it
    } else if ((e.which === keyCode.DOWN || e.which === keyCode.UP) && itemsFound === 1) {
      // Selected search result
      var _selected2 = $('a.selected', locationPanel.searchResults.selector);
      _selected2.focus();
      // If searchInput (or the one in the popup) focused, send the text inside to Google AutoComplete
    } else if (locationPanel.searchInput.$.is(':focus')) {
      var searchValue = locationPanel.searchInput.$.val();
      AutoComplete.inputSearchField(searchValue);
    }
  });

  /**
   * Prevent default UP & DOWN scrolling
   */
  $doc.keydown(function (e) {
    if (locationPanel.searchResults.$.is(':visible') && (e.which === keyCode.ENTER || e.which === keyCode.UP || e.which === keyCode.DOWN)) {
      e.preventDefault();
    }
  });

  /**
   * Hide search results when clicking outside
   * Changed from jquery to native, jquery would target the device banner when found.
   */
  document.body.addEventListener('click', function (e) {
    if (locationPanel.searchResults.$.is(':visible')) {
      if (e.target.classList.contains('lp__input') || e.target.classList.contains('lp__place') || e.target.classList.contains('lp__search-button')) {
        return;
      }
      window.app.components.locationPanel.UI.hidePlacesContainer();
      if ($(button).parents('.lp-popup__wrapper').length === 0) {
        locationPanel.searchInput.$.removeClass('open');
        $(button).show();
      }
    }
  });

  $doc.on('blur', locationPanel.searchInput.selector, function (e) {
    if (window.app.components.locationPanel.UI.val() === '') {
      console.log('LocationPanel on blur');
      if (AutoComplete.settings.searchfield !== '') {
        window.app.components.locationPanel.UI.val(AutoComplete.settings.searchfield);
      } else if (window.app.services.user.hasAddress(ADDRESS.GEO) && $('body').hasClass('step1')) {
        // Just because we need toString() method, I'll create a new Address
        var address = new Address(window.app.services.user.getAddress(ADDRESS.GEO));
        window.app.components.locationPanel.UI.val(address.toString());
      }
    }
  });

  // </editor-fold>
});
/* global app, $, Cookies, ADDRESS */

$(function () {
  // api call for customer addresses
  // only needed from step1 till step4
  // do nothing if no cookies are set (iv/verify)

  var body = $('body');

  if (body.hasClass('supplementary')) {
    return;
  }

  if (body.hasClass('step1') || body.hasClass('step5') || body.hasClass('customerservice')) {
    return false;
  }

  if (!Cookies.get('iv') || !Cookies.get('verify')) {
    if (window.app.services.addressStorage.hasSavedAddresses()) {
      window.app.services.addressStorage.removeSavedAddresses();
    }

    return false;
  }

  if (!window.app.services.addressStorage.hasSavedAddresses()) {
    window.app.services.user.handleSavedAddresses().then(function (data) {
      console.log(data);
      if (data !== false) {
        window.app.services.user.setAddress(ADDRESS.SAVED, data);
      }
    });
  } else {
    var addresses = window.app.services.addressStorage.retrieveSavedAddresses();

    if (addresses.length > 0) {
      window.app.services.user.setAddress(ADDRESS.SAVED, addresses);
    }
  }
});
/* global
  $
  active_obj2
  ActiveXObject
  bottomMargin
  checkRadiobutton
  column
  Cookies
  cur_value
  delta
  filterpanel
  footer_top_Ypos
  footerVisible
  formatted
  header_bottom_Ypos
  i
  jQuery
  modalWrapper
  newtop
  newtop
  st
  state
  target_element
  theform
  topMargin
  viewport_bottom_Ypos
  viewport_top_Ypos
*/
var connection;
var connection2;
var connection3;
var connectionform;
var connectionurlform;
var imageconnection;
var active_obj = null;
var active_content = null;
var active_content2 = null;
var active_content3 = null;
var active_contentform = null;
var active_content_formurl = null;
var windowwidth = getWindowSize().x;
var windowheight = getWindowSize().y;
var scrollpos = 0;
var popupwidth = 520;
var popupheight = 300;
var lastiteration = new Array();
var userPanel = false;

function xmlRequestGet(url, selector) {
  $.ajax({
    type: 'GET',
    url: url
  }).done(function (response) {
    return $(selector).html(response);
  });
}

var originalPreventDefault = jQuery.Event.prototype.preventDefault;
jQuery.Event.prototype.preventDefault = function () {
  if (window.event) {
    window.event.returnValue = false;
    window.event.cancelBubble = true;
  }
  return originalPreventDefault.apply(this, arguments);
};

Number.prototype.toMoney = function (decimals, decimal_sep, thousands_sep) {
  var n = this;
  var c = isNaN(decimals) ? 2 : Math.abs(decimals);
  var d = decimal_sep || '.';
  var t = typeof thousands_sep === 'undefined' ? ',' : thousands_sep;
  var sign = n < 0 ? '-' : '';
  var i = parseInt(n = Math.abs(n).toFixed(c)) + '';
  var j = (j = i.length) > 3 ? j % 3 : 0;
  return sign + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};

function format_price(price, currency) {
  if (!isNaN(price)) {
    var formatted = price.toMoney(currency.nrofdecimals, currency.decimalsepparator, currency.thousandsepparator);

    if (typeof currency.symbolposition !== 'undefined' && currency.symbolposition == 'end') {
      return formatted + ' ' + currency.symbol;
    }
    return currency.symbol + (currency.symbol !== '' ? ' ' : '') + formatted;
  }
  console.error('Cannot format price of ' + price);
  return price;
}

function in_array(eltvalue, arr) {
  var restelt;
  for (restelt in arr) {
    if (arr[restelt] === eltvalue) return true;
  }
  return false;
}

function relocatePopup(onscroll) {
  var newX = void 0;
  var newY = void 0;
  // check is need to relocate
  if (!onscroll) {
    // resized the window..store in global vars
    windowwidth = getWindowSize().x;
    windowheight = getWindowSize().y;
    windowwidth = $(window).width();
    windowheight = $(window).height();
  }

  // scrolled set new scrollpos
  scrollpos = getScrollPosition().y;
  if (active_obj && active_obj.id === 'popupdiv') {
    var popupsize = getElementSize(active_obj);
    if (onscroll) {
      var str = new String(active_obj.style.top);
      var popupy = parseInt(str.substr(0, str.length - 2));

      if (isNaN(popupy)) popupy = 0;
      if (popupsize.y >= windowheight) {
        newY = scrollpos;
        if (popupy + popupsize.y > newY && newY > popupy) {
          newY = popupy; // same, do not scroll
        }
      } else {
        newY = Math.round(scrollpos + windowheight / 2 - popupsize.y / 2);
      }

      newX = Math.round(windowwidth / 2 - popupsize.x / 2);
      window.setTimeout('interpolateLocation(\'' + active_obj.id + '\', ' + newX + ', ' + newY + ', 20)', 1);
    } else {
      popupsize = getElementSize(active_obj);
      newY = Math.round(scrollpos + windowheight / 2 - popupsize.y / 2);
      newX = Math.round(windowwidth / 2 - popupsize.x / 2);
      window.setTimeout('interpolateLocation(\'' + active_obj.id + '\', ' + newX + ', ' + newY + ', 20)', 1);
    }
  }
}

function setInterpolateLocation(locationobjid, newX, newY, iteration) {
  if ($('#' + locationobjid).hasClass('')) return false;

  if (getIterationNumber(locationobjid) <= iteration) {
    var locationobj = document.getElementById(locationobjid);

    if ($('#' + locationobj.id).hasClass('fixed')) {} else {
      if (locationobj) {
        if (locationobj.style.setProperty) {
          // mozilla
          locationobj.style.setProperty('left', newX + 'px', null);
          locationobj.style.setProperty('top', newY + 'px', null);
        } else {
          // ie
          locationobj.style.left = newX + 'px';
          locationobj.style.top = newY + 'px';
        }
      }
      updateIterationNumber(locationobjid, iteration);
    }
  }
}

function interpolateLocation(locationobjid, toX, toY, maxiterations) {
  var its = 10;
  var i, newX, newY;
  var locationobj = document.getElementById(locationobjid);
  toX = Math.round(toX);
  toY = Math.round(toY);
  var loc = findPos(locationobj);
  if (maxiterations > 0 && maxiterations < 100) its = maxiterations;

  updateIterationNumber(locationobjid, 0);

  for (i = 1; i <= its; i++) {
    newX = Math.round(loc['left'] + (toX - loc['left']) * (i / its));
    newY = Math.round(loc['top'] + (toY - loc['top']) * (i / its));
    window.setTimeout("setInterpolateLocation('" + locationobj.id + "', " + newX + ', ' + newY + ', ' + i + ')', i * 10);
  }
}

function updateIterationNumber(locationobjid, iteration) {
  var i;
  for (i = 0; i < lastiteration.length; i++) {
    if (lastiteration[i][0] === locationobjid) {
      lastiteration[i][1] = iteration;
      return;
    }
  }
  lastiteration.push([locationobjid, iteration]);
}

function getIterationNumber(locationobjid) {
  var i;

  for (i = 0; i < lastiteration.length; i++) {
    if (lastiteration[i][0] === locationobjid) {
      return lastiteration[i][1];
    }
  }
  return 0;
}

function setPopupLocation(obj) {
  if (!obj) {
    obj = active_obj;
  }
  if (obj) {
    scrollpos = getScrollPosition().y;
    var newY = void 0;
    var str = new String(obj.style.top);
    var popupsize = getElementSize(obj);

    if (popupsize.y >= windowheight) {
      newY = scrollpos;
    } else {
      newY = Math.round(scrollpos + $(window).height() / 2 - popupsize.y / 2);
    }
    var newX = Math.round($(window).width() / 2 - popupsize.x / 2);

    setInterpolateLocation(obj.id, newX, newY, 1000);

    // COMPENSATE IF POPUP IS LARGER THAN BODY
    var bodyobj = document.getElementsByTagName('BODY')[0];
    var blackoutstyle = document.getElementById('blackoutdiv').style;
    if (blackoutstyle.setProperty) {
      // Mozilla
      var docHeight = Math.max(bodyobj.offsetHeight, document.documentElement.clientHeight, bodyobj.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);
      blackoutstyle.setProperty('height', docHeight + 'px', null);
    } else {
      var docHeight = Math.max(bodyobj.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, bodyobj.scrollHeight, bodyobj.style.pixelHeight, bodyobj.style.height);
      blackoutstyle.height = docHeight + 'px';
    }
    blackoutstyle.visibility = 'visible';
  }
}

function callBack(content) {
  $(active_content).html(content);
}

function callBack2(content) {
  $(active_content2).html(content);
}

function callBack3(content) {
  $(active_content3).html(content);
}

function callBackForm(content) {
  var ifRedirected = redirectIfCaptcha(content);

  if (ifRedirected === false) {
    $(active_contentform).html(content);
    if (ie) {
      active_contentform.innerHTML = content;
    }
  }
}

var ie = function () {
  // IE checker
  var undef;
  var v = 3;
  var div = document.createElement('div');
  var all = div.getElementsByTagName('i');
  while (div.innerHTML = '<!--[if gt IE ' + ++v + ']><i></i><![endif]-->', all[0]) {}
  return v > 4 ? v : undef;
}();

// we need this because all modern browsers wont eject form in form via ajax

function xmlRequestSimple(id, destination_id, page, postvars) {
  if (typeof page !== 'undefined') {
    var serialized = '';

    if (postvars) {
      serialized = postvars;
    } else {
      $('input, select', '#' + id).each(function (i) {
        var $li = $(this);
        var $name = $li.attr('name');
        var $val = $li.val();
        if (typeof $name !== 'undefined') {
          serialized += $name + '=' + $val + '&';
        }
      });
    }
    $.ajax({
      type: 'POST',
      url: page,
      data: serialized,
      success: function success(data) {
        if (data) {
          $('#' + destination_id).html(data);
          $('#' + destination_id).css('visibility', 'visible');
          return false;
        }
      }
    });
  }
}

function xmlRequest(page, postvars, destination_id, focus_id) {
  var disableIcon = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var className = arguments[5];
  var callbackNew = arguments[6];

  if (page === '/xHttp/CustomerRetrievePassword.php') {
    window.app.services.tracking.send({
      eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_FORGOT_PASSWORD
    });
  }
  if (connection) {
    connection = null; // Don't use 'delete' anymore
  }

  active_content = document.getElementById(destination_id);
  if (window.XMLHttpRequest) {
    connection = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // IE
    try {
      connection = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      connection = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  if (typeof className !== 'undefined') {
    $('#' + destination_id).removeClass().addClass(className);
  }

  if (connection) {
    connection.open('POST', page, true);
    connection.onreadystatechange = function () {
      if (connection.readyState !== 4) {
        if (!disableIcon) {
          $('#' + destination_id).html('<div style="height:' + $('#' + destination_id).offsetHeight + 'px;"><img src="/images/loading.gif" border="0"></div>');
        }
        return;
      }
      eval('callBack(connection.responseText);');
      if (typeof callbackNew !== 'undefined') {
        callbackNew(connection.responsetext);
      }

      if (focus_id) {
        try {
          var fcs = document.getElementById(focus_id);
          if (fcs) {
            setTimeout(function () {
              document.getElementById(focus_id).focus();
            }, 100);
            setTimeout(function () {
              document.getElementById(focus_id).focus();
            }, 100);
          }
        } catch (e) {
          try {
            fcs.focus();
          } catch (e2) {}
        }
      }
      if (destination_id === 'popupdiv') {
        popUp(destination_id, className);
      } else if (destination_id === 'userPanel') {
        popUpMini(destination_id, className);
      } else {
        $('#' + destination_id).css('visibility', 'visible');
      }
      connection = null; // Don't use 'delete' anymore
    };

    connection.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    connection.send(postvars);
  }
}

function popUpMini(objid) {
  if (active_obj != null) return false;
  var obj = document.getElementById(objid);
  active_obj = obj;
  active_obj.style.visibility = 'visible';

  setModal(active_obj);
}

function xmlImageReloadRequest(page, postvars, destinationimg_id) {
  var imgcontentelt = document.getElementById(destinationimg_id);
  imgcontentelt.src = '' + page + '?' + postvars;
}

function xmlFormRequestUrlRedirect(theform, destination_id, error_id, the_action, disableIcon) {
  var datastring = $(theform).serialize();
  if (datastring.length === 0) {
    datastring = 'tp=1';
  } else {
    datastring = datastring + '&tp=2';
  }
  if (the_action) {
    xmlRequestUrlRedirect(the_action, datastring, destination_id, error_id, disableIcon);
  } else {
    xmlRequestUrlRedirect(theform.action, datastring, destination_id, error_id, disableIcon);
  }
}

function xmlRequestUrlRedirect(page, datastring, destination_id, error_id) {
  $.ajax({
    type: 'POST',
    url: page,
    data: datastring,
    dataType: 'json',
    success: function (destination_id, error_id) {
      return function (data, textStatus, jqXHR) {
        try {
          var dest = $('#' + destination_id);
          var errdest = $('#' + error_id);
          switch (data['type']) {
            case 'url':
              window.top.location = data['value'];
              break;
            case 'formpost':
              var submitForm = document.createElement('FORM');
              document.body.appendChild(submitForm);
              submitForm.method = 'POST';
              for (i = 0; i < data['inputs'].length; i += 2) {
                var newElement = document.createElement('input');
                newElement.name = data['inputs'][i];
                newElement.type = 'hidden';
                newElement.value = data['inputs'][i + 1];
                submitForm.appendChild(newElement);
              }
              submitForm.action = data['value'];
              submitForm.submit();
              break;
            case 'error':
              var i;
              for (i = 0; i < data['markfields'].length; i++) {
                $('#' + data['markfields'][i]).addClass('marked');
              }
              if (document.getElementById(error_id)) {
                document.getElementById(error_id).style.display = 'block';
                $(document.getElementById(error_id)).html(data['value']);
              }

              if (error_id === 'popupdiv') {
                popUp(destination_id, data.popuptype);
              }
              break;
            case 'html':
              dest.html(data['value']);
              if (destination_id === 'popupdiv') {
                popUp(destination_id, data.popuptype);
              }
              break;
            default:
              dest.html(jqXHR.responseText);
              if (destination_id === 'popupdiv') {
                popUp(destination_id, data.popuptype);
              }
              break;
          }
        } catch (e) {
          // alert('should not happen2.3:'+jqXHR.responseText);
          dest.html(jqXHR.responseText);
          if (destination_id === 'popupdiv') {
            popUp(destination_id);
          }
        }
      };
    }(destination_id, error_id)
  });
}

function xmlRequestCallback(page, postvars, callbackproc) {
  // except IE
  if (connection) {
    connection = null; // Don't use 'delete' anymore
  }

  if (window.XMLHttpRequest) {
    connection = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // IE
    try {
      connection = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      connection = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  if (connection) {
    connection.open('POST', page, true);
    connection.onreadystatechange = function () {
      if (connection.readyState !== 4) {
        return;
      }
      // process the url
      var responsetext = connection.responseText;
      eval(callbackproc + '(connection.responseText);');
      connection = null; // Don't use 'delete' anymore
    };
    connection.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    connection.send(postvars);
  }
}

function xmlRequest2(page, postvars, destination_id, disableIcon) {
  var disableIcon = disableIcon || false;
  // except IE

  if (connection2) {
    connection2 = null; // Don't use 'delete' anymore
  }

  active_content2 = document.getElementById(destination_id);

  if (window.XMLHttpRequest) {
    connection2 = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // IE
    try {
      connection2 = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      connection2 = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  if (connection2) {
    connection2.open('POST', page, true);
    connection2.onreadystatechange = function () {
      if (connection2 && connection2.readyState !== 4) {
        if (!disableIcon) {
          $('#' + destination_id).html('<div style="height:' + $('#' + destination_id).offsetHeight + 'px;"><img src="/images/loading.gif" border="0"></div>');
        }
        return;
      }
      eval('callBack2(connection2.responseText);');
      if (destination_id === 'popupdiv') {
        popUp(destination_id);
      }
      connection2 = null; // Don't use 'delete' anymore
    };
    connection2.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    connection2.send(postvars);
  }
}

function xmlRequest3(page, postvars, destination_id, disableIcon, cb) {
  // except IE
  var disableIcon = disableIcon || false;
  if (connection3) {
    connection3 = null; // Don't use 'delete' anymore
  }

  active_content3 = document.getElementById(destination_id);

  if (window.XMLHttpRequest) {
    connection3 = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // IE
    try {
      connection3 = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      connection3 = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  if (connection3) {
    connection3.open('POST', page, true);
    connection3.onreadystatechange = function () {
      if (connection3.readyState !== 4) {
        if (!disableIcon) {
          $('#' + destination_id).html('<div style="height:' + $('#' + destination_id).offsetHeight + 'px;"><img src="/images/loading.gif" border="0"></div>');
        }
        return;
      }
      eval('callBack3(connection3.responseText);');
      if (destination_id === 'popupdiv') {
        popUp(destination_id);
      }
      if (cb) {
        cb();
      }
      connection3 = null; // Don't use 'delete' anymore
    };
    connection3.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    connection3.send(postvars);
  }
}

function xmlRequestForm(page, postvars, destinationId) {
  var dwdw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;
  var disableIcon = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var focusId = arguments[5];
  var callback = arguments[6];
  var callBackAlways = arguments[7];

  if (connectionform) {
    connectionform = null; // Don't use 'delete' anymore
  }

  active_contentform = dwdw.document.getElementById(destinationId);
  if (window.XMLHttpRequest) {
    connectionform = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // IE
    try {
      connectionform = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      connectionform = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }
  if (connectionform) {
    connectionform.open('POST', page, true);
    connectionform.onreadystatechange = function () {
      if (connectionform.readyState !== 4) {
        if (!disableIcon) {
          var $dest = $('#' + destinationId);
          $dest.html('<div style="height:' + $dest.offsetHeight + 'px;"><img src="/images/loading.gif" border="0"></div>');
        }
        return;
      }
      eval('callBackForm(connectionform.responseText);');
      if (connectionform.status === 403 && page.includes('/xHttp/Auth/login.php')) {
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_FORM_ERROR,
          eventData: {
            formType: 'Login Form',
            formErrorType: 'Login Error'
          }
        });
      }
      if (focusId) {
        var fcs = document.getElementById(focusId);
        try {
          if (fcs) {
            setTimeout(function () {
              document.getElementById(focusId).focus();
            }, 100);
            setTimeout(function () {
              document.getElementById(focusId).focus();
            }, 100);
          }
        } catch (e) {
          try {
            if (fcs) {
              fcs.focus();
            }
          } catch (e2) {}
        }
      }

      if (destinationId === 'popupdiv') {
        popUp(destinationId);
      } else if (destinationId === 'userPanel') {
        popUpMini(destinationId);
      }

      if (typeof callback === 'function' && connectionform.readyState === 4 && connectionform.status === 200) {
        // custom callbacks after response
        callback();
      }
      if (typeof callBackAlways === 'function' && connectionform.readyState === 4) {
        callBackAlways();
      }
      connectionform = null; // Don't use 'delete' anymore
    };
    connectionform.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    connectionform.send(postvars);
  }
}

function xmlFormSubmit(formId, destinationId, action) {
  var fwdw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;
  var dwdw = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : window;
  var disableIcon = arguments[5];
  var focusId = arguments[6];
  var className = arguments[7];
  var callback = arguments[8];
  var callBackAlways = arguments[9];

  var postvars = [];
  var i = void 0,
      j = void 0;
  var form = fwdw.document.getElementById(formId);

  for (i = 0, j = form.elements.length; i < j; i++) {
    // check radio, checkbuttons and selects
    if (['text', 'textarea', 'hidden', 'password'].includes(form.elements[i].type) || ['radio', 'checkbox'].includes(form.elements[i].type) && form.elements[i].checked) {
      postvars.push(form.elements[i].name + '=' + encodeURIComponent(form.elements[i].value));
    } else if (form.elements[i].type === 'select-one' || form.elements[i].type === 'select') {
      postvars.push(form.elements[i].name + '=' + encodeURIComponent(form.elements[i].options[form.elements[i].selectedIndex].value));
    }
  }

  var postVarString = postvars.join('&');

  if (formId === 'icustomerloginform') {
    var linkType = postvars.includes('twofactorcode') ? '2FA' : 'Login Modal';
    window.app.services.tracking.send({
      eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_LOGIN,
      eventData: {
        linkType: linkType
      }
    });
  }
  if (typeof className !== 'undefined') {
    $('#' + destinationId).removeClass().addClass(className);
  }

  if (!action) {
    action = form.action;
  }

  xmlRequestForm(action, postVarString, destinationId, dwdw, disableIcon, focusId, callback, callBackAlways);

  return false;
}

function popUp(objid, classname) {
  if (active_obj != null && active_obj.id !== 'irestaurantresults') return false;
  var obj = document.getElementById(objid);

  popupwidth = getElementSize(obj).x;
  popupheight = getElementSize(obj).y;

  if (classname != null) $(obj).addClass(classname);
  if (!$(obj).hasClass('fixed')) {
    setPopupLocation(obj);
  }
  setModal(obj);

  active_obj = obj;
  active_obj.style.visibility = 'visible';
}

function setModal(obj) {
  // store focus of currently active element
  window.lastFocus = document.activeElement;
  // modal div should be the modal-wrapper if available
  if ($('.modal-wrapper', obj).length) {
    modalWrapper = $('.modal-wrapper', obj);
  } else {
    modalWrapper = obj;
  }
  modalWrapper.addClass('modal');

  window.app.helpers.keepFocusWithinModal({ modalElement: obj[0] });
}

function unsetModal(obj) {
  // Check if obj is a jQuery object, otherwise hasClass() will throw 'not function' err
  if (!(obj instanceof jQuery) || !obj.hasClass('modal')) {
    return;
  }
  obj.removeClass('modal');
  $('html body').off('focus keydown click');
  // restore the focus to the element that had it before opening
  window.lastFocus.focus();
}

function closeActivePopUpMini() {
  $(active_obj2).html('');
  unsetModal(active_obj2);
}

function closeActivePopUp(popup) {
  if (popup !== 'undefined' && active_obj === null) {
    active_obj = document.getElementById(popup);
  }
  if (active_obj === null) {
    // nothing to see here...
    return;
  }

  unsetModal(active_obj);

  // RESET popup class + attributes
  $('#' + active_obj.id).css({
    'top': '',
    'left': ''
  }).removeClass().addClass('popupdiv');

  active_obj.innerHTML = '';
  active_obj.width = 1;
  active_obj.height = 1;
  active_obj.style.visibility = 'hidden';
  active_obj = null;

  var d2 = document.getElementById('blackoutdiv');
  if (d2) {
    d2.style.visibility = 'hidden';
    d2.style.height = 'inherit';
  }
}

function findPos(posobj) {
  var curleft = 0;
  var curtop = 0;

  if (posobj.offsetParent) {
    while (posobj.offsetParent) {
      curleft += posobj.offsetLeft - posobj.scrollLeft;
      curtop += posobj.offsetTop - posobj.scrollTop;
      var position = '';
      if (posobj.style && posobj.style.position) position = posobj.style.position.toLowerCase();
      if (position === 'absolute' || position === 'relative') break;
      while (posobj.parentNode !== posobj.offsetParent) {
        posobj = posobj.parentNode;
        curleft -= posobj.scrollLeft;
        curtop -= posobj.scrollTop;
      }
      posobj = posobj.offsetParent;
    }
  } else {
    if (posobj.x) curleft += posobj.x;
    if (posobj.y) curtop += posobj.y;
  }
  return { left: curleft, top: curtop };
}

function getWindowSize() {
  if (typeof window.innerWidth !== 'undefined') {
    return { 'x': window.innerWidth, 'y': window.innerHeight };
  }
  return { 'x': document.documentElement.clientWidth, 'y': document.documentElement.clientHeight };
}

function getElementSize(elm) {
  if (elm) {
    // test
    return { 'x': elm.offsetWidth, 'y': elm.offsetHeight };
  }
  return false;
}

function getScrollPosition() {
  var scrollPosY = document.documentElement.scrollTop;
  var scrollPosX = document.documentElement.scrollLeft;

  if (scrollPosY === 0) {
    if (window.pageYOffset) {
      scrollPosY = window.pageYOffset;
    } else {
      scrollPosY = document.parentElement ? document.parentElement.scrollTop : 0;
    }
  }
  if (scrollPosX === 0) {
    if (window.pageXOffset) {
      scrollPosX = window.pageXOffset;
    } else {
      scrollPosX = document.parentElement ? document.parentElement.scrollLeft : 0;
    }
  }
  return { 'x': scrollPosX, 'y': scrollPosY };
}

function fillRestaurantPulldown() {
  var selectbox = document.getElementById('irestaurantpulldown');
  var selectboxdata = document.getElementById('irestaurantpulldowndata');
  if (selectbox && selectboxdata) {
    var lis = selectboxdata.getElementsByTagName('a');
    var i;
    var resttext = '';
    for (i = 0; i < lis.length; i++) {
      if (document.all) {
        resttext = lis[i].innerText;
      } else {
        if (lis[i].text) {
          resttext = lis[i].textContent;
        } else {
          resttext = lis[i].innerHTML;
        }
      }

      if (resttext.length > 40) {
        resttext = resttext.substr(0, 40) + '..';
      }

      var newoption = new Option(resttext, lis[i].href);
      newoption.className = lis[i].className;
      selectbox.options[i] = newoption;
    }
  }
}

function restaurantpulldownRedirect(selectedindex) {
  var selectbox = document.getElementById('irestaurantpulldown');
  if (selectbox) {
    var redirectvalue = selectbox.options[selectedindex].value;
    if (redirectvalue) {
      window.top.location = redirectvalue;
      return false;
    }
  }
}

function trim(str) {
  var newstr = str;
  var i = 0;
  var thechar = str.charAt(i);
  while ((thechar === ' ' || thechar === '\n' || thechar === '\r' || thechar === '\t') && i < str.length) {
    newstr = str.substr(i + 1);
    i++;
    thechar = str.charAt(i);
  }
  i = newstr.length - 1;
  thechar = newstr.charAt(i);
  while ((thechar === ' ' || thechar === '\n' || thechar === '\r' || thechar === '\t') && i > 0) {
    newstr = newstr.substr(0, i);
    i = newstr.length - 1;
    thechar = newstr.charAt(i);
  }
  return newstr;
}

function getElementStyle(eltid) {
  if (document.layers) {
    return document.layers[eltid];
  } else {
    if (document.getElementById) {
      var temp = document.getElementById(eltid);
      if (temp) {
        return temp.style;
      } else {
        return false;
      }
    } else {
      var temp = document.all[eltid];
      if (temp) {
        return temp.style;
      } else {
        return false;
      }
    }
  }
}

function scrollToElement(eltid) {
  var scrollelt = document.getElementById(eltid);
  if (scrollelt) {
    scrollelt.scrollIntoView(true);
  }
}

function setMinHeights() {
  var basketobj = document.getElementById('ibasket');
  var menucatobj = document.getElementById('imenucategory');

  var pnode;
  if (basketobj) {
    var basketsize = getElementSize(basketobj);
    pnode = basketobj.parentNode;
    if (pnode) pnode.style.minHeight = basketsize.y + 'px';
  }
  if (menucatobj) {
    var menucatsize = getElementSize(menucatobj);
    pnode = menucatobj.parentNode;
    if (pnode) pnode.style.minHeight = menucatsize.y + 'px';
  }
}

function checkPostcodeRadiobutton(radiob) {
  radiob.checked = true;
  checkRadiobutton(radiob, '');
}

function focusSearchField() {
  var elt = document.getElementById('isearchstring');
  if (elt) {
    elt.focus();
  } else {
    elt = document.getElementById('isearchstring1');
    if (elt) {
      elt.focus();
    }
  }
}

function showHideAccountCompany(showhide) {
  var comptr = document.getElementById('iaccountcompanyrow');
  if (comptr) {
    if (!showhide) {
      comptr.style.display = 'none';
    } else {
      try {
        comptr.style.display = 'table-row';
      } catch (e) {
        comptr.style.display = 'block';
      }
    }
  }
}

function displayLoggedInOutText(txt) {
  $('#userPaneltoggle').html(txt);
  $('.CloseBtn', '#userPanel').html(txt);
}

function displayLoggedInOut(inout) {
  var elt;
  if (inout) {
    elt = document.getElementById('imenuoptionloggedincontainer');
    if (elt) elt.className = 'menuoptionloggedincontainer';
    elt = document.getElementById('imenuoptionloggedoutcontainer');
    if (elt) elt.className = 'menuoptionloggedoutcontainer_nodisplay';
  } else {
    elt = document.getElementById('imenuoptionloggedincontainer');
    if (elt) elt.className = 'menuoptionloggedincontainer_nodisplay';
    elt = document.getElementById('imenuoptionloggedoutcontainer');
    if (elt) elt.className = 'menuoptionloggedoutcontainer';
  }
}

function xmlFormSubmitHtml(form_id, destination_id, url) {
  var datastring;

  datastring = $('#' + form_id).serialize();
  if (datastring.length === 0) {
    datastring = 'tp=1';
  } else {
    datastring = datastring + '&tp=2';
  }

  $.ajax({
    type: 'POST',
    url: url,
    data: datastring,
    success: function success(data) {
      var obj = $.parseJSON(data);

      if (obj.type === 'redirect') {
        document.location = obj.value;
        return false;
      } else if (obj.type === 'html') {
        $('.' + destination_id).html(obj.value);
        return false;
      }
    }
  });
}

function xmlRequestMini(page, postvars, destination_id, focus_id, className) {
  var datastring;
  if (postvars) {
    datastring = page + postvars;
  }
  if (typeof className !== 'undefined') {
    $('#' + destination_id).removeClass();
    $('#' + destination_id).addClass(className);
  }
  $.ajax({
    type: 'POST',
    url: page,
    data: datastring,
    // dataType: 'json',
    success: function success(data) {
      var obj = $.parseJSON(data);

      if (obj.type === 'redirect') {
        document.location = obj.value;
        return false;
      } else if (obj.type === 'html') {
        $('.' + destination_id).html(obj.value);
        $('.' + destination_id).css('visibility', 'visible');
        return false;
      }
    }
  });
}

/*
*
* SUBCATEGORY FILTERING
*
*/
$('#ivouchermessage .notificationfeedback').on('click', function () {
  $('.notificationfeedbackwrapper').hide();
});

$(document).mousedown(function (e) {
  var container = $('#userPanel');
  if ($(container).html() !== '') {
    if (!container.is(e.target) && container.has(e.target).length === 0) {
      active_obj = null;
      $(container).empty();
      $(container).removeClass('userPanelWide');
      $(container).css('visibility', 'hidden');
    }
  }
});

function openRestaurantFavorites(e, restId, url, rightpart) {
  var targetEl = void 0;
  var targetClass = void 0;
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;

  if ($('#irestaurant' + restId).parent().hasClass('restaurantlist-grid') && $(document).width() > 640) {
    targetEl = 'popupdiv';
    targetClass = 'popupdiv showRestaurantReviews';
  } else {
    targetEl = 'irestaurantreviews_' + restId;
    targetClass = 'restaurantcompactreviews grid-24';
  }

  xmlRequest(url, 'bid=' + restId, targetEl, false, false, targetClass);
  return false;
}

function openRestaurantDiscount(e, url, restId, rightpart) {
  var targetEl = void 0;
  var targetClass = void 0;
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;

  if ($('#irestaurant' + restId).parent().hasClass('restaurantlist-grid') && $(document).width() > 640) {
    targetEl = 'popupdiv';
    targetClass = 'popupdiv showRestaurantReviews';
  } else {
    targetEl = 'irestaurantreviews_' + restId;
    targetClass = 'restaurantcompactreviews grid-24';
  }
  xmlRequest(url, 'bid=' + restId + '&rightpart=' + rightpart, targetEl, false, false, targetClass);
  return false;
}

function closeCurrentActivePopup(e, id) {
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
  closeActivePopUp(id);
  return false;
}

function preselectFirstEmptyFormField() {
  if ($('#iaddress', '#main').val() === '') {
    $('#iaddress').focus();
  }
  return false;
}

$(document).ready(function () {
  $('.restaurantcompactreviews').click(function (e) {
    e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
  });
});

/**
 *  Close things when clicked on blackout div
 */
$(document).ready(function () {
  $(document).on('click touchend', '.blackout', function (e) {
    if ($('#basketOrb').length && $('#basketOrb').hasClass('opened')) {
      if ($('#basketOrb').hasClass('stopClickPropagation') === false) {
        $('#basketOrb').trigger('basketClose');
      } else {
        return; // don't close blackoutdiv
      }
    }
    closeActivePopUp('popupdiv');
  });
});

/**
 *    NOPC239 DELIVERYPANELTABS
 *
 */
$(document).ready(function () {
  $(document).on('click', '.deliverytabbed li', function (e) {
    $('li', '.deliverytabbed').removeClass('selected');

    if ($(this).attr('id') === 'address') {
      $('.address', '.deliverytabbed').addClass('selected');
      $('.citydistrictpulldowns').removeClass('hidden');
      $('.locationpulldowns').addClass('hidden');
    } else {
      $('.location', '.deliverytabbed').addClass('selected');
      $('.citydistrictpulldowns').addClass('hidden');
      $('.locationpulldowns').removeClass('hidden');
    }
    Cookies.set('deliverytab', $(this).attr('id'), { expires: 365, path: '/', secure: true });
    e.preventDefault();
  });
});

/**
 *  TAKEAWAY PICKUP SWITCHER
 *
 */
$(document).ready(function () {
  $('.pickup, .takeaway', '#ta-switch').click(function () {
    $('.switch').click();
  });
  $('.switch', '#ta-switch').click(function () {
    var switcher = $(this).attr('data-value');
    var takeaway = $('.takeaway');
    var pickup = $('.pickup');
    var goleft = '+=83';
    var marker = '<i class="fa fa-bars fa-rotate-90"></i>';
    var wrap = $(this).parent().innerWidth();

    goleft = wrap / 2 - 8;
    if (switcher === 'takeaway') {
      takeaway.removeClass('inactive');
      pickup.addClass('inactive');
      $(this).html(marker + ' ' + pickup.html());
      $(this).animate({ left: '+=' + goleft }, 30, function () {
        $(this).attr('data-value', 'pickup');
        $(this).parent().find('input').val('pickup');

        $.cookie('takeawaypickup', 'pickup', { expires: 365, path: '/', secure: true });
      });
    } else {
      if ($(this).hasClass('switchpickup')) {
        // reset position before animation; reset right and set left
        $(this).css('right', 'auto').css('left', goleft + 'px').removeClass('switchpickup');
      }
      pickup.removeClass('inactive');
      takeaway.addClass('inactive');
      $(this).html(marker + ' ' + takeaway.html());
      $(this).animate({ left: '-=' + goleft }, 30, function () {
        $(this).attr('data-value', 'takeaway');
        $(this).parent().find('input').val('takeaway');
      });
    }
  });

  if ($('#fixednav').length) {
    $('#fixednav').addClass('loaded');

    window.fixednavheight = $('#fixednav').outerHeight();
    window.fixednav_fits_in_view = $(window).height() - $('div#splash').height() - $('footer').height() > window.fixednavheight;
    window.fixednav_initial_Ypos = $('.fixednavtop').offset().top;

    // fill up content grid column height for at least as high as the nav div
    $('.grid-17').css('min-height', window.fixednavheight + window.fixednav_initial_Ypos - 130 + 'px');
  }
});

function relocatePromovideoPopup() {
  var container = $('.promovideo');
  var ratio = 1.77777;
  var windowwidth = $(window).width();
  var windowheight = $(window).height();

  if ($(container).isVisible()) {
    var videowidth = $(window).width() - 50;
    var videoheight = videowidth / ratio;

    if ($(container).height() < videoheight) {
      videoheight = $(container).height();
      videowidth = $(container).height() * ratio;
    }
    $('.iframe', container).css('width', videowidth + 'px').css('height', videoheight + 'px');

    // make popup closeable with esc key
    $('html,body').on('keydown', function (e) {
      if (!e.keyCode || e.keyCode === 27) {
        $('.closevideoplayer').click();
      }
    });
  }
}

$('html,body').on('touchstart scroll mousedown DOMMouseScroll mousewheel', function (e) {
  if (e.which > 0 || e.type === 'mousedown' || e.type === 'mousewheel' || e.type === 'touchstart') {
    $('html,body').stop();
  }
});

window.onresize = function (e) {
  relocatePopup(false);

  if ($('.promovideo').length > 0) {
    relocatePromovideoPopup();
  }

  if ($('#fixednav').length && $('#fixednav').hasClass('loaded')) {
    window.fixednavheight = $('#fixednav').outerHeight();
    window.fixednav_fits_in_view = $(window).height() - $('div#splash').height() - $('footer').height() > window.fixednavheight;
    window.fixednav_initial_Ypos = $('.fixednavtop').offset().top;

    if ($('#fixednav').is(':visible')) {
      repositionNavDiv(e);
    }
  }
};

document.onscroll = function (e) {
  relocatePopup(true);

  // determine scroll direction
  st = window.pageYOffset;
  if (window.lastScrollTop === undefined || st > window.lastScrollTop) {
    window.scrollDirection = 'down';
  } else {
    window.scrollDirection = 'up';
  }
  window.lastScrollTop = st;

  if ($('#fixednav').length && $('#fixednav').hasClass('loaded')) {
    if ($('#fixednav').is(':visible')) {
      repositionNavDiv(e);
    }
  }
};

$(window).on('switchedCompact, switchedJumboFromCompact', function () {
  if ($('#fixednav').length && $('#fixednav').hasClass('loaded')) {
    window.fixednav_fits_in_view = $(window).height() - $('div#splash').height() - $('footer').height() > window.fixednavheight;
    window.fixednav_initial_Ypos = $('.fixednavtop').offset().top;
  }
});

function repositionNavDiv(parentevent) {
  if ($('body').hasClass('step2')) {
    return tempFilterDiv();
  }

  state = '';

  var fixednav = $('#fixednav');

  topMargin = 10;
  bottomMargin = 60;

  viewport_top_Ypos = $(window).scrollTop();
  header_bottom_Ypos = $('div#splash').height();
  if (viewport_top_Ypos < header_bottom_Ypos) viewport_top_Ypos = header_bottom_Ypos;

  viewport_bottom_Ypos = Math.abs($(window).scrollTop() + $(window).height()) - bottomMargin;
  footer_top_Ypos = $('footer').offset().top - bottomMargin;
  footerVisible = footer_top_Ypos < viewport_bottom_Ypos;
  if (footerVisible) viewport_bottom_Ypos = footer_top_Ypos;

  // find a frame of reference for calculation of width
  if ($('body').hasClass('step2')) {
    column = $('#filter-panel');
  } else {
    column = fixednav.parents('[class^=grid-]').first();
  }
  fixednav.outerWidth(column.width() + 'px');

  if (window.fixednav_fits_in_view) {
    if (viewport_top_Ypos + 110 > window.fixednav_initial_Ypos) {
      newtop = $(window).scrollTop() - topMargin;
      fixednav.css({ 'position': 'absolute', 'top': newtop + 'px' });
      state = 'stickToTopViewport 1';
    } else {
      fixednav.css({ 'position': '', 'top': '' });
      state = 'initial fits';
    }
  }

  if (!window.fixednav_fits_in_view) {
    if (window.scrollDirection === 'down') {
      if (fixednav.offset().top + window.fixednavheight - topMargin <= viewport_bottom_Ypos) {
        newtop = viewport_bottom_Ypos - window.fixednavheight;
        if ($('body').hasClass('step3')) {
          newtop -= $('#splash').height() + topMargin;
        }
        fixednav.css({ 'position': 'absolute', 'top': newtop + 'px' });
        state = 'stickToBottomViewport';
      } else {
        state = 'transitioning 1';
      }
    }

    if (window.scrollDirection === 'up') {
      if ($('body').hasClass('deliveryareapanelbig')) {
        // deliverypanel expanded
        if (viewport_top_Ypos + bottomMargin + topMargin < window.fixednav_initial_Ypos) {
          fixednav.css({ 'position': '', 'top': '' });
          state = 'initial';
        } else {
          if (fixednav.offset().top >= $(window).scrollTop()) {
            newtop = $(window).scrollTop() - $('#splash').height() + topMargin;
            fixednav.css({ 'position': 'absolute', 'top': newtop + 'px' });
            state = 'stickToTopViewport 2';
          } else {
            state = 'transitioning 2';
          }
        }
      } else {
        if (viewport_top_Ypos + bottomMargin + topMargin < window.fixednav_initial_Ypos) {
          fixednav.css({ 'position': '', 'top': '' });
          state = 'initial';
        } else {
          if ($('body').hasClass('step3')) {
            if (fixednav.offset().top - bottomMargin >= viewport_top_Ypos && !footerVisible) {
              newtop = $(window).scrollTop() - topMargin;
              fixednav.css({ 'position': 'absolute', 'top': newtop + 'px' });
              state = 'stickToTopViewport 3';
            } else {
              // correct nav positioning above footer
              state = 'transitioning 3';
            }
          } else {
            if (fixednav.offset().top >= viewport_top_Ypos) {
              newtop = $(window).scrollTop() + $('#splash').height() + topMargin;
              fixednav.css({ 'position': 'absolute', 'top': newtop + 'px' });
              state = 'stickToTopViewport 4';
            } else {
              state = 'transitioning 4';
            }
          }
        }
      }
    }
  }

  if (parentevent.type === 'resize') fixClippedFooter(bottomMargin);

  test = {
    'event': parentevent.type,
    'scrolldirection': window.scrollDirection,
    'newtop': fixednav.css('top'),
    'state': state
  };
}

function fixClippedFooter(bottomMargin) {
  delta = $('#fixednav').offset().top + $('#fixednav').outerHeight() - $('footer').offset().top;
  if (delta > 0) {
    newtop = $('#fixednav').offset().top - (delta + 130) - bottomMargin;
    $('#fixednav').css('top', newtop + 'px');
    state += ' corrected';
  }
}

function tempFilterDiv() {
  if (!$('#main').hasClass('sc-filter-hover')) {
    filterpanel = $('#filter-panel');
    $('#fixednav').outerWidth(filterpanel.width() + 'px');

    if ($(window).scrollTop() > $('.fixednavtop').offset().top - $('#splash').height()) {
      if ($(window).scrollTop() + $('#fixednav').height() > filterpanel.height()) {
        $('#fixednav').css('position', 'absolute');
        var newtop = $('footer').offset().top - $('#fixednav').height() - 25;
        $('#fixednav').css('top', newtop + 'px');
      } else {
        $('#fixednav').css('position', 'fixed');
        $('#fixednav').css('top', $('#splash').height() + 14 + 'px');
      }
    } else if ($(window).scrollTop() <= $('.fixednavtop').offset().top) {
      $('#fixednav').attr('style', ''); // remove all calculated styles
    }
  } else {
    $('#fixednav').attr('style', ''); // remove all calculated styles
  }
}

/* buttons.js */
var imageselectboxactive = false;
var displayingbox = false;

function documentEvent(e) {
  if (e.type === 'click') {
    if (displayingbox) {
      imageselectboxactive = true;
      displayingbox = false;
      e.returnValue = false;
      return false;
    } else {
      if (imageselectboxactive) {
        hideAllImageSelectBoxes();
        imageselectboxactive = false;
        e.returnValue = false;
        return false;
      }
    }
  }
  if (window.routeEvent) window.routeEvent(e);
  // else e.returnValue = true;

  if (e) return e.returnValue;
}

if (document.attachEvent) {
  // IE
  document.attachEvent('onclick', documentEvent);
} else if (window.addEventListener) {
  // Opera/Safari/etc
  window.addEventListener('click', documentEvent, false);
} else if (document.addEventListener) {
  // Opera/Safari/etc
  document.addEventListener('click', documentEvent, false);
} else {
  // MOZILLA
  document.captureEvents(Event.CLICK);
  document.onclick = documentEvent;
}

function displayImageSelectBox(uleltid) {
  if (!imageselectboxactive) {
    displayingbox = true;
    var ulelt = document.getElementById(uleltid);
    var lielts;
    if (ulelt) {
      if (ulelt.className === 'imagepulldown') ulelt.className = 'imagepulldown_show';
    }
    // show marker
    $('#iimagepulldownmarker').addClass('imagepulldownmarker_show');
  } else {
    hideAllImageSelectBoxes();
  }
  return false;
}

function hideAllImageSelectBoxes() {
  if (imageselectboxactive) {
    var ulelts = document.getElementsByTagName('ul');
    if (ulelts) {
      for (i = 0; i < ulelts.length; i++) {
        if (ulelts[i].className === 'imagepulldown_show') ulelts[i].className = 'imagepulldown';
        if (ulelts[i].className === 'imagepulldownmarker') ulelts[i].className = 'imagepulldownmarker_show';
      }
    }
    imageselectboxactive = false;
    // hide marker
    $('#iimagepulldownmarker').removeClass('imagepulldownmarker_show');
  }
}

function changeValueImageSelectBox(imageselectboxid, ivalue) {
  var ulelt = document.getElementById('i' + imageselectboxid + 'data');
  var inputelt = document.getElementById('i' + imageselectboxid);
  var selectdiv = document.getElementById('i' + imageselectboxid + 'selected');
  var lielts, lielt, hrefelt;
  if (ulelt) {
    lielts = ulelt.getElementsByTagName('li');
    if (lielts) {
      lielt = lielts[ivalue];
      if (lielt) {
        hrefelt = lielt.childNodes[0];
        if (hrefelt && hrefelt.href) {
          inputelt.value = hrefelt.href;
        }
        if (selectdiv) {
          selectdiv.childNodes[1].innerHTML = hrefelt.innerHTML;
        }
      }
    }
  }
}

/** Add one to the values currently in the DOM elements with
 *    the given (comma separated) targetids up to a given maximum (or 99)
 */
function pmButtonAddOne(targetids, maximum) {
  if (maximum === undefined) maximum = 99;

  // function supports multiple ids passed through targetids parameter
  var target_id_array = targetids.split(',');
  if (target_id_array.length > 1) {
    // call this function again for each single element in targetids
    for (i = 0; i < target_id_array.length; i++) {
      pmButtonAddOne(target_id_array[i], maximum);
    }
  } else {
    // there is only one element in targetids
    var targetid = target_id_array[0];

    target_element = document.getElementById('i' + targetid);
    if (target_element != null) {
      if (target_element.tagName === 'INPUT') {
        cur_value = parseInt(target_element.value);
        if (cur_value < maximum) {
          target_element.value = cur_value + 1;
        } else {
          target_element.value = maximum;
        }
      } else {
        cur_value = parseInt(target_element.innerHTML);
        if (cur_value < maximum) {
          target_element.innerHTML = cur_value + 1;
        } else {
          target_element.innerHTML = maximum;
        }
      }
    }
  }
}

/** Subtract one off the values currently in the DOM elements with
 *    the given (comma separated) targetids down to a given minimum (or 1)
 */
function pmButtonSubtractOne(targetids, minimum) {
  if (minimum === undefined) minimum = 0;

  // function supports multiple ids passed through targetids parameter
  var target_id_array = targetids.split(',');
  if (target_id_array.length > 1) {
    // call this function again for each single element in targetids
    for (i = 0; i < target_id_array.length; i++) {
      pmButtonSubtractOne(target_id_array[i], minimum);
    }
  } else {
    // there is only one element in targetids
    var targetid = target_id_array[0];

    target_element = document.getElementById('i' + targetid);
    if (target_element != null) {
      if (target_element.tagName === 'INPUT') {
        cur_value = parseInt(target_element.value);
        if (cur_value > minimum) {
          target_element.value = cur_value - 1;
        } else {
          target_element.value = minimum;
        }
      } else {
        cur_value = parseInt(target_element.innerHTML);
        if (cur_value > minimum) {
          target_element.innerHTML = cur_value - 1;
        } else {
          target_element.innerHTML = minimum;
        }
      }
    }
  }
}

function is_touch_device() {
  return 'ontouchstart' in window || // works on most browsers
  navigator.maxTouchPoints; // works on IE10/11 and Surface
}

if (is_touch_device()) {
  $('html').addClass('touch');
} else {
  $('html').addClass('no-touch');
}

/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per `wait` duration;
 * but if you'd like to disable the execution on the leading edge, pass
 * `{leading: false}`. To disable execution on the trailing edge, ditto.
 */
function throttle(func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};
  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
  var timeout = void 0;
  return function () {
    var context = this;
    var args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
/* global $, LazyLoad */

$(function () {
  initLazyLoad();
});

var lazyLoadConfig = {
  elements_selector: '.menucardproductimg, .meal__product-image, .restlogo, .lazy',
  load_delay: 0,
  threshold: 100,
  class_loaded: 'lazy-loaded'
};

function initLazyLoad() {
  if (window.lazyLoadInstance) {
    window.lazyLoadInstance.update();
  } else {
    window.lazyLoadInstance = new LazyLoad(lazyLoadConfig);
  }
}
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global app, site, Helper, userpanel */
var StampCards = function () {
  var activeListClass = 'list-active';
  var collapseClass = 'collapse';
  var panelTitleClassSelector = '.panel-title';
  var activeClass = 'active';
  var userPanelSelector = '#userpanel';
  var currentActiveTab = null;

  function howActive() {
    activateTab(getHowLink(), getHowContainer());
  }

  function termsActive() {
    activateTab(getTermsLink(), getTermsContainer());
  }

  function aboutActive() {
    activateTab(getStampLink(), getStampContainer());
  }

  function activateTab(link, container) {
    hideAll();

    link.classList.add(activeListClass);
    container.style.display = '';

    var modalElement = getStampCardContainer();
    app.helpers.keepFocusWithinModal({ modalElement: modalElement });
  }

  function hideAll() {
    getHowLink().classList.remove(activeListClass);
    getHowContainer().style.display = 'none';
    getTermsLink().classList.remove(activeListClass);
    getTermsContainer().style.display = 'none';
    getStampLink().classList.remove(activeListClass);
    getStampContainer().style.display = 'none';
  }

  function toggleDisplay(selector, activeElement) {
    var element = document.querySelector(selector);
    if (element) {
      if (element.classList.contains(collapseClass)) {
        element.classList.remove(collapseClass);
        activeElement.closest(panelTitleClassSelector).classList.remove(activeClass);
      } else {
        element.classList.add(collapseClass);
        activeElement.closest(panelTitleClassSelector).classList.add(activeClass);
      }
    }
  }

  function getStampCardContainer() {
    return document.querySelector('.stampcard-container');
  }

  function getHowLink() {
    return document.querySelector('.js-how');
  }

  function getHowContainer() {
    return document.querySelector('.js-how-container');
  }

  function getTermsLink() {
    return document.querySelector('.js-terms');
  }

  function getTermsContainer() {
    return document.querySelector('.js-terms-container');
  }

  function getStampLink() {
    return document.querySelector('.js-stamp');
  }

  function getStampContainer() {
    return document.querySelector('.js-stampcollection-container');
  }

  var addTrackingEventStampcardsModalCreateAccount = function addTrackingEventStampcardsModalCreateAccount() {
    var link = document.querySelector(window.app.enums.SELECTOR_CLASS_NAMES.CUSTOMER_PANEL.STAMPCARDS_CREATE_ACCOUNT);
    if (link) {
      link.addEventListener('click', function () {
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_CREATE_ACCOUNT,
          eventData: {
            linkType: window.app.enums.TRACKING_EVENT_NAMES.LINK_TYPE.STAMPCARDS_MODAL
          }
        });
      });
    }
  };

  function populateSkeletons(amount, container, item) {
    if (isNaN(amount) || !(container instanceof Element || container instanceof HTMLDocument) || !(item instanceof Element || item instanceof HTMLDocument)) {
      console.warn('Populating container failed!');
      return;
    }

    container.innerHTML = '';

    for (var i = 0; i < amount; i++) {
      container.appendChild(item.cloneNode(true));
    }
  }

  function getUserPanel() {
    return document.querySelector(userPanelSelector);
  }

  function addVoucherCopyToStampCardItem(card) {
    card.querySelectorAll('[data-copy-on-click]').forEach(function ($voucherButton) {
      $voucherButton.addEventListener('click', function () {
        var voucherCode = $voucherButton.dataset.copyOnClick;
        console.log('[StampCard] copy value "' + voucherCode + '" to clipboard');
        window.app.helpers.copyToClipboard(voucherCode, $voucherButton);
        document.querySelectorAll('.copied[data-copy-on-click]').forEach(function (element) {
          element.classList.remove('copied');
          element.innerHTML = element.dataset.formattedAmount;
        });
        $voucherButton.classList.add('copied');
        $voucherButton.innerHTML = voucherCode;
        var message = ('' + site.stampCardTranslations.voucher_has_been_copied).replace('[code]', voucherCode);
        var toast = new window.app.components.Toast({
          message: message,
          iconClass: 'icon-check',
          fadeTimeout: 5000
        });
        toast.show();
      });
    });
  }

  function addTrackingToStampCardItem(card) {
    if (_typeof(window.dataLayer) === 'object') {
      var $orderLink = card.querySelector('.js-track-restaurant-order-now');
      if ($orderLink) {
        $orderLink.addEventListener('click', function () {
          window.dataLayer.push({ event: 'hasClickedOrderNowSC' });
          console.log('[StampCard] track hasClickedOrderNowSC');
        });
      }

      card.querySelectorAll('.js-track-collected-voucher').forEach(function ($voucherButton) {
        $voucherButton.addEventListener('click', function () {
          window.dataLayer.push({ event: 'hasCollectedVoucherSC' });
          console.log('[StampCard] track hasCollectedVoucherSC');
        });
      });
    }
  }

  function initTrackingOnUserPanel() {
    addTrackingEventStampcardsModalCreateAccount();
    if (_typeof(window.dataLayer) === 'object') {
      var userPanel = getUserPanel();
      var stampCardLink = userPanel.querySelector('.js-stampcards-link a');
      if (stampCardLink) {
        stampCardLink.addEventListener('click', function () {
          window.dataLayer.push({ event: 'hasVisitedStampCards' });
          console.log('[StampCard] track hasVisitedStampCards');
        });
      }

      var giftCardsLink = userPanel.querySelector('.js-giftcards-link a');
      if (giftCardsLink) {
        giftCardsLink.addEventListener('click', function () {
          window.dataLayer.push({
            event: 'hasClickedGiftCards',
            tms_data: { linkType: 'burger modal' }
          });
          console.log('[GiftCards] track hasClickedGiftCards');
        });
      }

      var stampCardOptinLink = userPanel.querySelector('.js-track-newsletter-optin');
      if (stampCardOptinLink) {
        stampCardOptinLink.addEventListener('click', function () {
          window.dataLayer.push({ event: 'hasOptedInNewsletterSC' });
          console.log('[StampCard] track hasOptedInNewsletterSC');
        });
      }

      [{ selector: '.js-track-your-stampcards-tab', eventName: 'hasClickedYourStampcardsTab' }, { selector: '.js-track-how-does-it-work-tab', eventName: 'hasClickedHowDoesItWorkTab' }, { selector: '.js-track-terms-tab', eventName: 'hasClickedTermsTab' }].forEach(function ($item) {
        var $tab = userPanel.querySelector($item.selector);
        if ($tab) {
          if ($tab.classList.contains(activeListClass)) {
            currentActiveTab = $tab; // needed because the event changing the tabs is fired before this one
          }
          $tab.addEventListener('click', function () {
            if (currentActiveTab !== $tab) {
              currentActiveTab = $tab;
              window.dataLayer.push({ event: $item.eventName });
              console.log('[StampCard] track ' + $item.eventName);
            }
          });
        }
      });
    }
  }

  function addErrorMessage(errorContainer, errorCode) {
    var container = document.querySelector('.js-skeleton__stampcards');

    var errorMessage = 'Ooops!';
    if (container.dataset && container.dataset.errorMessage) {
      errorMessage = container.dataset.errorMessage;
    }

    var errorMessageElement = document.createElement('p');
    errorMessageElement.className = 'stampcard__error';
    errorMessageElement.innerHTML = '\n      <span class="stampcard__error-message">' + errorMessage + '</span>\n      <span class="stampcard__error-code">(' + errorCode + ')<span>\n    ';
    errorContainer.parentElement.replaceChild(errorMessageElement, errorContainer);
  }

  function init() {
    var userPanel = getUserPanel();

    var stampCardsContainer = userPanel.querySelector('.js-stampcards-tab-container');

    if (stampCardsContainer !== null) {
      var stampCardsSkeletonContainer = userPanel.querySelector('.js-skeleton__stampcards');
      var stampCardsSkeleton = userPanel.querySelector('.js-skeleton__stampcard_display');

      var translationsElement = document.querySelector('.js-stampcard_translations');
      if (translationsElement !== null) {
        site.stampCardTranslations = JSON.parse(translationsElement.innerHTML);
      }
      var request = new XMLHttpRequest();
      request.open('GET', site.aPath + 'xHttp/' + site.language + '/stampcard', true);
      request.onload = function () {
        if (request.status >= 200 && request.status < 400) {
          var response = JSON.parse(request.responseText);
          if (response.hasOwnProperty('data') && response.data.hasOwnProperty('stampcards')) {
            var stampCards = removeOfflineRestaurants(response.data.stampcards);

            if (stampCards.length === 0) {
              stampCardsSkeletonContainer.innerHTML = '<p>' + site.stampCardTranslations.stampcards_list_empty + '</p>';
            } else {
              var comparisonDate = new Date();
              // apply filtering
              stampCards = removeVoucherThatExpired(comparisonDate, stampCards);

              stampCards = convertStampcards(stampCards);

              populateSkeletons(stampCards.length, stampCardsSkeletonContainer, stampCardsSkeleton);
              // Sort vouchers
              stampCards = sortVoucherByExpirationDate(stampCards);

              // Sort stampcards
              stampCards.sort(sortStampcards);

              stampCards.forEach(function (stampCardData) {
                var card = new window.app.components.StampcardComponent(stampCardData).render();
                stampCardsContainer.appendChild(card.stampCardElement);
                addTrackingToStampCardItem(card.stampCardElement);
                addVoucherCopyToStampCardItem(card.stampCardElement);
                stampCardsSkeletonContainer.removeChild(stampCardsSkeletonContainer.lastChild);
              });
              // Fire all at once
            }
          } else {
            console.log('[StampCard] no stampcards key found');
            addErrorMessage(stampCardsSkeletonContainer, 'SCE:001');
          }
        } else {
          console.log('[StampCard] There was a server error of some sort');
          addErrorMessage(stampCardsSkeletonContainer, 'SCE:002');
        }
      };

      request.onerror = function () {
        console.log('[StampCard] There was a connection error of some sort');
        addErrorMessage(stampCardsSkeletonContainer, 'SCE:003');
      };

      request.send();
    }
  }

  function removeOfflineRestaurants(stampCardData) {
    return stampCardData.filter(function (stampCard) {
      return stampCard.hasOwnProperty('restaurant') && _typeof(stampCard.restaurant) === 'object' && stampCard.restaurant.hasOwnProperty('isOnline') && stampCard.restaurant.isOnline === true;
    });
  }

  function removeVoucherThatExpired(comparisonDate, stampCardData) {
    return stampCardData.map(function (stampCard) {
      return _extends({}, stampCard, {
        vouchers: stampCard.vouchers.filter(function (voucher) {
          return voucher.hasOwnProperty('validUntil') && voucher.validUntil > comparisonDate.getTime();
        })
      });
    });
  }

  function convertStampcards(stampCardData) {
    var split = stampCardData.map(function (stampCard) {
      var stampCardList = [];

      if (stampCard.vouchers.length === 1 && stampCard.stamps === 0) {
        stampCard.stamps = 5;
      }
      // if the stampcard has between 1 and 5 stamps, split it into 2 cards
      if (stampCard.stamps > 0 && stampCard.stamps < 5 && stampCard.vouchers.length > 0) {
        var stampsCopy = JSON.parse(JSON.stringify(stampCard));
        stampsCopy.vouchers = []; // empty the vouchers
        stampsCopy.isCopyFromStamps = true;
        stampCard.stamps = 5;
        stampCardList.push(stampsCopy);
      }
      // if the stampcard has more than 1 voucher split per voucher
      if (stampCard.vouchers.length > 1) {
        stampCard.stamps = 5;
        var otherVouchers = stampCard.vouchers.slice(1);
        stampCard.vouchers = stampCard.vouchers.slice(0, 1);
        otherVouchers.forEach(function (voucher) {
          var voucherCopy = JSON.parse(JSON.stringify(stampCard));
          voucherCopy.vouchers = [voucher];
          voucherCopy.isCopyFromVoucher = true;
          stampCardList.push(voucherCopy);
        });
      }

      stampCardList.push(stampCard);

      return stampCardList;
    });
    return split.flat(1);
  }

  function sortVoucherByExpirationDate(stampCardData) {
    return stampCardData.map(function (stampCard) {
      return _extends({}, stampCard, {
        vouchers: stampCard.vouchers.sort(function (firstVoucher, secondVoucher) {
          if (!firstVoucher.hasOwnProperty('validUntil') || !secondVoucher.hasOwnProperty('validUntil') || firstVoucher.validUntil === secondVoucher.validUntil) {
            return 0;
          }
          return firstVoucher.validUntil > secondVoucher.validUntil ? 1 : -1;
        })
      });
    });
  }

  function sortStampcards(firstStampCard, secondStampCard) {
    var firstVouchers = firstStampCard.vouchers.slice(0, 1);
    var secondVouchers = secondStampCard.vouchers.slice(0, 1);
    // Sorting by amount of vouchers (only 1 at the moment)
    // If the first stampcard has vouchers, let it go first. No check on the amount of vouchers
    // The vouchers are already sorted and reduced before rendering
    // (removeVoucherThatExpired, sortVoucherByExpirationDate in the stampcard component)
    if (firstVouchers.length !== secondVouchers.length) {
      return firstVouchers.length > 0 ? -1 : 1;
    }

    // Sorting by voucher expiration date, if found
    if (firstVouchers.length > 0 && secondVouchers.length > 0) {
      var _firstVouchers = _slicedToArray(firstVouchers, 1),
          firstVoucher = _firstVouchers[0];

      var _secondVouchers = _slicedToArray(secondVouchers, 1),
          secondVoucher = _secondVouchers[0];
      // Only apply if both have a validUntil property


      if (firstVoucher.hasOwnProperty('validUntil') && secondVoucher.hasOwnProperty('validUntil')) {
        return firstVoucher.validUntil < secondVoucher.validUntil ? -1 : 1;
      }
    }

    // Sorting by amount of stamps
    if (firstStampCard.stamps !== secondStampCard.stamps) {
      return firstStampCard.stamps > secondStampCard.stamps ? -1 : 1;
    }

    // Sorting by lastOrder, if there is one (Should be)
    if (firstStampCard.hasOwnProperty('lastOrder') && secondStampCard.hasOwnProperty('lastOrder') && firstStampCard.lastOrder !== secondStampCard.lastOrder) {
      if (typeof firstStampCard.lastOrder === 'undefined' || firstStampCard.lastOrder === null || !firstStampCard.lastOrder.hasOwnProperty('date')) {
        return -1;
      } else if (typeof secondStampCard.lastOrder === 'undefined' || secondStampCard.lastOrder === null || !secondStampCard.lastOrder.hasOwnProperty('date')) {
        return 1;
      } else {
        var firstDate = new Date(firstStampCard.lastOrder.date);
        var secondDate = new Date(secondStampCard.lastOrder.date);
        return firstDate.getTime() > secondDate.getTime() ? -1 : 1;
      }
    }

    return 0;
  }

  return {
    aboutActive: aboutActive,
    howActive: howActive,
    termsActive: termsActive,
    toggleDisplay: toggleDisplay,
    initTrackingOnUserPanel: initTrackingOnUserPanel,
    init: init
  };
}();

Helper.ready(function () {
  document.querySelectorAll('.js-open-stampcards').forEach(function ($link) {
    // link from the footer
    $link.addEventListener('click', function () {
      userpanel.Run('stampcards');
      window.dataLayer.push({ event: 'hasVisitedStampCards' });
      console.log('[StampCard] track hasVisitedStampCards');
    });
  });
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/* global
  $,
  app,
  Cookies,
  fomatQuerySplitPostcode,
  format_price,
  formatQueryPostcode,
  Helper,
  initStrengthBar,
  jQuery,
  PrefillAddress,
  resetView,
  SaveAddressSelection,
  setModal,
  site,
  StampCards,
  Takeaway,
  TakeawayPay,
  toggleMap,
  xmlFormSubmit,
  xmlRequest,
  xmlRequest2,
*/

function redirectIfCaptcha(data, item) {
  item = item || 'user-panel';
  if (typeof data === 'string' && data.indexOf('Incapsula incident ID') > -1) {
    var url = encodeURIComponent('' + document.location.pathname + document.location.search + '#' + item);
    document.location = site.local + 'captcha?source=' + url;
    return true;
  }
  return false;
}

var checkLoginLogout = function checkLoginLogout() {
  window.app.services.optInService.setOptInStatusFromLogin();

  if ($('body').hasClass('step4')) {
    SaveAddressSelection();
    var $takeawayPayContainer = document.querySelector('.js-takeaway-pay');
    if ($takeawayPayContainer) {
      $takeawayPayContainer.parentNode.removeChild($takeawayPayContainer);
    }
    xmlRequest(site.local + 'xHttp/OrderDetails/showCheckoutNaw.php', false, 'icheckoutnaw', undefined, undefined, undefined, PrefillAddress);
    if (app.services.user.isLogged()) {
      window.RenderTakeawayPay();
    } else {
      window.basket.resetTakeawayPay();
      window.basket.resetTakeawayPayInitialized();
      window.basket.calculateTotalPrice();
      window.basket.saveBasket(); // So the basket local storage is the same
      window.basket.updateUI();
    }

    xmlRequest2(site.local + 'xHttp/OrderDetails/showPaymentDetails.php', false, 'ipaymentdetails');
  }
};

/**
 * Redirect to the fullscreen Captcha page if the given data is a Incapsula response
 *
 * @param {string} data
 * @param {string} item
 */

(function ($) {
  $.userPanel = function (el, options) {
    var KEYCODE_ESC = 27;
    var uP = this;
    var body = 'body';
    var userpanel = '#userpanel';
    var userpanelWrapper = '#userpanel-wrapper';

    var defaults = {
      userpanelvisible: false, // no medium panel allowed
      fullscreen: false, // is map visible
      myaccount: false
    };
    var scrollPosition = 0;

    var $document = $(document);

    uP.settings = $.extend({}, defaults, options);

    uP.init = function () {
      uP.settings.fullscreen = window.app.services.mediaQueryService.respondTo('<tablet-landscape');
      if (uP.settings.fullscreen) {
        $(body).addClass('fullscreen');
        $(body).find('.content').addClass('collapse');
        $('html').addClass('fullscreen');
      }

      $(userpanel).addClass('show');
      $(userpanel).addClass('no-scroll');
      uP.settings.userpanelvisible = true;
      toggleMap(false);
      $('.userpanel-list-link').hide();
    };

    uP.Run = function (item) {
      uP.settings.fullscreen = window.app.services.mediaQueryService.respondTo('<tablet-landscape');
      if (uP.settings.userpanelvisible === false) {
        uP.Show(item);
      } else {
        uP.Hide();
      }
    };

    uP.Show = function (item) {
      $.ajax({
        type: 'POST',
        url: site.local + 'xHttp/CustomerPanel.php',
        data: {}
      }).done(function (msg) {
        redirectIfCaptcha(msg, item);

        if (uP.settings.fullscreen) {
          $(body).addClass('fullscreen');
          $(body).find('.content').addClass('collapse');
          $('html').addClass('fullscreen');
        }

        $(userpanel).html(msg);

        if (uP.settings.myaccount === true) {
          $(userpanel).addClass('userpanel-myaccount show');
        } else {
          $(userpanel).addClass('show');
          $(userpanel).addClass('no-scroll');
        }
        uP.settings.userpanelvisible = true;
        toggleMap(false);
        setModal($(userpanel));
        if (item && item !== '') {
          $('.userpanel-list-link').hide();
          uP.OpenMenuItem(item);
        } else {
          uP.updateLoyaltyPoints();
          window.app.components.updateCustomerPanelPoints();
          uP.updateTakeawayPayAmount();
        }

        StampCards.initTrackingOnUserPanel();
        TakeawayPay.initClickOnUserPanel();

        addTrackingForCourier();

        favoritesModal.initTrackingFavoritesModal();

        orderHistoryModal.initTrackingOrderHistoryModal();

        document.body.classList.add('stop-scroll');
      });
    };

    uP.addTrackingBrowseRestaurantBtn = function (modal) {
      var browseRestaurantButton = document.querySelector('.js-browse-restaurant-btn');
      if (browseRestaurantButton && Helper.isTrackingAvailable()) {
        browseRestaurantButton.addEventListener('click', function () {
          if (modal === favoritesModal) {
            window.dataLayer.push({
              event: 'hasClickedBrowseRestaurantsInFavourites'
            });
          } else if (modal === orderHistoryModal) {
            window.dataLayer.push({
              event: 'hasClickedBrowseRestaurantsInOrderHistory'
            });
          }
        });
      }
    };

    uP.updateLoyaltyPoints = function () {
      var $bonusPoints = $('.loyaltyPointsMenuItem');
      var loyaltyPointsMenuTextAmount = $('#loyaltyPointsMenuText > .amount');
      var loyaltyPointsMenuTextSuffix = ' ' + loyaltyPointsMenuTextAmount.data('suffix');

      if ($bonusPoints.length > 0 && $bonusPoints.hasClass('fetchPoints')) {
        window.app.services.loyaltyShop.getCurrentUserBonusPoints().then(function (data) {
          if (data.hasBonusPoints === true) {
            if (data.amount) {
              loyaltyPointsMenuTextAmount.fadeIn().html(data.amount + loyaltyPointsMenuTextSuffix);
            }
          } else {
            $('#loyaltyPointsMenuText').hide();
          }
        });
      }
    };

    uP.updateTakeawayPayAmount = function () {
      var userPanelContainer = document.getElementById('userpanel-wrapper');
      if (userPanelContainer) {
        var takeawayPayAmountContainer = userPanelContainer.querySelector('.js-takeaway-pay-menu-amount');
        if (takeawayPayAmountContainer) {
          // It seems the customer is logged in, fire the request
          window.fetch(site.aPath + 'xHttp/' + site.language + '/takeaway-pay-menu', {
            headers: {
              'Takeaway-Accept-Language': site.language
            },
            credentials: 'same-origin'
          }).then(function (response) {
            return response.json();
          }).then(function (json) {
            if (json.allowed === true && json.hasOwnProperty('allowances') && json.allowances.length > 0 && json.hasOwnProperty('currency')) {
              var total = json.allowances.reduce(function (current, item) {
                return current + (item.hasOwnProperty('credit') ? item.credit : 0);
              }, 0);
              takeawayPayAmountContainer.innerHTML = format_price(total, json.currency);
            }
          }).catch(function (error) {
            console.error(error);
          });
        }
      }
    };

    uP.Hide = function () {
      var $body = $(body);
      if ($body.hasClass('myaccountpages')) {
        window.location.reload();
        return;
      }
      $(userpanel).removeClass('show').removeAttr('style');
      $body.removeClass('fullscreen');
      $body.find('.content').removeClass('collapse');
      $('html').removeClass('fullscreen');
      document.body.classList.remove('stop-scroll');
      uP.settings.userpanelvisible = false;
    };

    var initRegisterForm = function initRegisterForm() {
      var form = document.querySelector(window.app.enums.SELECTOR_CLASS_NAMES.CUSTOMER_PANEL.REGISTER_FORM);
      var handleOnSubmit = function handleOnSubmit(event) {
        event.preventDefault();
        xmlFormSubmit('iaccountsignupform', 'userpanel-wrapper', site.local + 'xHttp/CustomerPanel.php', window, window, undefined, undefined, undefined, function () {
          // after post callback
          initRegisterForm();
          addTrackingEventOnRegisterFormSubmit();
        }, function () {
          window.app.services.addFacebookClickAndLoadEvent();
          window.app.services.addGoogleLoginClickAndLoadEvent();
        });
      };
      if (form) {
        form.addEventListener('submit', handleOnSubmit);
      }
    };

    var addTrackingForCourier = function addTrackingForCourier() {
      var courierLink = document.querySelector('.js-become-courier');
      if (courierLink) {
        courierLink.addEventListener('click', function () {
          window.app.services.tracking.send({
            eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_BECOME_COURIER,
            eventData: {
              linkType: 'burger modal'
            }
          });
        });
      }
    };

    var addTrackingEventOnRegisterFormSubmit = function addTrackingEventOnRegisterFormSubmit() {
      var enums = window.app.enums;
      var registerSuccess = document.querySelector(enums.SELECTOR_CLASS_NAMES.CUSTOMER_PANEL.REGISTER_SUCCESS_MESSAGE);
      var registerFail = document.querySelector(enums.SELECTOR_CLASS_NAMES.CUSTOMER_PANEL.REGISTER_FAIL_MESSAGE);
      var payload = {};
      console.log('registerSuccess:' + !!registerSuccess);
      console.log('registerFail:' + !!registerFail);

      if (registerSuccess) {
        payload.eventName = enums.TRACKING_EVENT_NAMES.HAS_SUBMITTED_NEW_ACCOUNT;
        payload.eventData = {
          submitType: enums.TRACKING_EVENT_NAMES.SUBMIT_TYPE.SUCCESS
        };
      } else if (registerFail) {
        payload.eventName = enums.TRACKING_EVENT_NAMES.HAS_SUBMITTED_NEW_ACCOUNT;
        payload.eventData = {
          submitType: enums.TRACKING_EVENT_NAMES.SUBMIT_TYPE.INVALID
        };
      }
      // Send event
      if (Object.keys(payload).length > 0) {
        window.app.services.tracking.send(payload);
      }
    };

    uP.OpenMenuItem = function (item, params) {
      var options = Object.assign({ open: item }, params);
      $.post(site.local + 'xHttp/CustomerPanel.php', options).done(function (data) {
        redirectIfCaptcha(data, item);

        var $takeawayPayRegistration = $('.takeaway-pay-registration');
        if (item === 'logout' && ($(body).hasClass('myaccountpages') || $takeawayPayRegistration.length > 0)) {
          window.location.reload(); // Reload just like MyAccount.js does
          return false;
        }

        if (data) {
          data = $.parseHTML(data);
          var title = $(data).filter('dt').text();
          var $userpanelWrapper = $(userpanelWrapper);
          var target = item === false ? $(userpanel) : $userpanelWrapper;
          var favoriteModal = $(data).find('#noFavorites').length;
          var orderHistory = $(data).closest('#order-history').length;
          var orderHistoryEmpty = $(data).find('#order-history-empty').length;

          target.html(data);
          TakeawayPay.initClickOnUserPanel();
          StampCards.init();
          StampCards.initTrackingOnUserPanel();
          addTrackingEventOnRegisterFormSubmit();
          addTrackingForCourier();

          if (item) {
            $userpanelWrapper.addClass('submenu');
          }
          if (title) {
            $('.modal-title .title', userpanel).html(title);
          }

          if (item === 'register') {
            initStrengthBar($('.progress-bar-parent'));
            initRegisterForm();
          }

          if (!favoriteModal && !orderHistory) {
            $(userpanel).addClass('no-scroll');
          }

          if (favoriteModal) {
            $(userpanel).removeClass('no-scroll');
            $('.inner').addClass('inner--bg-white');
            favoritesModal.initTrackingForFavorites();
            browseRestaurantButton();
            uP.addTrackingBrowseRestaurantBtn(favoritesModal);
          }

          if (orderHistory) {
            $(userpanel).removeClass('no-scroll');
            $('.inner').addClass('inner--bg-white');
            orderHistoryModal.initTrackingOrderHistoryModal();
            if (orderHistoryEmpty) {
              browseRestaurantButton();
              uP.addTrackingBrowseRestaurantBtn(orderHistoryModal);
            }
          }
        }

        if (item === 'logout' || item === false) {
          checkLoginLogout();
        }

        if (item === 'login') {
          window.app.services.optInService.setOptInStatusFromLogin();
        }

        setModal($(userpanel));

        if (item === 'logout') {
          uP.OpenMenuItem(false);
        }

        if (item === 'languages') {
          window.dispatchEvent(new Event('mobile-lang-loaded'));
          var popupLanguageUrls = document.querySelectorAll('.popup-language-url');
          for (var popupUrlIndex = 0; popupUrlIndex < popupLanguageUrls.length; popupUrlIndex++) {
            popupLanguageUrls[popupUrlIndex].addEventListener('click', function (item) {
              item.preventDefault();
              item.stopPropagation();
              var target = item.target;

              // Gets the languages from the <link rel="alternate"
              var linkItems = document.querySelectorAll('.js-click-language.js-url-source');
              var itemUrls = [];
              for (var linkIndex = 0; linkIndex < linkItems.length; linkIndex++) {
                var element = linkItems[linkIndex];
                // Convert the itemUrl to an absolute url
                itemUrls[element.dataset.clickLanguage] = element.href.substr(element.href.indexOf('/', element.href.indexOf('.')));
              }

              if (target && target.dataset && target.dataset.clickLanguage && itemUrls[target.dataset.clickLanguage]) {
                window.location.assign(itemUrls[target.dataset.clickLanguage]);
              } else {
                var concatfix = site.local === '/' ? '' : '-';
                window.location.assign('' + site.local + concatfix + target.dataset.clickLanguage);
              }
            });
          }
        }

        if (item === 'orders') {
          var orders = document.querySelectorAll('.js-detailed-order');
          if (orders) {
            orders.forEach(function (order) {
              order.addEventListener('click', function (e) {
                var orderElem = e.currentTarget;
                var orderRef = orderElem.getAttribute('data-orderref');
                var orderId = orderElem.getAttribute('data-id');
                var restaurantId = orderElem.getAttribute('data-restid');
                var isActiveOrder = orderElem.getAttribute('data-type') === 'active-order';
                var isGuestOrder = orderElem.getAttribute('data-type') === 'guest-order';

                if (isActiveOrder) {
                  // Handle active orders event click

                  // Tracking
                  if (Helper.isTrackingAvailable()) {
                    window.dataLayer.push({
                      event: 'hasClickedActiveOrder',
                      'tms_data': {
                        orderHistoryTransactionID: orderRef,
                        restaurantID: restaurantId
                      }
                    });
                  }
                } else {
                  // Handle old orders event click
                  if (!isGuestOrder) {
                    uP.OpenMenuItem('orderdetails', { orderId: orderId });
                  }

                  // Tracking
                  if (Helper.isTrackingAvailable()) {
                    window.dataLayer.push({
                      event: 'hasClickedPastOrder',
                      'tms_data': {
                        orderHistoryTransactionID: orderRef,
                        restaurantID: restaurantId
                      }
                    });
                  }
                }
              });
            });
          }
        }

        if (item === 'orderdetails') {
          $(userpanel).removeClass('no-scroll');

          orderHistoryModal.initBackButton(uP);

          uP.updateFavouriteRestaurant();
          uP.addReview();
          uP.reorderOrder();

          var tipping = new window.app.components.Tipping({
            containerSelector: '.js-tipping',
            source: 'order-history'
          });
          tipping.init();
        }

        if (item === 'addreview') {
          $(userpanel).removeClass('no-scroll');

          addReviewModal.initSubmitFunction(uP);
          addReviewModal.initBackButton(uP);
        }

        uP.updateLoyaltyPoints();
        window.app.components.updateCustomerPanelPoints();
        uP.updateTakeawayPayAmount();
        favoritesModal.initTrackingFavoritesModal();
        orderHistoryModal.initTrackingOrderHistoryModal();

        return false;
      }).always(function () {
        if (['login', 'register'].includes(item)) {
          window.app.services.addFacebookClickAndLoadEvent();
          window.app.services.addGoogleLoginClickAndLoadEvent();
        }
      });
    };

    uP.OpenMenuItemDirectly = function (item) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      uP.init();

      uP.OpenMenuItem(item, params);

      StampCards.initTrackingOnUserPanel();
      addTrackingForCourier();

      favoritesModal.initTrackingFavoritesModal();

      orderHistoryModal.initTrackingOrderHistoryModal();

      document.body.classList.add('stop-scroll');
    };

    uP.updateFavouriteRestaurant = function () {
      var favoriteElement = document.querySelector('.js-favorite-update');

      if (favoriteElement) {
        var currentRestaurant = favoriteElement.dataset.restaurant;
        if (currentRestaurant) {
          var isFavorite = window.app.services.user.getFavoriteRestaurants();
          if (isFavorite.includes(currentRestaurant)) {
            favoriteElement.classList.add('selected');
          }

          favoriteElement.addEventListener('click', function (event) {
            var favoAction = favoriteElement.classList.contains('selected') ? 'remove' : 'add';
            var isLoggedIn = window.app.services.user.isLogged();

            if (!currentRestaurant) {
              return;
            }

            if (isLoggedIn) {
              xmlRequest(site.local + 'setFavorite.php', 'action=' + favoAction + 'favorite&bid=' + currentRestaurant, 'idummy');
            } else {
              window.app.services.user.manageLocalFavorites(favoAction, currentRestaurant);
            }

            if (favoAction === 'add') {
              favoriteElement.classList.add('selected');

              if (orderHistoryModal.isOrderDetails()) {
                orderHistoryModal.trackEventOrderDetailsAddFavorite(currentRestaurant);
              }
            } else {
              favoriteElement.classList.remove('selected');
            }
            return false;
          });
        }
      }
    };

    uP.addReview = function () {
      var addReviewButton = document.querySelector('.js-add-review-order-history');

      if (addReviewButton) {
        var _addReviewButton$data = addReviewButton.dataset,
            orderId = _addReviewButton$data.orderId,
            orderTransactionId = _addReviewButton$data.orderTransactionId,
            restaurantId = _addReviewButton$data.restaurantId;


        if (orderId) {
          addReviewButton.addEventListener('click', function () {
            uP.OpenMenuItem('addreview', {
              orderId: orderId
            });

            if (orderHistoryModal.isOrderDetails() && orderTransactionId && restaurantId) {
              orderHistoryModal.trackEventOrderDetailsAddReview(orderTransactionId, restaurantId);
            }
          });
        }
      }
    };

    uP.reorderOrder = function () {
      var reorderButton = document.querySelector('.js-reorder-order');

      if (reorderButton) {
        var restaurantUrl = reorderButton.dataset.restaurantUrl;

        if (restaurantUrl !== '') {
          reorderButton.addEventListener('click', function () {
            return uP.handleReorderClick();
          });
        }
      }
    };

    /**
     * Click function of reorder button in order history.
     * @returns {boolean}
     */
    uP.handleReorderClick = function () {
      var _document$querySelect = document.querySelector('.js-reorder-order').dataset,
          deliveryMethod = _document$querySelect.deliveryMethod,
          errorNotificationMessage = _document$querySelect.errorNotificationMessage,
          _document$querySelect2 = _document$querySelect.houseNumber,
          houseNumber = _document$querySelect2 === undefined ? '' : _document$querySelect2,
          _document$querySelect3 = _document$querySelect.latitude,
          latitude = _document$querySelect3 === undefined ? '' : _document$querySelect3,
          _document$querySelect4 = _document$querySelect.longitude,
          longitude = _document$querySelect4 === undefined ? '' : _document$querySelect4,
          orderId = _document$querySelect.orderId,
          orderTransactionId = _document$querySelect.orderTransactionId,
          _document$querySelect5 = _document$querySelect.postcode,
          postcode = _document$querySelect5 === undefined ? '' : _document$querySelect5,
          restaurantId = _document$querySelect.restaurantId,
          restaurantUrl = _document$querySelect.restaurantUrl,
          _document$querySelect6 = _document$querySelect.streetAddress,
          streetAddress = _document$querySelect6 === undefined ? '' : _document$querySelect6,
          _document$querySelect7 = _document$querySelect.town,
          town = _document$querySelect7 === undefined ? '' : _document$querySelect7,
          unavailabilityNotificationMessage = _document$querySelect.unavailabilityNotificationMessage;

      app.components.locationPanel.UI.clearStoredAddressData();

      var addressString = streetAddress;
      var addressObject = { route: streetAddress };

      if (houseNumber !== '') {
        addressString += ' ' + houseNumber;
        addressObject.street_number = houseNumber;
      }

      addressString += ', ' + postcode;
      addressObject.postal_code = postcode;

      if (town !== '') {
        addressString += ' ' + town;
        addressObject.locality = town;
      }

      Cookies.set('latitude', latitude);
      Cookies.set('longitude', longitude);
      Cookies.set('postcode', postcode);
      Cookies.set('searchstring', addressString);
      localStorage.setItem('SelectedAddress', JSON.stringify(addressObject));
      if (orderHistoryModal.isOrderDetails() && orderTransactionId && restaurantId) {
        orderHistoryModal.trackEventOrderDetailsReOrder(orderTransactionId, restaurantId);
      }

      if (orderId && restaurantId) {
        window.axios.get(site.aPath + 'xHttp/reorder/' + deliveryMethod + '/' + orderId + '/' + restaurantId).then(function (_ref) {
          var result = _ref.data.result;

          if (result) {
            try {
              // Set reorder data which is needed in Basket.js::loadBasket()
              var baskets = result;
              baskets[restaurantId].isReorder = true;
              baskets[restaurantId].unavailabilityNotificationMessage = unavailabilityNotificationMessage;
              // Write basket related data
              Cookies.set('pickup', deliveryMethod);
              localStorage.setItem(Takeaway.Basket.Persistence.BASKET, JSON.stringify(baskets));
              localStorage.setItem(Takeaway.Basket.Persistence.LAST_INTERACTION_TIME, Date.now());
              window.location = restaurantUrl;
            } catch (e) {
              console.error('Reorder data handling error:', e);
              window.app.helpers.notifyErrorWithIconSad(errorNotificationMessage);
            }
          } else {
            window.app.helpers.notifyErrorWithIconSad(errorNotificationMessage);
          }
        }).catch(function (error) {
          console.error('Reorder api error:', error);
          window.app.helpers.notifyErrorWithIconSad(errorNotificationMessage);
        });
      } else {
        window.location = restaurantUrl;
        window.app.helpers.notifyErrorWithIconSad(errorNotificationMessage);
      }

      return false;
    };

    uP.handleMessage = function (e) {
      switch (e.detail.type) {
        case window.app.services.hash.PAGES.MAIN_PAGE:
          uP.settings.fullscreen = window.app.services.mediaQueryService.respondTo('<tablet-landscape');
          uP.Show();
          break;
        case window.app.services.hash.PAGES.SUB_PAGE:
          uP.OpenMenuItemDirectly(e.detail.data);
          break;
        case window.app.services.hash.PAGES.SUB_PAGE_WITH_DATA:
          var data = e.detail.data;
          if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.hasOwnProperty('target') && data.hasOwnProperty('params')) {
            uP.OpenMenuItemDirectly(data.target, data.params);
          }
          break;
        default:
      }
    };

    // browser restaurant from UserPanel button
    function browseRestaurantButton() {
      var browseRestaurantsClass = '.js-browse-restaurant-btn';
      var browseRestaurantElem = document.querySelector(browseRestaurantsClass);
      browseRestaurantElem.addEventListener('click', function (event) {
        event.preventDefault();
        var iSearchString = document.getElementById('isearchstring');
        var doesAddressExist = iSearchString ? iSearchString.value : null;
        var getPostcodeFromCookie = Cookies.get('postcode') || Cookies.get('AID') || false;
        var mySearchString = document.querySelector('#imysearchstring');
        if (document.body.classList.contains('step1') && !doesAddressExist && !mySearchString.value || document.body.classList.contains('is-restaurant-list')) {
          if (document.body.classList.contains('step1')) {
            var submitDeliveryareaBtn = document.querySelector('#submit_deliveryarea');
            var autoCompleteDropDown = document.querySelector('.autoCompleteDropDown');
            setTimeout(function () {
              mySearchString.focus();
              mySearchString.classList.add('open');
              submitDeliveryareaBtn.style.display = 'none';
              autoCompleteDropDown.style.display = 'block';
            }, 10);
          }
          uP.Run();
        } else {
          var userPostcode = getPostcodeFromCookie ? fomatQuerySplitPostcode(formatQueryPostcode(getPostcodeFromCookie)) : false;
          var geoAddress = window.app.services.addressStorage.retrieveGeoAddress();
          if (userPostcode) {
            window.location = userPostcode;
          } else if (geoAddress && geoAddress.postcode) {
            window.location = geoAddress.postcode;
          } else {
            window.location = window.location.pathname.replace(/[^/]+$/, '');
          }
        }
      });
    }

    $document.ready(function () {
      // Listen for hash changes
      window.app.services.message.onMessage(uP.handleMessage);
      // Set hash to userPanel state
      defaults.hash = window.app.services.hash.getHash() && window.app.services.hash.getHash();
      // Check for initial hash
      window.app.services.hash.process();
      // Check for hash changes
      window.addEventListener('hashchange', window.app.services.hash.process);

      // check if url had param to open popup
      var takeawayPayForgotPassword = 'tap-forgot-password';

      $document.on('click', '.legal', function (e) {
        var $ilegal = $('#ilegal');
        if (e.target.nodeName !== 'A' && $ilegal.is(':visible')) {
          if ($ilegal.prop('checked')) {
            $('#legalerror').css('display', 'none');
          } else {
            $('#legalerror').css('display', 'block');
          }
        }
      });

      $document.on('click', '.footer-already-has-account a', function (e) {
        e.preventDefault();
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_I_HAVE_AN_ACCOUNT
        });
        uP.OpenMenuItem('login');
      });

      $document.on('click', '.footer-create-an-account a', function (e) {
        e.preventDefault();
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_CREATE_ACCOUNT
        });
        uP.OpenMenuItem('register');
      });

      $document.on('click', '#morelegalinfo', function (e) {
        e.preventDefault();
        var legal = $('.legal.extra');
        if (legal.css('display') === 'block') {
          $(this).text($(this).data('show'));
        } else {
          $(this).text($(this).data('hide'));
        }
        legal.toggle();
      });

      // click events
      $document.on('click', '.userlogin', function (e) {
        e.preventDefault();
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_BURGER_MODAL
        });
        if ($(this).hasClass('userlogin-myaccount')) {
          uP.settings.myaccount = true;
        }

        scrollPosition = $(window).scrollTop();
        resetView();

        uP.Run();
      });

      $document.on('click', '.userpanel .userpanel-list-link a', function (e) {
        var item = $(this).data('click');
        if (item !== undefined) {
          e.preventDefault();
          uP.OpenMenuItem(item);
        }
      });

      // this has been externilized for futur changes that will happen to the login and registration popups
      $document.on('click', '.userpanel .login-signup-container a', function (e) {
        var item = $(this).data('click');
        if (item !== undefined) {
          if (item === 'login') {
            window.app.services.tracking.send({
              eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_LOGIN,
              eventData: {
                linkType: 'My account Modal'
              }
            });
          }

          if (item === 'register') {
            window.app.services.tracking.send({
              eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_CREATE_ACCOUNT
            });
          }
          e.preventDefault();
          uP.OpenMenuItem(item);
        }
      });

      document.getElementById('userpanel').addEventListener('keyup', function (clickEvent) {
        if (clickEvent.keyCode === KEYCODE_ESC) {
          clickEvent.preventDefault();
          uP.Hide();
        }
      });

      $('.userpanel').on('click', function (e) {
        // ugly work around for takeaway pay
        var isPanelClick = e.target.id === 'userpanel';
        if (e.target.classList.contains('modal-close') || isPanelClick) {
          if (this.classList.contains(takeawayPayForgotPassword)) {
            // Only hide when this is takeaway pay
            uP.Hide();
            this.classList.remove(takeawayPayForgotPassword);
          } else {
            e.preventDefault();
            uP.Run();
            if (!isPanelClick) {
              $(window).scrollTop(scrollPosition);
            }
          }
        }
      });

      $document.on('click', '.modal-back', function (e) {
        e.preventDefault();
        uP.OpenMenuItem(false);
      });

      var $backToOrderHistory = document.querySelector('.js-back-to-order-history');
      if ($backToOrderHistory) {
        $backToOrderHistory.addEventListener('click', function (e) {
          e.preventDefault();
        });
      }

      $(document).on('click', '#userpanel', function (e) {
        var isForgotPasswordPopup = $(e.target).find('.forgot-password').length > 0;
        if (e.target.id === 'userpanel' && isForgotPasswordPopup === false) {
          e.preventDefault();
          uP.Run();
        }
      });

      $(document).on('click', 'li.fold', function (e) {
        var target = $(e.target);
        if (!target.hasClass('foldmenu-item')) {
          $(this).toggleClass('active');
          return false;
        }
      });

      // on resize
      $(window).on('resize', function (e) {
        e.preventDefault();
        uP.settings.fullscreen = window.app.services.mediaQueryService.respondTo('<tablet-landscape');
        uP.settings.userpanelvisible = $(userpanel).hasClass('show');

        if (uP.settings.userpanelvisible === true && uP.settings.fullscreen === true) {
          $(body).removeClass('utility-bottom-header');
          $(body).addClass('fullscreen');
          $(body).find('.content').addClass('collapse');
          $('html').addClass('fullscreen');
        }
        if (uP.settings.userpanelvisible === true && uP.settings.fullscreen === false) {
          $(body).removeClass('fullscreen');
          $(body).find('.content').removeClass('collapse');
          $('html').removeClass('fullscreen');
        }
      });

      // userpanel tabs
      $document.on('click', '.tab-navigation #userlogin', function (e) {
        e.preventDefault();
        xmlRequest(site.local + 'xHttp/CustomerLogin.php', false, 'userpanel-wrapper', false, false, false);
        return false;
      });

      $document.on('click', '.tab-navigation #userregister', function (e) {
        e.preventDefault();
        xmlRequest(site.local + 'xHttp/CustomerCreateAccount.php', '', 'userpanel-wrapper', false, false, 'form signup');
        return false;
      });
    });
  };
})(jQuery);

var userpanel = new $.userPanel('.userpanel', false);

var favoritesModal = function () {
  var noFavoriteClass = '.js-no-favorite';
  var myFavoriteModalClass = '.js-my-favorites-menu';
  var favoritesParentSelector = '.js-userpanel-favorites';
  var openFavoriteRestaurantClass = 'js-open-favorite-rest';
  var removeFavoriteRestaurantClass = 'js-remove-favorite';

  function removeFavoriteRestaurant(restaurantElem, restaurantId, favoritesParentElem) {
    var noFavoritesMsg = document.querySelector(noFavoriteClass);
    var thisRestaurant = restaurantElem.parentNode.parentNode;
    favoritesParentElem.removeChild(thisRestaurant);
    if (window.app.services.user.isLogged()) {
      $.post(restaurantElem.getAttribute('data-url') + 'setFavorite.php', { bid: restaurantId, action: 'removefavorite' }, function (data) {
        if (data) {
          noFavoritesMsg.classList.add('no-favorites--visible');
        }
      });
    } else {
      window.app.services.user.manageLocalFavorites('remove', restaurantId, function () {
        var latestFavoriteRestaurant = window.app.services.user.getFavoriteRestaurants();
        if (latestFavoriteRestaurant.length === 0) {
          noFavoritesMsg.classList.add('no-favorites--visible');
        }
      });
    }
    return false;
  }

  function initTrackingForFavorites() {
    var favoritesParentElem = document.querySelector(favoritesParentSelector) || false;
    if (favoritesParentElem && favoritesParentElem.hasChildNodes()) {
      (function () {
        var favoritesList = document.querySelectorAll('.' + openFavoriteRestaurantClass);

        var _loop = function _loop(restaurantIndex) {
          favoritesList[restaurantIndex].addEventListener('click', function (event) {
            var restaurantId = favoritesList[restaurantIndex].getAttribute('data-id');
            if (!event.target.classList.contains(removeFavoriteRestaurantClass) && (event.target === favoritesList[restaurantIndex] || favoritesList[restaurantIndex].contains(event.target))) {
              var restaurantUrl = favoritesList[restaurantIndex].getAttribute('data-url');
              if (Helper.isTrackingAvailable()) {
                window.dataLayer.push({
                  event: 'hasClickedRestaurantInFavorites',
                  tms_data: {
                    restaurantID: restaurantId
                  }
                });
              }
              setDeliveryArea(restaurantUrl, restaurantId);
            }
            if (event.target.classList.contains(removeFavoriteRestaurantClass)) {
              var restaurantElem = event.target;
              removeFavoriteRestaurant(restaurantElem, restaurantId, favoritesParentElem);
              if (Helper.isTrackingAvailable()) {
                window.dataLayer.push({
                  event: 'hasRemovedFavourite',
                  tms_data: {
                    restaurantID: restaurantId
                  }
                });
              }
            }
          }, false);
        };

        for (var restaurantIndex = 0; restaurantIndex < favoritesList.length; restaurantIndex++) {
          _loop(restaurantIndex);
        }
      })();
    }
  }

  function setDeliveryArea(dataUrl, dataId) {
    $.post(dataUrl + 'setDeliveryAreaId.php', { locationidrestaurant: dataId, type: 'postcode' }, function (data) {
      var obj = $.parseJSON(data);
      if (obj.type === 'url') {
        document.location = obj.value;
      }
    });
  }

  function initTrackingFavoritesModal() {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    var myFavoriteModalElem = document.querySelector(myFavoriteModalClass);
    if (myFavoriteModalElem) {
      myFavoriteModalElem.addEventListener('click', function (event) {
        window.dataLayer.push({
          event: 'hasViewedFavourites'
        });
      }, false);
    }
  }

  return {
    initTrackingFavoritesModal: initTrackingFavoritesModal,
    initTrackingForFavorites: initTrackingForFavorites
  };
}();

var orderHistoryModal = function () {
  var orderHistoryModalClass = '.js-order-history-menu';
  var orderHistoryBackButtonClass = '.js-back-to-order-history';
  var orderDetailsModalClass = '.js-order-details';

  function isOrderDetails() {
    return document.querySelectorAll(orderDetailsModalClass).length > 0;
  }

  function initTrackingOrderHistoryModal() {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    var orderHistoryModal = document.querySelector(orderHistoryModalClass);
    if (orderHistoryModal) {
      orderHistoryModal.addEventListener('click', function () {
        window.dataLayer.push({
          event: 'hasViewedOrderHistory'
        });
      });
    }
  }

  function trackEventOrderDetailsAddFavorite(restaurantId) {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    window.dataLayer.push({
      event: 'hasFavouriteAddedInOrderHistory',
      tms_data: {
        restaurantID: restaurantId
      }
    });
  }

  function trackEventOrderDetailsAddReview(orderTransactionId, restaurantId) {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    window.dataLayer.push({
      event: 'hasReviewedInOrderHistory',
      tms_data: {
        orderHistoryTransactionID: orderTransactionId,
        restaurantID: restaurantId
      }
    });
  }

  function trackEventOrderDetailsReOrder(orderTransactionId, restaurantId) {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    window.dataLayer.push({
      event: 'hasReorderedInOrderHistory',
      tms_data: {
        orderHistoryTransactionID: orderTransactionId,
        restaurantID: restaurantId
      }
    });
  }

  function initBackButton(uP) {
    var backButtons = document.querySelectorAll(orderHistoryBackButtonClass);
    if (backButtons.length > 0) {
      backButtons.forEach(function (button) {
        button.addEventListener('click', function () {
          uP.OpenMenuItem('orders');
        });
      });
    }
  }

  return {
    isOrderDetails: isOrderDetails,
    trackEventOrderDetailsAddFavorite: trackEventOrderDetailsAddFavorite,
    trackEventOrderDetailsAddReview: trackEventOrderDetailsAddReview,
    trackEventOrderDetailsReOrder: trackEventOrderDetailsReOrder,
    initTrackingOrderHistoryModal: initTrackingOrderHistoryModal,
    initBackButton: initBackButton
  };
}();

var addReviewModal = function () {
  var postReview = function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(formValues) {
      var addReviewForm, _addReviewForm$datase, reviewUrl, reviewKey, restaurantId;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              addReviewForm = document.querySelector(addReviewFormClass);

              if (!addReviewForm) {
                _context.next = 5;
                break;
              }

              _addReviewForm$datase = addReviewForm.dataset, reviewUrl = _addReviewForm$datase.reviewUrl, reviewKey = _addReviewForm$datase.reviewKey, restaurantId = _addReviewForm$datase.restaurantId;


              if (!reviewUrl || !reviewKey || !restaurantId) {
                console.error('Missing data for a valid review: ' + JSON.stringify({ reviewUrl: reviewUrl, reviewKey: reviewKey, restaurantId: restaurantId }));
              }

              return _context.abrupt('return', fetch(reviewUrl + '?key=' + reviewKey + '&restid=' + restaurantId, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Accept': 'application/json'
                },
                body: formValues,
                type: 'json'
              }).then(function (response) {
                if (!response.ok) {
                  throw Error(response.statusText);
                }
                return response;
              }).then(function (response) {
                return response.json();
              }).then(function (jsonResponse) {
                return jsonResponse;
              }));

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function postReview(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var submitReview = function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(eventHandler) {
      var target, formFieldsArray, postString, result, addReviewForm, addReviewFormInOrderHistory, backButton, _addReviewForm$datase2, orderTransactionId, encryptedRestaurantId;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              eventHandler.preventDefault();
              eventHandler.stopPropagation();

              target = eventHandler.target;
              formFieldsArray = Array.from(target.querySelectorAll('[name]'));
              postString = serializeReview(formFieldsArray);
              _context2.next = 7;
              return postReview(postString);

            case 7:
              result = _context2.sent;

              if (result && result.success) {
                addReviewForm = document.querySelector(addReviewFormClass);
                addReviewFormInOrderHistory = document.querySelector('.js-add-review-form');

                window.app.helpers.notifySuccessWithIconHappy(result.html);
                backButton = document.querySelector(addReviewBackButtonClass);

                if (backButton) {
                  backButton.click();
                  if (addReviewForm) {
                    _addReviewForm$datase2 = addReviewForm.dataset, orderTransactionId = _addReviewForm$datase2.orderTransactionId, encryptedRestaurantId = _addReviewForm$datase2.encryptedRestaurantId;

                    if (addReviewFormInOrderHistory && orderTransactionId && encryptedRestaurantId) {
                      trackEventAddReviewSubmit(orderTransactionId, encryptedRestaurantId);
                    }
                  }
                }
              } else {
                window.app.helpers.notifyErrorWithIconSad(result.html);
              }

            case 9:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function submitReview(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  var addReviewFormClass = '.js-voteform';
  var addReviewFormErrorClass = '.js-voteform-error';
  var addReviewBackButtonClass = '.js-back-to-order-details';

  function trackEventAddReviewSubmit(orderTransactionId, restaurantId) {
    if (!Helper.isTrackingAvailable()) {
      return;
    }

    window.dataLayer.push({
      event: 'hasReviewAddedInOrderHistory',
      tms_data: {
        orderHistoryTransactionID: orderTransactionId,
        restaurantID: restaurantId
      }
    });
  }

  function serializeReview(formFields) {
    var serialized = [];
    Array.from(formFields).forEach(function (field) {
      if (!field.name || field.disabled || field.type === 'file' || field.type === 'reset' || field.type === 'submit' || field.type === 'button') {
        return;
      }

      if (field.type === 'select-multiple') {
        field.options.filter(function (option) {
          return option.selected;
        }).forEach(function (option) {
          return serialized.push(encodeURIComponent(field.name) + '=' + encodeURIComponent(option.value));
        });
      }

      if (field.type !== 'checkbox' && field.type !== 'radio' || field.checked) {
        if (field.name === 'vote_estimateddeliverytime' && !field.value) {
          return;
        }
        serialized.push(encodeURIComponent(field.name) + '=' + encodeURIComponent(field.value));
      }
    });
    return serialized.join('&');
  }

  function initSubmitFunction() {
    var addReviewForm = document.querySelector(addReviewFormClass);
    if (addReviewForm) {
      addReviewForm.addEventListener('submit', submitReview);
    }
  }

  function initBackButton(uP) {
    var backButton = document.querySelector(addReviewBackButtonClass);
    if (backButton) {
      var addReviewForm = document.querySelector(addReviewFormClass);
      var orderId = void 0;
      if (addReviewForm) {
        orderId = addReviewForm.dataset['orderId'];
      } else {
        var addReviewFormError = document.querySelector(addReviewFormErrorClass);
        orderId = addReviewFormError.dataset['orderId'];
      }

      backButton.addEventListener('click', function () {
        uP.OpenMenuItem('orderdetails', {
          orderId: orderId
        });
      });
    }
  }

  return {
    initSubmitFunction: initSubmitFunction,
    initBackButton: initBackButton
  };
}();
/* global $, resetView, toggleMap */
$(document).ready(function () {
  $('.button-user', '#country').click(function (e) {
    e.stopPropagation();
    resetView();
    toggleMap(false);
    $('#country').toggleClass('expanded expanded-country');
  });
  $(window).click(function () {
    $('.select-dropdown').removeClass('expanded expanded-country expanded-locale');
  });

  var localeButton = $('#locale');
  localeButton.click(function (e) {
    e.stopPropagation();
    $('.language-country-modal').toggleClass('active');
  });

  $(document).click(function (e) {
    var localeModal = $('.language-country-modal');
    if (e.target !== localeButton && !localeModal.is(e.target) && localeModal.has(e.target).length === 0) {
      localeModal.removeClass('active');
    }
  });
});
/* global google, $, MarkerClusterer, restaurants, visibleRestaurantIds, returnToList, Cookies, PcMatch, AutoComplete, site, AreaId, initLazyLoad */
/**
 * Only used in UtilityBar.js. Its name was 'Map', which gave errors on IE11
 *
 * @constructor
 */
var CustomMap = function CustomMap() {
  this.geocoder = new google.maps.Geocoder();
  this.markers = [];
  this.restaurantsmap = $('.restaurants-map');
  this.canvasId = 'map-canvas';

  this.googlemapcanvas = $('#' + this.canvasId);

  /** @var {google.maps.Map} this.map */
  this.map = null;
  /** @var {google.maps.Marker} this.customerLocation */
  this.customerLocation = null;
  this.dataWindowClass = 'map-data-window';
  this.cards = {
    pickup: [],
    delivery: []
  };
  this.bufferTime = 300000; // 5 minutes
  this.backToListButton = $('.js-back-to-list-button');
};

/**
 * Create an plain JS object to represent a Google Maps Icon
 *
 * @param {string} subject
 *
 * @returns {{url: *, scaledSize: google.maps.Size}}
 */
CustomMap.prototype.createIcon = function (subject) {
  var images = {
    active: { url: '/assets/icons/ta-location-pin-active.svg', width: 38, height: 47 },
    location: { url: '/assets/icons/ta-location-gps.svg', width: 56, height: 56 },
    regular: { url: '/assets/icons/ta-location-pin-shadow.svg', width: 40, height: 41 }
  };

  var image = images[subject];

  if (image === undefined) {
    throw new Error('Unknow pin "' + subject + '"');
  }

  return {
    url: image.url,
    scaledSize: new google.maps.Size(image.width, image.height)
  };
};

CustomMap.prototype.buildMarkerCluster = function (markers) {
  this.markerCluster = new MarkerClusterer(this.map, markers, {
    maxZoom: 17,
    imagePath: '/assets/icons/cluster/'
  });
  this.markerCluster.setClusterClass('clustered-pins');
};

CustomMap.prototype.updateClusters = function () {
  var visibleMarkers = this.markers.filter(function (marker) {
    return marker.visible;
  });

  if (this.markerCluster) {
    this.markerCluster.clearMarkers();
  }

  this.buildMarkerCluster(visibleMarkers);
  this.markerCluster.repaint();
};

CustomMap.prototype.init = function () {
  this.initGoogleMaps();
};

CustomMap.prototype.initGoogleMaps = function () {
  var self = this;
  var center = new google.maps.LatLng(0, 0);
  var noPoi = [{
    featureType: 'poi',
    stylers: [{ visibility: 'off' }]
  }];
  var mapOptions = {
    zoom: 14,
    center: center,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    mapTypeControl: false,
    streetViewControl: false,
    minZoom: 12,
    maxZoom: 18,
    styles: noPoi,
    fullscreenControl: false,
    zoomControlOptions: {
      style: google.maps.ZoomControlStyle.SMALL,
      position: google.maps.ControlPosition.LEFT_BOTTOM
    },
    panControl: true,
    panControlOptions: {
      position: google.maps.ControlPosition.RIGHT_BOTTOM
    }
  };

  this.map = new google.maps.Map(document.getElementById(this.canvasId), mapOptions);

  this.centerMapToCustomerAddress();

  for (var key in restaurants) {
    var restaurant = restaurants[key];

    var marker = new google.maps.Marker({
      position: new google.maps.LatLng(restaurant[16], restaurant[17]),
      map: this.map,
      icon: this.createIcon('regular'),
      title: restaurant[4]
    });
    marker.set('restId', restaurant[0]);
    marker.set('catIds', restaurant[1].join(','));

    if (marker) {
      // collect markers
      this.markers.push(marker);
    }
    this.addMarkerEvent(marker);
  }
  this.updateClusters();
  // Only fires if not clicked on a marker
  this.map.addListener('click', function () {
    self.reset();
    self.prev_marker = null; // remove the previous marker reference
  });

  // trigger resize if the bounds change
  this.map.addListener('bounds_changed', function () {
    google.maps.event.trigger(self.map, 'resize');
  });

  this.showMarkers();

  this.getDataWindow(); // So it get's added to the mapview

  this.showBackToListButton();
};

CustomMap.prototype.showBackToListButton = function () {
  if (this.backToListButton.length > 0) {
    this.googlemapcanvas.prepend(this.backToListButton);
    // add the functionality
    this.backToListButton.on('click', function (event) {
      returnToList(event); // from UtilityBar.js
    });

    this.backToListButton.addClass('show-button');
  }
};

CustomMap.prototype.hideMarkers = function () {
  console.log('Hiding markers');
  for (var i = 0, l = this.markers.length; i < l; i++) {
    this.markers[i].setVisible(false);
  }
};

CustomMap.prototype.showMarkers = function () {
  // first hide all markers
  this.hideMarkers();
  console.log('Show markers');
  if (visibleRestaurantIds.length === 0) {
    $.each(restaurants, function (i, restaurant) {
      visibleRestaurantIds.push(restaurant[0]);
    });
  }

  for (var Id in visibleRestaurantIds) {
    var restaurantId = visibleRestaurantIds[Id];
    for (var i = 0, l = this.markers.length; i < l; i++) {
      if (this.markers[i].restId === restaurantId) {
        this.markers[i].setVisible(true);
      }
    }
  }
  // Update clusters
  this.updateClusters();
};

CustomMap.prototype.centerMapToCustomerAddress = function () {
  if (!this.map) {
    throw new Error('Cannot find the map');
  }
  var latitude = Cookies.get('latitude') || false;
  var longitude = Cookies.get('longitude') || false;
  var postcode = Cookies.get('postcode');
  var address = this.googlemapcanvas.attr('data-center-address');
  var location = void 0;

  if (typeof postcode !== 'undefined') {
    console.log('Found a postcode');
    postcode = $.trim(postcode.replace('+', ''));
    if (postcode.match(PcMatch)) {
      address = postcode + ', ' + AutoComplete.settings.myCountry[AutoComplete.settings.language];

      var search = Cookies.get('searchstring');
      if (typeof search !== 'undefined') {
        if (postcode !== search) {
          address = search + ', ' + AutoComplete.settings.myCountry[AutoComplete.settings.language];
        }
      }
    }
  }

  if (latitude === false || longitude === false) {
    console.log('Latitude and Longitude are incomplete, using geocoder');
    this.geocoder.geocode({ 'address': address }, function (results, status) {
      if (status === google.maps.GeocoderStatus.OK) {
        location = results[0].geometry.location;
        this.centerMapToCustomerLocation(location);
      }
    }.bind(this));
  } else {
    location = new google.maps.LatLng(latitude, longitude);
    this.centerMapToCustomerLocation(location);
  }
};

CustomMap.prototype.centerMapToCustomerLocation = function (location) {
  google.maps.event.trigger(this.map, 'resize');
  console.log('Setting the center of the map to the customers location');
  this.map.setCenter(location);
  if (this.customerLocation) {
    this.customerLocation.setMap(null);
  }
  console.log('Creating a location marker for the customer');
  this.customerLocation = new google.maps.Marker({
    map: this.map,
    icon: this.createIcon('location'),
    position: location
  });
};

CustomMap.prototype.reset = function () {
  var regularIcon = this.createIcon('regular');
  console.log('Resetting icons to regular');
  this.markers.forEach(function (marker) {
    marker.setIcon(regularIcon);
  });
  console.log('Emptying the datawindow');
  this.getDataWindow().html('');
};

CustomMap.prototype.getDataWindow = function () {
  var dataWindow = this.googlemapcanvas.find('.' + this.dataWindowClass);
  if (dataWindow.length === 0) {
    console.log('Creating datawindow');
    this.googlemapcanvas.children().first().prepend("<div class='" + this.dataWindowClass + "'></div>");
    dataWindow = this.googlemapcanvas.find('.' + this.dataWindowClass);
  }
  return dataWindow;
};

CustomMap.prototype.getRestaurantKey = function (restaurantId) {
  return 'restaurant_' + restaurantId;
};

CustomMap.prototype.showCard = function (sendData, marker) {
  var content = $($('#irestaurant' + sendData.bid).get(0).outerHTML);
  content.removeClass('restaurant-hide');
  this.renderCard('<div class="restaurant-infopanel delivery-card">' + content.get(0).outerHTML + '</div>', marker);
  initLazyLoad();
};

CustomMap.prototype.renderCard = function (html, marker) {
  // Check if the user still has the map view open

  if (this.restaurantsmap.hasClass('mapmode-panel')) {
    var dataWindow = this.getDataWindow();

    if (dataWindow.length > 0) {
      dataWindow.html(html);
    }

    this.map.panTo(marker.getPosition());
  }
};

CustomMap.prototype.addMarkerEvent = function (marker) {
  var self = this;
  google.maps.event.addListener(marker, 'click', function () {
    if (self.prev_marker) {
      self.reset();
      // Clicked on the same marker
      if (marker.get('restId') === self.prev_marker.get('restId')) {
        self.prev_marker = null;
        return null;
      }
    }

    var sendData = {
      bid: false,
      user: true
    };
    if (marker.get('restId') !== 'false') {
      // AreaId is a global
      sendData = { bid: marker.get('restId'), areaId: AreaId, location: window.app.services.user.location };
      marker.setIcon(self.createIcon('active'));
      self.prev_marker = marker;
    }

    self.showCard(sendData, marker);
  });
};

$.when($.ready).then(function () {
  $(window).resize(function () {
    if (typeof google !== 'undefined') {
      google.maps.event.trigger(CustomMap.map, 'resize');
    }
  });
});
/* global
  $,
  app,
  Helper,
  google,
  CustomMap,
  clearSearch,
  stickyKitchenType,
  isFilterActive,
  processHash,
  RestaurantSortBy,
  getRestaurantCount,
  basket
*/
var map;
var initOffsetHeight; // needed for Chrome for Android hack.
var utilityScrollTop; // dirty fix to hold the current scroll when basket is opened.
var headerHeight = 45;
var distanceFromTop = $('body').is('.is-restaurant-list, .step3') ? 226 : 290;
var windowScrollTop = distanceFromTop - headerHeight;

function isStep2() {
  return document.body.classList.contains('step2');
}

function toggleLocationPanel(value) {
  if (value) {
    if (!isStep2()) {
      $('.logo').removeClass('hide');
      $('.myaccount').removeClass('hide');
    }
  } else {
    if (!isStep2()) {
      $('.logo').addClass('hide');
      $('.myaccount').addClass('hide');
    }
  }
}

function toggleBottomHeader(action, show) {
  if (isStep2()) {
    var $element = $('.utility-middle-navigation .subnav-wrapper');
    var mode = ['searchmode', 'filtermode', 'mapmode'];
    var activeAction = show ? action : null;
    console.log('bottomHeader', action, show);
    var $body = $('body');

    for (var i = 0; i < mode.length; i++) {
      if (!activeAction || mode[i] !== activeAction) {
        $body.removeClass('utility-bottom-header');
        $body.removeClass('ubh-' + mode[i]);
        $element.removeClass(mode[i]);
      }
    }

    if (activeAction) {
      $body.addClass('utility-bottom-header');
      $body.addClass('ubh-' + activeAction);
      $element.addClass(action);
    }

    // show restaurant list on searchmode
    if (activeAction === 'searchmode') {
      $('.restaurants.restaurantlist').show();
    }
    // disabling filtermode is not active
    if (activeAction !== 'filtermode') {
      $('.restaurants-filter').removeClass('filtermode-panel');
    }
    // disabling mapmode is not active
    if (activeAction !== 'mapmode') {
      $('.restaurants-map').removeClass('mapmode-panel');
      $body.removeClass('fullscreen');
      $('html').removeClass('fullscreen');
      toggleMap(false);
    }
  }
}

function StickyPanel() {
  var $wrapper = $('.filter-wrapper');
  var scrollWrapper = 'filter-wrapper-scrolling';
  var $header = $('header');
  if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape') && !$header.hasClass('fixed') && !$('body').hasClass('step1')) {
    var utilityMiddleNavigation = $('.js-kitchen-type-sticky').height();
    var scrollShouldStart = $header.height() + utilityMiddleNavigation;

    var st = $(window).scrollTop();
    var stPos = st + $(window).height();
    var bottom = $(document).height() - $('footer').height();

    var filterPanelHeight = $wrapper.height();

    $wrapper.css('height', '');

    if ($('.restaurantlist').height() > filterPanelHeight) {
      if (stPos + filterPanelHeight > bottom) {
        var bottomOfWrapper = $wrapper.offset().top + $wrapper.outerHeight(true);
        if (bottom < bottomOfWrapper) {
          // calculate the remaining height of the wrapper when footer gets in view, so scrolling inside it will reach all elements
          var visibleHeightOfFooter = bottomOfWrapper - bottom;
          $wrapper.css('height', $(window).height() - visibleHeightOfFooter - utilityMiddleNavigation);
          $wrapper.scrollTop($wrapper.scrollTop() + (stPos - bottom));
          return;
        }
      }
      $wrapper.css('bottom', 'initial');
      if (st >= scrollShouldStart) {
        if (!$wrapper.hasClass(scrollWrapper)) {
          $wrapper.addClass(scrollWrapper).css('width', $('.restaurants-filter').width());
        }
      } else {
        if ($wrapper.hasClass(scrollWrapper)) {
          $wrapper.removeClass(scrollWrapper).css('width', '');
        }
      }
    } else {
      $wrapper.removeClass(scrollWrapper).css('width', '');
    }
  } else {
    $wrapper.removeClass(scrollWrapper).css('width', '');
  }
}

$(window).on('orientationchange', function () {
  console.log('orientation changed');
  setTimeout(function () {
    // settimeout is needed to make sure the orientation changed did finish
    if ($('.restaurants-map').hasClass('mapmode-panel')) {
      console.log('map refreshed');
      toggleMap(true);
    } else if ($('.kitchen-types').hasClass('kitchen-type-scrolling')) {
      console.log('scroll to top');
      $('html, body').animate({ scrollTop: 0 }, 'slow');
    }
  }, 500);
});

function goToListView() {
  resetView();
  toggleMap(false);
  if (window.app.services.mediaQueryService.respondTo('<tablet-landscape')) {
    $(window).scrollTop(windowScrollTop);
  }
  toggleBottomHeader('goToListView', false);
}

var UtilityInitSorting = function UtilityInitSorting() {
  var _window$app$getState = window.app.getState(),
      listSortBy = _window$app$getState.listSortBy;

  if (listSortBy !== 'default') {
    var subnavigation = $('.subnavigation');
    subnavigation.find('.btn-sorting').addClass('active');
    subnavigation.find('.btn-icon').removeClass().addClass('btn-icon ' + listSortBy).attr('data-sort', listSortBy);
    subnavigation.find('.btn-sorting-text').html($('.subnav-sortmode').find('[data-name="' + listSortBy + '"]').text());
  }
};

$(document).ready(function () {
  var $languageCountryModal = $('.language-country-modal');
  var $utilityMiddleNavigation = $('.utility-middle-navigation .subnav-wrapper');
  var $utilityAsideNavigation = $('.utility-aside-navigation .subnav-wrapper');
  var $buttonSearch = $('.btn-search');
  if (isStep2()) {
    var $topBar = $('.topbar');
    var $subHeader = $('.subheader');
    windowScrollTop = $topBar.outerHeight() + $subHeader.outerHeight();
    if ($('#irestaurantsearchstring-middle').val().length > 0) {
      $('.utility-middle-bar .btn-close').addClass('active');
    }
  }

  if (isStep2() && typeof restaurants !== 'undefined' && $('.subnavigation .btn-sorting').length > 0) {
    UtilityInitSorting();
  }

  initOffsetHeight = document.body.offsetHeight;
  $buttonSearch.find('#irestaurantsearchstring').keyup(function () {
    if ($(this).val().length > 0) {
      $buttonSearch.find('.btn-remove-search').addClass('btn-search-clear');
    } else {
      $buttonSearch.find('.btn-remove-search').removeClass('btn-search-clear');
    }
  });
  $buttonSearch.find('#irestaurantsearchstring-middle').keyup(function () {
    if ($(this).val().length > 0) {
      $buttonSearch.find('.btn-remove-search').addClass('btn-search-clear');
      $('.btn-filter', '.subnavigation').addClass('active');
      $('.utility-middle-bar .btn-close').addClass('active');
    } else {
      $buttonSearch.find('.btn-remove-search').removeClass('btn-search-clear');
      $('.utility-middle-bar .btn-close').removeClass('active');
      if (!isFilterActive()) {
        $('.btn-filter', '.subnavigation').removeClass('active');
      }
    }
  });

  $('a', '.subnav-sortmode').click(function (e) {
    e.preventDefault();
    var sortmethod = $(this).parent().data('name');
    var subnavigation = $('.subnav-wrapper'); // all sub navigations
    window.app.setState({ listSortBy: sortmethod });

    $('.sorting-select').val(sortmethod);
    RestaurantSortBy();

    // step2: MiddleBar
    if (sortmethod !== 'default' || isStep2()) {
      subnavigation.find('.btn-sorting').addClass('active');
      subnavigation.find('.btn-icon').removeClass().addClass('btn-icon ' + sortmethod).attr('data-sort', sortmethod);
      subnavigation.find('.btn-sorting-text').html($(this).parent().text());
    } else {
      $('.btn-remove-icon', '.subnavigation').click();
      resetView($(this));
    }
    Sort.closeSortingMiddle(e);
    Sort.closeSortingAside(e);
  });

  $('.btn-remove-icon', '.subnavigation').click(function () {
    if ($(this).parent().hasClass('active')) {
      if ($(this).parent().hasClass('btn-sorting')) {
        $(this).parent().removeClass('active').text($(this).parent().find('btn-text-placeholder').html());
        $(this).parent().find('.btn-icon').removeClass().addClass('btn-icon');
        RestaurantSortBy();
      }
    }
    return false;
  });

  // Clicking on the map button, both the top as the bottom one
  $('.btn.btn-map').click(function (event) {
    event.stopPropagation();
    var mapModeClass = 'mapmode';
    var mapModeAction = 'mapmode';

    // close language selector in case it is open
    $languageCountryModal.removeClass('active');
    $('.grid-container').removeClass('space-before');

    // If the map is active
    if (!$utilityMiddleNavigation.hasClass(mapModeClass)) {
      toggleBottomHeader(mapModeAction, true);
      var element = event.target;
      if (window.app.services.mediaQueryService.respondTo('<tablet-landscape')) {
        if (!$(element).hasClass('btn-search')) {
          $('body').addClass('fullscreen');
          $('html').addClass('fullscreen');
          showHeaderFullScreen();
        }
      }
      toggleMap(true);
      var mapcontent = $('.restaurants-map');
      mapcontent.addClass('mapmode-panel');
      $utilityMiddleNavigation.addClass(mapModeClass).removeClass('sortmode');
      google.maps.event.trigger(map, 'resize');
      $('.restaurants.restaurantlist').hide();
    } else {
      toggleBottomHeader(mapModeAction, false);
      resetView($(this));
      toggleMap(false);
    }
  });

  $('.js-btn-search').on('click', function () {
    console.log('js search button click, firing input focus');
    toggleBottomHeader('searchmode', true);
    $('.js-restaurantsearch-input').focus();
  });

  $('.js-restaurantsearch-input').on('focus blur', function (event) {
    // close language selector incase is open
    $languageCountryModal.removeClass('active');
    event.preventDefault();
    event.stopPropagation();
    console.log('restaurant search event', event.type);
    if (event.type === 'focus') {
      console.log('firing focus for search input');
      toggleBottomHeader('searchmode', true);
    } else {
      console.log('firing blur for search input');
      if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape')) {
        $utilityMiddleNavigation.removeClass('searchmode');
        toggleBottomHeader('searchmode', false);
      }
    }
  });

  var Sort = function () {
    function openSortingAside(event) {
      if (event) {
        event.preventDefault();
        if (event.type === 'blur') {
          // stop here, blur never opens the sorting
          return;
        }
      }
      $utilityAsideNavigation.addClass('sortmode');
    }

    function openSortingMiddle(event) {
      if (event) {
        event.preventDefault();
        if (event.type === 'blur') {
          // stop here, blur never opens the sorting
          return;
        }
      }
      $languageCountryModal.removeClass('active');
      $utilityMiddleNavigation.addClass('sortmode');
      if (window.app.services.mediaQueryService.respondTo('<tablet-landscape')) {
        $(window).scrollTop();
        $('body, html').addClass('fullscreen');
        $('#toTop').hide();
      }
    }

    function closeSortingAside(event) {
      if (event) {
        event.preventDefault();
        if (event.type === 'focus') {
          // stop here, focus never closes the sorting
          return;
        }
      }
      $utilityAsideNavigation.removeClass('sortmode');
    }

    function closeSortingMiddle(event) {
      if (event) {
        event.preventDefault();
        if (event.type === 'focus') {
          // stop here, focus never closes the sorting
          return;
        }
      }
      $utilityMiddleNavigation.removeClass('sortmode');
      $languageCountryModal.removeClass('active');
      if (document.activeElement) {
        document.activeElement.blur();
      }
    }

    function init() {
      /**
       * Adding desktop methods
       */

      var $jsBtnSortingMiddle = $('.js-btn-sorting-middle');
      // chose mousedown as it fires before focus
      $jsBtnSortingMiddle.on('mousedown touchstart', function (event) {
        if ($utilityMiddleNavigation.hasClass('sortmode')) {
          if (!$(event.target).hasClass('js-sorting-item')) {
            console.log('firing close sorting middle from ' + event.type);
            closeSortingMiddle(event);
          }
        } else {
          console.log('firing open sorting middle from ' + event.type);
          openSortingMiddle(event);
        }
      });

      // Adding focus handler for keyboard tab focus
      $jsBtnSortingMiddle.on('focus', function (event) {
        console.log('firing open sorting middle from ' + event.type);
        openSortingMiddle(event);
      });

      // Add blur with a small timeout on the sorting main item and the links
      $('.js-list-sorting-blur-middle a, .js-btn-sorting-middle').on('blur', function (event) {
        setTimeout(function () {
          var $focussed = $(':focus');
          // close the sorting if the next focussed element is not one of the sorting items, after 100 ms
          if (!$focussed.hasClass('js-sorting-item') && !$focussed.hasClass('js-btn-sorting-middle')) {
            console.log('firing close sorting from list item middle ' + event.type);
            closeSortingMiddle(event);
          }
        }, 100);
      });

      /**
       * Adding mobile methods
       */

      var $jsBtnSortingAside = $('.js-btn-sorting-aside');
      // same mousedown event
      $jsBtnSortingAside.on('mousedown touchstart', function (event) {
        if ($utilityAsideNavigation.hasClass('sortmode')) {
          if (!$(event.target).hasClass('js-sorting-item')) {
            // because touchstart fires too early
            console.log('firing close sorting aside from ' + event.type);
            closeSortingAside(event);
          }
        } else {
          console.log('firing open sorting aside from ' + event.type);
          openSortingAside(event);
        }
      });

      // Adding focus handler for keyboard tab focus
      // Unlikely this will ever be triggered, but just to be sure
      $jsBtnSortingAside.on('focus', function (event) {
        console.log('firing open sorting aside from ' + event.type);
        openSortingAside(event);
      });

      // Add blur with a small timeout on the sorting main item and the links
      $('.js-list-sorting-blur-aside a, .js-btn-sorting-aside').on('blur', function (event) {
        setTimeout(function () {
          var $focussed = $(':focus');
          // close the sorting if the next focussed element is not one of the sorting items, after 100 ms
          if (!$focussed.hasClass('js-sorting-item') && !$focussed.hasClass('js-btn-sorting-aside')) {
            console.log('firing close sorting from list item aside ' + event.type);
            closeSortingAside(event);
          }
        }, 100);
      });
    }

    return {
      init: init,
      closeSortingMiddle: closeSortingMiddle,
      closeSortingAside: closeSortingAside
    };
  }();

  Sort.init();

  $('.btn.btn-filter').click(function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (!$utilityMiddleNavigation.hasClass('filtermode')) {
      toggleBottomHeader('filtermode', true);
      if (!isStep2() && window.app.services.mediaQueryService.respondTo('<tablet-landscape')) {
        utilityScrollTop = $(window).scrollTop();
        var element = event.target;
        if ($(window).scrollTop() < windowScrollTop) {
          $(window).scrollTop(windowScrollTop);
        }
        if (!$(element).hasClass('btn-search')) {
          $('body').addClass('fullscreen');
          $('html').addClass('fullscreen');
          $('#toTop').hide();
          showHeaderFullScreen();
        }
      }
      $utilityMiddleNavigation.addClass('filtermode');
      $('.restaurants-filter').addClass('filtermode-panel');
      $('.filter-wrapper').removeClass('filter-wrapper-scrolling');
      $('.restaurants.restaurantlist').hide();
    } else {
      toggleBottomHeader('filtermode', false);
      resetView($(this));
    }
    var modalElement = document.querySelector('.js-restaurants-modal');
    window.app.helpers.keepFocusWithinModal({ modalElement: modalElement });
  });

  $('.btn.btn-categories').click(function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (!$(this).parent().hasClass('categorymode')) {
      utilityScrollTop = $(window).scrollTop();
      var element = event.target;
      if (window.app.services.mediaQueryService.respondTo('<tablet-landscape')) {
        if ($(window).scrollTop() < windowScrollTop) {
          $(window).scrollTop(windowScrollTop);
        }
        if (!$(element).hasClass('btn-search')) {
          $('body').addClass('fullscreen');
          $('html').addClass('fullscreen');
        }
      }
      $(this).parent().toggleClass('categorymode');
      $('.menu-categories-wrapper', '.menucard-listing').toggleClass('visible');

      showHeaderFullScreen();
    } else {
      $('.menu-categories-wrapper', '.menucard-listing').toggleClass('visible');
      resetView($(this));

      if (utilityScrollTop > windowScrollTop) {
        $(window).scrollTop(utilityScrollTop);
      } else {
        $(window).scrollTop(windowScrollTop);
      }
    }
  });

  $('.btn-close').click(function (event) {
    event.preventDefault();
    event.stopPropagation();

    var $inputElVal = $('#irestaurantsearchstring-middle').val();

    // hides no results text, clears search text input, resets restaurant search (Filterpanel.js)
    clearSearch();
    // step 2 only
    // if filter active and no results: show no result text
    // elseif the filter isn't active, remove active class from filter button and subnavigation (.btn-filter, .subnavigation)
    utilityClearSearch();
    processHash();
    if ($inputElVal && $inputElVal.length > 0) {
      app.setState({
        restaurantSearchString: ''
      });
      $('.utility-middle-bar .btn-close').removeClass('active');
      $('.utility-middle-bar > .subnav-wrapper').addClass('searchmode');
      if ($('body').hasClass('ubh-searchmode')) {
        return;
      }
    }

    toggleBottomHeader('close', false);
    resetView($(this));
    if ($('.restaurants-map').hasClass('mapmode-panel')) {
      toggleMap(false);
    }
    // If this is step 2, trigger the stickyKitchenType to make sure the kitchen scroller is still in the right position
    if (isStep2()) {
      stickyKitchenType();
    }
  });

  $('.btn.btn-back').click(function (event) {
    returnToList(event);
  });

  $(window).on('resize', function () {
    if ($(document.body).hasClass('supplementary') || $(document.body).hasClass('step1')) {
      return;
    }

    var ua = navigator.userAgent;
    var isNativeAndroid = ua.indexOf('Mozilla/5.0') > -1 && ua.indexOf('Android') > -1 && ua.indexOf('AppleWebKit') > -1;

    if (ua.match(/iPad/i) || ua.match(/iPhone/i)) {
      return;
    }

    if (initOffsetHeight === document.body.offsetHeight && isNativeAndroid) {
      return;
    }

    if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape')) {
      toggleBottomHeader('resizeToDesktop', false);
      resetView();
      toggleMap(false);
      toggleLocationPanel(true);
      $('header .subnavigation').css({ zIndex: '' });
      $('header').removeClass('small');
    } else if (!$('body').hasClass('fullscreen')) {
      if (!$('html').hasClass('touch')) {
        var _headerHeight = $('body').is('.is-restaurant-list, .step3') ? 226 : 290;
        if ($(window).scrollTop() < _headerHeight) {
          toggleLocationPanel(true);
        } else {
          toggleLocationPanel(false);
        }
      }
      if ($('.subnav-wrapper').hasClass('basketmode')) {
        $(document.body).addClass('fullscreen');
      }
    }
  });
});

function returnToList(event) {
  event.stopPropagation();

  if ($('.subnav-wrapper').hasClass('mapmode')) {
    event.preventDefault();
    resetView();
    toggleMap(false);
    goToListView();
    stickyKitchenType();
  }
}

function toggleMap(showMap) {
  $('header').removeClass('hideheader');
  var $body = $('body');
  if ($body.hasClass('step2') || $body.hasClass('step3') || $body.hasClass('step4')) {
    $('.listing-inner').removeClass('hideheader');
  }

  if (showMap) {
    // Activate the map
    if (!map) {
      map = new CustomMap();
      map.init();
    } else {
      map.showMarkers();
    }

    $body.addClass('fullscreen');
    $('html').addClass('fullscreen');
    // for some reason in firefox subnavigation keeps subnavigation scrolling class which makes it
    // stick at the top of the screen so removing this class will fix it.
    $('.subnavigation').removeClass('subnavigation-scrolling');

    resizeMap();
  } else {
    stickyKitchenType();
    $('.subnav-wrapper').removeClass('mapmode');
    $('.restaurants-map').removeClass('mapmode-panel');
    $('.filter-wrapper').removeAttr('style');
    if (map) {
      map.reset();
      map.prev_marker = null;
    }
  }
}

function resizeMap() {
  var $mapCanvas = $('#map-canvas');
  // Found the google map canvas
  if ($mapCanvas.length > 0) {
    var innerHeight = 0;

    // The position of the map canvas is in _Map.scss - .mapmode-panel
    if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape')) {
      // Above and on 1004px
      // Above landscape, the header should be visible
      var $topBar = $('.topbar');
      var $subHeader = $('.subheader');
      innerHeight += $topBar.outerHeight();
      innerHeight += $subHeader.outerHeight();
    } else {
      // Below landscape, the bottom navigation bar
      var $bottomBar = $('.utility-bottom-bar');
      innerHeight += $bottomBar.outerHeight();
    }

    $mapCanvas.css({
      height: $(window).height() - innerHeight
    });
  }
}

// Only try to resize the map in step 2
$(window).on('resize', function () {
  if (isStep2()) {
    resizeMap();
  }
});

function showHeaderFullScreen() {
  if (isStep2()) {
    console.log('Step2 not use showHeaderFullScreen');
    return;
  }
  toggleLocationPanel(false);
}

function utilityClearSearch() {
  if (!isStep2()) {
    return;
  }

  if (isFilterActive() && getRestaurantCount() === 0) {
    $('.restaurant_noresults').show();
  } else if (!isFilterActive()) {
    $('.btn-filter', '.subnavigation').removeClass('active');
  }
}

function resetView() {
  var $filtercontent = $('.restaurants-filter');
  var $body = $('body');
  if (typeof basket !== 'undefined' && ($body.hasClass('step3') || $body.hasClass('step4'))) {
    window.basket.closeProductComment(null, basket.selectedProductCommentId, true);
  }

  $body.removeClass('fullscreen');
  $('html').removeClass('fullscreen');
  $('#toTop').show();

  $('.menu-categories-wrapper', '.menucard-listing').removeClass('visible');
  $filtercontent.removeClass('filtermode-panel');

  if (isStep2()) {
    $body.removeClass('ubh-mapmode');
    $('.restaurants-map').removeClass('mapmode-panel');
    $('.restaurants.restaurantlist').show();
  } else if ($(document.body).hasClass('step3')) {
    $('.menucard').show();
  }

  if ($body.hasClass('myaccountpages') || $body.hasClass('landingpages') || $body.hasClass('servicepages') || $body.hasClass('seopages')) {
    $('#dropdown-location-panel').css('display', '');
  }
}

/**
 *
 * Refactored event handlers
 *
 */

Helper.ready(function () {
  if (document.querySelector('.js-restaurants-filter')) {
    window.addEventListener('scroll', function () {
      return StickyPanel();
    });
  }
});
/* global $ */
$(document).ready(function () {
  var pos = 0;

  $(document).on('click', '.steps-btn-backward', function () {
    var mainelement = $(this).parent();
    var stepswrapper = $(mainelement).find('.steps-wrapper');
    var totalsteps = stepswrapper.attr('data-steps');

    pos = StepsRetrieveCurrent(mainelement) - 1;
    if (pos < 0) pos = totalsteps - 1;

    StepsMoveContent(mainelement, pos, stepswrapper);
    return false;
  });

  $(document).on('click', '.steps-btn-forward', function () {
    var mainelement = $(this).parent();
    var stepswrapper = $(mainelement).find('.steps-wrapper');
    var totalsteps = stepswrapper.attr('data-steps');

    pos = StepsRetrieveCurrent(mainelement) + 1;
    if (pos > totalsteps - 1) pos = 0;

    StepsMoveContent(mainelement, pos, stepswrapper);
    return false;
  });

  $('.steps-slider-dots-wrap span').bind('click', function (e) {
    var pos = $('.steps-slider-dots-wrap span').index(this);
    if (pos > 2) pos = pos - 3;
    var mainelement = $(this).parent().parent();
    var stepswrapper = $(mainelement).find('.steps-wrapper');
    var totalsteps = stepswrapper.attr('data-steps');

    if (pos > totalsteps - 1) pos = 0;

    StepsMoveContent(mainelement, pos, stepswrapper);
    return false;
  });

  var StepsMoveContent = function StepsMoveContent(mainelement, pos, stepswrapper) {
    stepswrapper.attr('class', 'listbox-boxes steps-wrapper number-of-steps-3').addClass('align-step' + pos);
    StepsUpdateCurrent(mainelement, pos);
  };

  var StepsRetrieveCurrent = function StepsRetrieveCurrent(steps) {
    var stepdots = $('.steps-slider-dots-wrap', steps);
    var i = 0;
    var selected = false;

    $('span', stepdots).each(function () {
      if ($(this).hasClass('steps-slider-dot-active') === true) {
        selected = i;
      }
      i++;
    });
    return selected;
  };

  var StepsUpdateCurrent = function StepsUpdateCurrent(mainelement, pos) {
    var stepdots = $('.steps-slider-dots-wrap', mainelement);
    var i = 0;

    $('span', stepdots).each(function () {
      var spans = $(this);
      $(spans).removeClass().addClass('steps-slider-dots');

      if (i === pos) {
        $(spans).addClass('steps-slider-dot-active');
      }
      i++;
    });
  };
});
/* global $ */
$(document).ready(function () {
  $(document).on('click', '.lightbox-close', function () {
    closeLightbox();
  });

  $(document).keyup(function (e) {
    if (e.keyCode === 27) {
      closeLightbox();
    }
  });
});

function closeLightbox() {
  $('#lightbox').remove();
  $('#lightbox_deliveryswitch').hide();
  $('#main').removeClass('lightbox-opened');

  if ($('body').hasClass('stop-scroll')) {
    $('body').removeClass('stop-scroll');
  }
}
/* global $ */
$(document).ready(function () {
  $('#tabs').on('click', 'li', function (event) {
    event.preventDefault();
    $('#tabs li').removeClass('active');
    var tabContents = $('.tab_content');
    tabContents.removeClass('visible');
    $(event.currentTarget).addClass('active');
    var name = event.currentTarget.id.replace('tab_', '');
    var tabContent = $('#' + name);
    tabContent.addClass('visible');
  });

  $('#tabslider-btn-forward').click(function () {
    var tabs = $('#tabs');
    var activeTab = tabs.find('li.active');
    var nextTab = activeTab.next().length ? activeTab.next() : tabs.find('li:first-child');
    activeTab.removeClass('active');
    nextTab.addClass('active');
    movetab(nextTab);
  });

  $('#tabslider-btn-backward').click(function () {
    var tabs = $('#tabs');
    var activeTab = tabs.find('li.active');
    var nextTab = activeTab.prev().length ? activeTab.prev() : tabs.find('li:last-child');

    activeTab.removeClass('active');
    nextTab.addClass('active');
    movetab(nextTab);
  });

  function movetab(tab) {
    var self = this;
    var tabWidth = tab.width();
    var screenWidth = $(window).width();
    var tabPosition = tab.position();

    var center = screenWidth / 2 - tabWidth / 2;
    var moveToCenter = tabPosition.left + 30 - center;

    $('#tabs').animate({
      left: -moveToCenter
    }, 300);
    activeContent(tab.attr('id'));
  }

  function activeContent(tab) {
    var name = tab.replace('tab_', '');
    var tabContent = $('#' + name);
    $('.tab_content', '.tabslider').removeClass('visible');
    tabContent.addClass('visible');
  }
});
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global
  $,
  app,
  AreaId,
  AreaString,
  basket,
  clearHash,
  clearSearch,
  closeLightbox,
  Cookies,
  currentRestaurant,
  format_price,
  getRestaurantCount,
  getUsersDeliveryAreaId,
  goToListView,
  itemsIndexed,
  processHash,
  resetFilter,
  resetView,
  RestaurantFilterInit,
  restaurants,
  RestaurantSortBy,
  RestaurantWeightDistance,
  selectFirstPossiblePaymentMethod,
  site,
  Takeaway,
  toggleBottomHeader,
  toggleMap,
  UpdateDeliveryCostInfo,
  updateFilters,
  updateLabels
*/

var Pickup = function () {
  var $body = void 0; // filled on init
  var $pickupAsideButton = void 0;
  var $deliveryAsideButton = void 0;

  var takeawayStatus = 'takeaway';
  var pickupStatus = 'pickup';
  var pickupSettings = {
    currentstatus: takeawayStatus
  };
  var switchActiveClass = 'switch-active';
  var pickupRestaurants = void 0;

  var isStep3 = function isStep3() {
    return $body.hasClass('step3');
  };

  var isStep4 = function isStep4() {
    return $body.hasClass('step4');
  };

  var getCurrentStatus = function getCurrentStatus() {
    return pickupSettings.currentstatus;
  };

  var isPickupStatus = function isPickupStatus() {
    return getCurrentStatus() === pickupStatus;
  };

  var isTakeawayStatus = function isTakeawayStatus() {
    return getCurrentStatus() === takeawayStatus;
  };

  var setNewStatus = function setNewStatus(status) {
    if (status !== pickupStatus) {
      status = takeawayStatus;
    }

    if (pickupSettings.currentstatus !== status) {
      var eventToBeFired = function eventToBeFired(event) {
        window.app.services.tracking.send({
          eventName: 'hasSwitchedDeliveryType',
          eventData: {
            countRestaurantShown: event.detail.visibleRestaurantsCount || getRestaurantCount()
          },
          searchData: {
            filterDeliveryType: status
          }
        });
        window.removeEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, eventToBeFired);
      };
      window.addEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, eventToBeFired);

      pickupSettings.currentstatus = status;
      return true;
    }
    return false;
  };

  var getPickupStatus = function getPickupStatus() {
    return pickupStatus;
  };

  var getTakeawayStatus = function getTakeawayStatus() {
    return takeawayStatus;
  };

  var checkCurrentStatus = function checkCurrentStatus() {
    if (site.pickup.enabled) {
      if (site.pickup.restaurant === true) {
        setNewStatus(pickupStatus);
      } else {
        var status = Cookies.get('pickup');
        if (typeof status !== 'undefined') {
          setNewStatus(status); // no check or update, triggers an error with basket, because it is loaded later
        }
      }
    }
  };

  var switchState = function switchState(state, callback) {
    $.ajax({
      method: 'POST',
      url: site.local + 'pickupstate',
      async: true,
      data: { deliverymethod: state }
    }).done(function (response) {
      if (typeof callback === 'function') {
        callback();
      }
    });
  };

  var updateContent = function updateContent(callback) {
    // Menu, basket content needs to be replaced in step3 and/or step4.
    if (hasBasket()) {
      $(document).delay(100).queue(function (el) {
        $.ajax({
          method: 'POST',
          url: window.location.href,
          data: {
            popup: true
          }
        }).done(function (data) {
          if (typeof callback === 'function') {
            callback(data);
          }
          return false;
        });
        el();
      });
    } else if (hasRestaurants()) {
      if (typeof callback === 'function') {
        callback();
      }
      return false;
    }
  };

  var handleStep2Switch = function handleStep2Switch() {
    if (hasRestaurants()) {
      console.log('handle step 2 switch');

      clearSearch();
      resetStep2();
      updateContent(function () {
        updateStep2({ addDistanceRating: false });
      });
    }
  };

  var handlePickupUI = function handlePickupUI() {
    if (isPickupStatus()) {
      $('#bottom-switch-delivery-pickup').prop('checked', true);
      $pickupAsideButton.addClass(switchActiveClass);
      $deliveryAsideButton.removeClass(switchActiveClass);
      $('.basket-notification').removeClass('hidden').show();
      $('#delivery-costs-card').hide();
    } else {
      $('#bottom-switch-delivery-pickup').prop('checked', false);
      $pickupAsideButton.removeClass(switchActiveClass);
      $deliveryAsideButton.addClass(switchActiveClass);
      $('.basket-notification').hide();
      $('#delivery-costs-card').show();
    }
    if (isStep3() && Pickup.isTakeawayStatus()) {
      UpdateDeliveryCostInfo(); // created in MenuCard.js
    }
  };

  var showRestaurantUnsupportedDeliveryMethodError = function showRestaurantUnsupportedDeliveryMethodError(deliveryMethod, errors) {
    if (errors.restaurantSupportedDeliveryType === undefined) {
      return false;
    }

    $('#deliveryswitch-title').html(currentRestaurant.Translations.error);
    var defaultText = currentRestaurant.Translations.pickupRestaurantUnavailableTitle.replace('{restaurant}', currentRestaurant.Name);
    if (deliveryMethod === Takeaway.DeliveryMethod.Type.Delivery) {
      defaultText = currentRestaurant.Translations.deliveryRestaurantUnavailableTitle.replace('{restaurant}', currentRestaurant.Name);
    }
    $('#default-text').html(defaultText);

    // Generate back to step2 uri
    var url = site.local;

    // If there is no deliveryAreaId, go to step 1
    // the restaurant delivery area id is added in the TakeawayController in parseRestaurantData()
    var deliveryAreaIdFound = false;
    if (basket.restaurant.deliveryAreaId !== null && typeof basket.restaurant.deliveryAreaId !== 'undefined') {
      url += basket.restaurant.deliveryAreaId;
      deliveryAreaIdFound = true;
    } else {
      var usersDeliveryAreaId = getUsersDeliveryAreaId();
      if (usersDeliveryAreaId !== null) {
        url += usersDeliveryAreaId;
        deliveryAreaIdFound = true;
      }
    }

    if (!deliveryAreaIdFound) {
      console.log('Error, no delivery area id found');
    }

    var $showOverview = $('#showoverview');

    $showOverview.attr('href', url);
    $showOverview.show();

    $('#lightbox_deliveryswitch').show();

    return true;
  };

  var showBasketError = function showBasketError(deliveryMethod, errors) {
    var isError = false;
    if (errors.unsupportedDeliveryType.length > 0) {
      var unsupportedText = currentRestaurant.Translations.pickupProductUnavailableText;
      if (deliveryMethod === Takeaway.DeliveryMethod.Type.Delivery) {
        unsupportedText = currentRestaurant.Translations.deliveryProductUnavailableText;
      }
      $('#unsupported-text').html(unsupportedText);

      $.each(errors.unsupportedDeliveryType, function (index, product) {
        var entry = $('#unsupported-template').clone();
        entry.removeAttr('id');
        entry.text(product.productName);
        $('#list-unsupported').append(entry.show());
      });
      isError = true;
    }

    if (errors.priceDifference.length > 0) {
      var priceMisMatchedText = currentRestaurant.Translations.pickupPriceMismatchedText;
      if (deliveryMethod === Takeaway.DeliveryMethod.Type.Delivery) {
        priceMisMatchedText = currentRestaurant.Translations.deliveryPriceMismatchedText;
      }
      $('#pricemismatched-text').html(priceMisMatchedText);

      $.each(errors.priceDifference, function (index, product) {
        var price = format_price(product.price, currentRestaurant.Currency);
        var pricePickup = format_price(product.pricePickup, currentRestaurant.Currency);
        var text = '<s>' + price + '</s>\n<b>' + pricePickup + '</b>';
        if (deliveryMethod === Takeaway.DeliveryMethod.Type.Delivery) {
          text = '<s>' + pricePickup + '</s>\n<b>' + price + '</b>';
        }

        var entry = $('#pricemismatched-template').clone();
        entry.removeAttr('id');
        entry.html(product.productName + '\n' + text);
        $('#list-pricemismatched').append(entry.show());
      });
      isError = true;
    }
    console.log('showBasketError isError : ' + isError);

    if (isError) {
      var $toggleState = $('#togglestate');
      $toggleState.attr('href', site.local + currentRestaurant.Urls.Restaurant);
      $toggleState.show();
      $('#lightbox_deliveryswitch').show();
    }
    return isError;
  };

  // No longer called, rebuilding the basket ui is problematic
  var updateStep3Or4 = function updateStep3Or4() {
    setTimeout(function () {
      // $('#' + id).removeClass('blow')
      updateContent(function (html) {
        // do something with the content
        if (isStep3()) {
          updateStep3(html);
        } else if (isStep4()) {
          updateStep4(html);
        }

        handlePickupUI();
      });
    }, 500);
  };

  var resetStep2 = function resetStep2() {
    clearHash();
    resetFilter();
    goToListView();
    updateFilters();
    if (app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
      return;
    }
    updateLabels();
  };
  var addPickupRestaurantsToRestaurantList = function addPickupRestaurantsToRestaurantList(_ref) {
    var _restaurants;

    var pickupRestaurants = _ref.pickupRestaurants;

    var restaurantsToAdd = pickupRestaurants.filter(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
          pickupRestaurantId = _ref3[0];

      return (
        // Only add the restaurants that are not already in the list
        !restaurants.find(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 1),
              restaurantId = _ref5[0];

          return restaurantId === pickupRestaurantId;
        })
      );
    }).map(function (restaurant) {
      // Needs calculation from location
      restaurant[6] = getDistance(restaurant);
      // Pickup only restaurant so don't show in delivery mode
      restaurant[26] = true;
      return restaurant;
    });
    console.warn(restaurantsToAdd);
    // Add items to the Global restaurants Array
    (_restaurants = restaurants).splice.apply(_restaurants, [restaurants.length, 0].concat(_toConsumableArray(restaurantsToAdd)));
  };

  var updateStep2 = function updateStep2(_ref6) {
    var _ref6$addDistanceRati = _ref6.addDistanceRating,
        addDistanceRating = _ref6$addDistanceRati === undefined ? false : _ref6$addDistanceRati;

    if (hasRestaurants()) {
      $(window).scrollTop(0);
      if (Array.isArray(pickupRestaurants) === false && isPickupStatus()) {
        var pickupRequestLocation = typeof AreaString !== 'undefined' ? AreaString : AreaId;

        $.ajax({
          url: site.aPath + 'xHttp/restaurant/pickup/' + pickupRequestLocation,
          type: 'POST',
          headers: {
            'Takeaway-Accept-Language': site.language
          },
          dataType: 'json',
          success: function success(data) {
            pickupRestaurants = data;
            if (!addDistanceRating && restaurants) {
              restaurants.forEach(function (restaurant) {
                restaurant[24] -= RestaurantWeightDistance(restaurant[6]);
              });
            }
            if (app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
              addPickupRestaurantsToRestaurantList({ pickupRestaurants: pickupRestaurants });
            } else {
              CombinePickupRestaurants(pickupRestaurants);
            }
            // resort restaurant listing
            toggleMap(false);
            RestaurantFilterInit({ addDistanceRating: true });
            processHash();
          }
        });
      } else {
        toggleMap(false);
        RestaurantFilterInit({ addDistanceRating: false });
        processHash();
      }
    }
  };

  // Only called in updateStep3or4, but that function is no longer called
  var updateStep3 = function updateStep3(html) {
    var containerSelector = '.js-basket-container';
    // console.log('step3 html', html)
    // filter the basket container
    var basketContainer = $(html).find(containerSelector);
    if (basketContainer.length === 1) {
      // Please check if there is NO functionality coupled in elements in this html
      // It will be removed
      $(containerSelector).html(basketContainer.html());
    }
    basket.calculateTotalPrice();
    basket.updateUI();
  };

  // Only called in updateStep3or4, but that function is no longer called
  var updateStep4 = function updateStep4(html) {
    // console.log('step 4 html', html)
    var containerSelector = '.js-basket-container';
    // console.log('step3 html', html)
    // filter the basket container
    var basketContainer = $(html).find(containerSelector);
    if (basketContainer.length === 1) {
      // Please check if there is NO functionality coupled in elements in this html
      // It will be removed
      $(containerSelector).html(basketContainer.html());
    }
    basket.calculateTotalPrice();
    basket.updateUI();
    selectFirstPossiblePaymentMethod();
  };

  var hasRestaurants = function hasRestaurants() {
    return typeof restaurants !== 'undefined';
  };

  var hasBasket = function hasBasket() {
    return document.querySelector('.basket') !== null;
  };

  var updateToCurrentState = function updateToCurrentState() {
    var skipReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (hasBasket()) {
      var currentStatus = isTakeawayStatus() ? Takeaway.DeliveryMethod.Type.Delivery : Takeaway.DeliveryMethod.Type.Pickup;
      var errors = basket.switchDeliveryType(currentStatus, false);
      $('#default-text').empty();
      $('#unsupported-text').empty();
      $('#pricemismatched-text').empty();
      $('#list-unsupported').empty();
      $('#list-pricemismatched').empty();
      $('#togglestate').hide();
      $('#showoverview').hide();

      console.log('errors', errors);

      if (errors !== undefined && (showRestaurantUnsupportedDeliveryMethodError(currentStatus, errors) || showBasketError(currentStatus, errors))) {
        // Put status back
        setNewStatus(isTakeawayStatus() ? getPickupStatus() : getTakeawayStatus());
        return;
      }

      resetView();

      // If everything is allright, we can continue
      switchState(getCurrentStatus(), function () {
        updatePickupCookie();

        if (skipReload === false) {
          window.location.reload();
        }
        // updateStep3Or4() // fires handlePickupUI, doesn't work, has flawed logic for recalculation when switching between pickup and delivery
      });
    }

    if (hasRestaurants()) {
      handleStep2Switch();
      toggleBottomHeader('bottomSwitch', false);
      handlePickupUI();
      updatePickupCookie();
    }
  };

  var updatePickupCookie = function updatePickupCookie() {
    Cookies.set('pickup', getCurrentStatus(), { path: '/', secure: true });
  };

  var updateSortingTo = function updateSortingTo(sortName) {
    console.log('updating sorting to ' + sortName);
    // By default switch to distance
    // Find the element and update the main value.
    var sortingContainers = document.body.querySelectorAll('.subnav-wrapper');
    if (sortingContainers.length > 0) {
      var defaultSortingElement = sortingContainers[0].querySelector('[data-name="' + sortName + '"] a');
      if (defaultSortingElement) {
        window.app.setState({ listSortBy: sortName });
        $('.sorting-select').val(sortName);
        RestaurantSortBy();
        sortingContainers.forEach(function (container) {
          var button = container.querySelector('.btn-sorting-text');
          if (button) {
            button.innerHTML = defaultSortingElement.innerHTML;
          }
        });
      }
    }
  };

  var updateToPickup = function updateToPickup() {
    var skipReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (setNewStatus(getPickupStatus())) {
      updateSortingTo('distance');
      updateToCurrentState(skipReload);
    }
  };

  var updateToDelivery = function updateToDelivery() {
    var skipReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (setNewStatus(getTakeawayStatus())) {
      // To support V3, we need to remove "?shipping=pickup" from url when switching to "delivery" mode
      var urlParams = new URLSearchParams(window.location.search);

      if (urlParams.has('shipping')) {
        urlParams.delete('shipping');
        var urlParamsString = urlParams.toString() ? '?' + urlParams.toString() : '';
        window.history.pushState('', document.title, window.location.pathname + urlParamsString);
      }

      updateSortingTo('default');
      updateToCurrentState(skipReload);
    }
  };

  var CombinePickupRestaurants = function CombinePickupRestaurants(pickuprestaurants) {
    var _loop = function _loop(x) {
      var pickupRestaurant = pickuprestaurants[x];
      var filtered = restaurants.filter(function (restaurant) {
        return restaurant[0] === pickupRestaurant[0];
      })[0];

      if (filtered === undefined) {
        restaurants.push(pickupRestaurant);
        pickupRestaurant[6] = getDistance(pickupRestaurant);
        // [26] is Is Disabled for delivery
        // To not adjust the number of the delivery restaurants
        // We don't want to show the restaurants in that list
        pickupRestaurant[26] = false;
        CombinePickupRestaurantsHTML(pickupRestaurant);

        // fuse needs the new restaurants.
        itemsIndexed.push({
          id: '#irestaurant' + pickupRestaurant[0],
          name: pickupRestaurant[4],
          status: pickupRestaurant[18]
        });
      }
    };

    // search if pickuprestaurants is already available in restaurants
    // if so, remove it from pickuprestaurants array
    // if not, we should add it later on

    for (var x in pickuprestaurants) {
      _loop(x);
    }
  };

  var CombinePickupRestaurantsHTML = function CombinePickupRestaurantsHTML(restaurant) {
    var SingleRestaurantTemplate = $('#SingleRestaurantTemplateIdentifier')[0].outerHTML;
    SingleRestaurantTemplate = SingleRestaurantTemplate.replace('SingleRestaurantTemplateIdentifier', 'irestaurant' + restaurant[0]);
    SingleRestaurantTemplate = RestaurantHtmlReview(restaurant, SingleRestaurantTemplate);
    SingleRestaurantTemplate = RestaurantHtmlDistance(restaurant, SingleRestaurantTemplate);
    SingleRestaurantTemplate = RestaurantHtmlDetails(restaurant, SingleRestaurantTemplate);

    $('.restaurantlist').append(SingleRestaurantTemplate);
  };

  var RestaurantHtmlReview = function RestaurantHtmlReview(restaurant, html) {
    var reviewScore = restaurant[29];

    if (reviewScore.count > 0 && reviewScore.score > 0) {
      if (reviewScore.score > 89) {
        reviewScore.score++;
        html = html.replace('{{RestaurantReviewScore}}', reviewScore.score);
      }
      html = html.replace('{{RestaurantReviewAmount}}', '(' + reviewScore.count + ')');
      html = html.replace('review-stars-disabled', '');
    } else {
      html = html.replace('{{RestaurantReviewScore}}', '100');
      html = html.replace('{{RestaurantReviewAmount}}', '');
    }

    return html;
  };

  var RestaurantHtmlDetails = function RestaurantHtmlDetails(restaurant, html) {
    var RestaurantInfo = restaurant[30];

    RestaurantInfo.logo = '<img class="restlogo" data-src="' + RestaurantInfo.logo + '" border="0" alt="restaurant logo" />';
    var replace = {
      '{{RestaurantName}}': RestaurantInfo.name,
      '{{RestaurantCategories}}': RestaurantInfo.categories,
      '{{RestaurantLogo}}': RestaurantInfo.logo,
      '{{RestaurantUrl}}': RestaurantInfo.url
    };
    return replaceInString(html, Object.keys(replace), Object.values(replace));
  };

  var RestaurantHtmlDistance = function RestaurantHtmlDistance(restaurant, html) {
    var distance = restaurant[6];
    if (distance > 0) {
      var label = getDistance(distance);
      html = html.replace('{{RestaurantDistance}}', label);
    }
    return html;
  };

  var replaceInString = function replaceInString(replaceString, find, replace) {
    var regex = void 0;
    for (var i = 0, l = find.length; i < l; i++) {
      regex = new RegExp(find[i], 'g');
      replaceString = replaceString.replace(regex, replace[i]);
    }
    return replaceString;
  };

  var init = function init() {
    var $document = $(document);
    $body = $('body');
    $pickupAsideButton = $('#pickup-aside-button');
    $deliveryAsideButton = $('#delivery-aside-button');

    checkCurrentStatus();

    /**
     * Mobile (Bottom) Switch Button
     */
    $('#bottom-switch-delivery-pickup').change(function (e) {
      if (window.app.services.headerService.pickupDisabled(true) && e.target.checked === true) {
        e.target.checked = false;
      }

      e.preventDefault();
      var newStatus = e.target.checked === true ? pickupStatus : takeawayStatus;
      if (setNewStatus(newStatus)) {
        var updateSortingValue = 'default';
        if (newStatus === pickupStatus) {
          updateSortingValue = 'distance';
        }
        updateSortingTo(updateSortingValue);
        updateToCurrentState();
      }
    });

    /**
     * Web Desktop (Aside) Switch Buttons
     */
    $pickupAsideButton.click(function (e) {
      if (window.app.services.headerService.pickupDisabled(true)) {
        return;
      }

      e.preventDefault();
      updateToPickup();
    });

    $deliveryAsideButton.click(function (e) {
      e.preventDefault();
      updateToDelivery();
    });

    // todo: check this, should still be in use
    $document.on('click', '.pickupnotification #togglestate', function (e) {
      e.preventDefault();
      console.log('firing from popup');
      var newStatus = isTakeawayStatus() ? getPickupStatus() : getTakeawayStatus();
      switchState(newStatus, function () {
        closeLightbox();
        resetView();
        window.location.reload();
        // Pickup.updateStep3or4() // error updating the basket when switching between pickup and delivery
      });
      return false;
    });

    $document.on('click', '.pickupnotification #showoverview', function (e) {
      e.preventDefault();
      console.log('firing showoverview link from popup');
      var newStatus = isTakeawayStatus() ? getPickupStatus() : getTakeawayStatus();
      var href = $(this).attr('href');
      console.log('firing showoverview new status', newStatus);
      switchState(newStatus, function () {
        setNewStatus(newStatus);
        updatePickupCookie();
        window.location.href = href;
      });
      return false;
    });

    if (isStep4()) {
      // check if the delivery type is right, if not disabled the button
      var validDeliveryTypes = [];
      if (currentRestaurant.Pickup === 2) {
        // No idea why this is in the property Pickup
        validDeliveryTypes = [].concat(_toConsumableArray(validDeliveryTypes), [Takeaway.DeliveryMethod.Type.Delivery, Takeaway.DeliveryMethod.Type.Pickup]);
      } else {
        validDeliveryTypes.push(currentRestaurant.Pickup);
      }

      var status = Cookies.get('pickup');
      var intStatus = status === 'pickup' ? 3 : 1;
      if (validDeliveryTypes.indexOf(intStatus) === -1) {
        // invalid
        var btn = $('.checkout-orderbutton-btn').find('input[type=submit]');
        btn.addClass('btn-disabled');
        btn.removeAttr('onclick');
      }
    }

    handlePickupUI();
  };

  return {
    init: init,
    updateStep2: updateStep2,
    updateStep3Or4: updateStep3Or4,
    showBasketError: showBasketError,
    hasRestaurants: hasRestaurants,
    hasBasket: hasBasket,
    isPickupStatus: isPickupStatus,
    isTakeawayStatus: isTakeawayStatus,
    setNewStatus: setNewStatus,
    getPickupStatus: getPickupStatus,
    getTakeawayStatus: getTakeawayStatus,
    getCurrentStatus: getCurrentStatus,
    updateToDelivery: updateToDelivery
  };
}();

$(document).ready(function () {
  var $body = $('body');

  Pickup.init();

  // do not execute pickup stuff if we're on chainpages
  if ($body.hasClass('chains') || $body.hasClass('seopages') || $body.hasClass('servicepages') || $body.hasClass('myaccountpages')) {
    return false;
  }

  updateFilters();
  if (!app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
    updateLabels();
  }

  if (Pickup.hasRestaurants() !== true) {
    // No restaurants found, stop executing
    return false;
  }

  if (Pickup.isPickupStatus()) {
    // only run this if pickup is selected but we're also located on step2 with listing available
    Pickup.updateStep2({ addDistanceRating: true });
  }
});

var getDistance = function getDistance(km) {
  // also used in Filterpanel
  // Set default value
  var distance = 0;
  var distanceLabel = 'km';

  if (km > 5) km = 5;
  if (km > 0) {
    if (km < 1) {
      distanceLabel = 'm';
      distance = Math.floor(km * 1000);
    } else {
      distanceLabel = 'km';
      distance = km.toLocaleString(site.distance.localeFormat, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
  }
  return distance + ' ' + distanceLabel;
};
/* global $, site, Cookies, AreaId, site */
/*

  SET AID COOKIE if available
  -----
  For proper usage of back button on Step3/menucard
  we need to set a cookie to create a fake back button based on users entry flow
  AID cookie should only be used if there is no postcode zipcode set

 */

$(document).ready(function () {
  if (typeof AreaId !== 'undefined' && site.cc != 239) {
    Cookies.set('AID', AreaId, { path: site.path, secure: true });
  }
});
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global
  $,
  _i18n,
  app,
  AreaId,
  categoriesindex,
  Cookies,
  currency,
  favoriteText,
  format_price,
  formatQueryPostcode,
  getDistance,
  getOpeningStatus,
  getPreorderTime,
  Helper,
  initLazyLoad,
  moment,
  OpeningStatus,
  Pickup,
  polygons,
  resetView,
  restaurants,
  scrollToElement,
  searchRestaurant,
  SingleRestaurantHtml,
  site,
  toggleBottomHeader,
  xmlRequest,
*/

var visibleRestaurantIds = [];
var restaurantId;
var restaurantDOM;

// Constants for showing which ID is used.
var RESTAURANT_ID = 0;
var CATEGORY_IDS = 1; // eslint-disable-line no-unused-vars
var SUB_CATEGORY_IDS = 2;
var NAME = 4;
var DISTANCE = 6;
var REVIEW = 7;
var PRICE_INDEX = 9;
var MINIMUM_DELIVERY = 10;
var INDEX_KEY = 11;
var OPENING_STATUS = 12;
var IS_FAVORITE = 13;
var DELIVERY_COST = 14;
var HAS_ONLINE_PAYMENT = 15;
var LATITUDE = 16;
var LONGITUDE = 17;
var IS_PICKUP = 18;
var AVERAGE_DELIVERY_TIME = 19;
var OPENING_TIMES_TAKEAWAY = 20;
var EXCEPTION_TIMES_TAKEAWAY = 21;
var OPENING_TIMES_PICKUP = 22;
var EXCEPTION_TIMES_PICKUP = 23;
var RANKING = 24;
var POLYGON = 25;
var IS_DISABLED_FOR_DELIVERY = 26;
var RESTAURANT_STATUS = 28; // resto actief / gesloten / disabled / closed
var RESTAURANT_INFO_AND_LINKS = 30;
var DISCOUNTS_TOTAL = 31;
var HAS_MEAL_DEALS = 34;
var DISCOUNTS_WEEK = 35;
var RESTAURANT_LABEL = 36;
var RESTAURANT_SLOGAN = 37;
var RESTAURANT_ADDRESS = 38;
var REVIEW_COUNT = 39;
var HAS_STAMPCARDS = 40;
var FREE_DELIVERY_FROM = 41;
var ALLOWED_SORTING_METHODS = ['default', 'review', 'distance', 'popularity', 'deliverycosts', 'averageprice', 'minimumorderamount', 'alphabet', 'deliverytime'];

// Constants for Price Range Filter
var PRICE_RANGE_STRUCTURE = {
  HASH: 'PriceRange',
  OPTIONS: {
    LOW: 'low',
    MEDIUM: 'medium',
    HIGH: 'high'
  },
  CLASS_NAMES: {
    buttons: 'js-pricerange-toggle',
    active: 'switch-active'
  }
};

var getPreOrderTimeLabel = function getPreOrderTimeLabel(openingTimes, exceptionTimes) {
  var _app$getState = app.getState(),
      normalizedServerTime = _app$getState.normalizedServerTime;

  var currentOpeningTimes = getCurrentOpeningTimes(normalizedServerTime, openingTimes, exceptionTimes);

  for (var x in currentOpeningTimes) {
    var openingTime = currentOpeningTimes[x];
    var timeStatus = window.checkTimeBetween(openingTime, normalizedServerTime.time, normalizedServerTime.time);
    if (timeStatus === window.TimeStatus.Before) {
      return moment(openingTime.starttime, 'HH:mm:ss').format('HH:mm');
    }
  }
};

var renderRestaurantHTML = function renderRestaurantHTML(restaurant) {
  var isPickup = Pickup.isPickupStatus();

  // Restaurant attributes
  var restaurantObject = {
    address: restaurant[RESTAURANT_ADDRESS],
    averageDeliveryTime: restaurant[AVERAGE_DELIVERY_TIME],
    categories: restaurant[RESTAURANT_INFO_AND_LINKS].categories,
    distance: getDistance(restaurant[DISTANCE]),
    exceptionTimesDelivery: restaurant[EXCEPTION_TIMES_TAKEAWAY],
    exceptionTimesPickup: restaurant[EXCEPTION_TIMES_PICKUP],
    id: restaurant[RESTAURANT_ID],
    isFavorite: restaurant[IS_FAVORITE],
    isPreOrderInOneHour: restaurant.isPreOrderInOneHour,
    label: restaurant[RESTAURANT_LABEL],
    logo: restaurant[RESTAURANT_INFO_AND_LINKS].logo,
    minimumDeliveryCost: restaurant[DELIVERY_COST],
    minimumOrderValue: restaurant[MINIMUM_DELIVERY],
    name: (restaurant[NAME] || '').replace(/\\(.)/mg, '$1'),
    openingStatus: restaurant[OPENING_STATUS],
    openingTimesDelivery: restaurant[OPENING_TIMES_TAKEAWAY],
    openingTimesPickup: restaurant[OPENING_TIMES_PICKUP],
    preOrderLabelDelivery: getPreOrderTimeLabel(restaurant[OPENING_TIMES_TAKEAWAY], restaurant[EXCEPTION_TIMES_TAKEAWAY]),
    preOrderLabelPickup: getPreOrderTimeLabel(restaurant[OPENING_TIMES_PICKUP], restaurant[EXCEPTION_TIMES_PICKUP]),
    promoted: restaurant.promoted,
    reviewAmount: restaurant[REVIEW_COUNT],
    reviewScore: restaurant[REVIEW],
    slogan: restaurant[RESTAURANT_SLOGAN],
    title: restaurant[NAME],
    url: restaurant[RESTAURANT_INFO_AND_LINKS].url,
    urlAsAttribute: app.services.feature.isActive(app.enums.FEATURES.VERSION_3_SUPPORT) ? 'data-url="' + restaurant[RESTAURANT_INFO_AND_LINKS].url + '"' : 'onclick="document.location=\'' + restaurant[RESTAURANT_INFO_AND_LINKS].url + '\';return false;"',
    freeDeliveryFrom: restaurant[FREE_DELIVERY_FROM]

    // Translation texts
  };var textsObject = {
    closedForDelivery: SingleRestaurantHtml.closedForDelivery,
    closedForPickup: SingleRestaurantHtml.closedForPickup,
    estimationAbbreviation: SingleRestaurantHtml.estimation_abbreviation,
    freeDelivery: SingleRestaurantHtml.freedelivery,
    minimumDeliveryCost: SingleRestaurantHtml.mindelivery,
    minutesAbbreviation: SingleRestaurantHtml.minutes_abbreviation,
    newRestaurant: SingleRestaurantHtml.newRestaurantBalloon,
    openFrom: SingleRestaurantHtml.openfrom,
    openFromAbbreviation: SingleRestaurantHtml.openfromAbbr,
    promoted: SingleRestaurantHtml.promotedBalloon,
    freeDeliveryFrom: SingleRestaurantHtml.freeDeliveryFrom

    // Enum for Restaurant Opening Status
  };var OPENING_STATUSES = {
    CLOSED: 0,
    OPEN: 1,
    PRE_ORDER: 2
  };

  var renderOpenLabel = function renderOpenLabel(_ref) {
    var averageDeliveryTime = _ref.averageDeliveryTime;
    return '\n    <div class="avgdeliverytime avgdeliverytimefull open">' + averageDeliveryTime + textsObject.minutesAbbreviation + '</div>\n    <div class="avgdeliverytime avgdeliverytimeabbr openAbbr">' + averageDeliveryTime + textsObject.minutesAbbreviation + '</div>\n  ';
  };

  var renderPreOrderLabel = function renderPreOrderLabel(_ref2) {
    var preOrderLabelDelivery = _ref2.preOrderLabelDelivery,
        preOrderLabelPickup = _ref2.preOrderLabelPickup;

    if (isPickup) {
      return '<div class="open openpickup">' + textsObject.openFrom + ' ' + preOrderLabelPickup + '</div>';
    } else {
      return '\n        <div class="avgdeliverytime avgdeliverytimefull open">' + textsObject.openFrom + ' ' + preOrderLabelDelivery + '</div>\n        <div class="avgdeliverytime avgdeliverytimeabbr openAbbr">' + textsObject.openFromAbbreviation + ' ' + preOrderLabelDelivery + '</div>\n      ';
    }
  };

  var renderClosedLabelDelivery = function renderClosedLabelDelivery() {
    return '\n    <div class="avgdeliverytime avgdeliverytimefull open closed">' + textsObject.closedForDelivery + '</div>\n    <div class="avgdeliverytime avgdeliverytimeabbr openAbbr closed">' + textsObject.closedForDelivery + '</div>';
  };

  var renderClosedLabelPickup = function renderClosedLabelPickup() {
    return '\n    <div class="open openpickup closed">' + textsObject.closedForPickup + '</div>\n  ';
  };

  var renderDistanceLabel = function renderDistanceLabel(_ref3) {
    var distance = _ref3.distance;
    return '<div class="distance">' + distance + '</div>';
  };
  var renderAddressLabel = function renderAddressLabel(_ref4) {
    var address = _ref4.address;
    return '<div class="address">' + address + '</div>';
  };
  var renderPromotedLabel = function renderPromotedLabel(_ref5) {
    var id = _ref5.id;

    var _app$getState2 = app.getState(),
        listSortBy = _app$getState2.listSortBy;

    if (restaurant.promoted && listSortBy === 'default') {
      return '<div class="label-promoted js-label-promoted is-promoted">' + textsObject.promoted + '</div>';
    }
    return '';
  };

  var renderDeliveryBadge = function renderDeliveryBadge(_ref6) {
    var freeDeliveryFrom = _ref6.freeDeliveryFrom,
        id = _ref6.id;

    if (freeDeliveryFrom > 0.0) {
      return '<div class="free-from">' + textsObject.freeDeliveryFrom + ' ' + format_price(freeDeliveryFrom, currency) + '</div>';
    }
    return '';
  };

  var renderMinimumOrderValueLabel = function renderMinimumOrderValueLabel(_ref7) {
    var minimumOrderValue = _ref7.minimumOrderValue;
    return minimumOrderValue > 0 ? '<div class="min-order notranslate">' + textsObject.minimumDeliveryCost + ' ' + format_price(minimumOrderValue, currency) + '</div>' : '';
  };

  var renderDeliveryCostLabel = function renderDeliveryCostLabel(_ref8) {
    var minimumDeliveryCost = _ref8.minimumDeliveryCost;
    return minimumDeliveryCost > 0 ? '<div class="delivery-cost js-delivery-cost notranslate">' + format_price(minimumDeliveryCost, currency) + '</div>' : '<div class="delivery-cost free-delivery-cost js-delivery-cost notranslate">' + textsObject.freeDelivery + '</div>';
  };

  var renderRestaurantLabelsDelivery = function renderRestaurantLabelsDelivery(restaurantObject) {
    if (restaurantObject.openingStatus === OPENING_STATUSES.OPEN && !restaurantObject.isPreOrderInOneHour) {
      return '\n          ' + renderOpenLabel(restaurantObject) + '\n          ' + renderDeliveryCostLabel(restaurantObject) + '\n          ' + renderMinimumOrderValueLabel(restaurantObject) + '\n          ' + renderPromotedLabel(restaurantObject) + '\n          ' + renderDeliveryBadge(restaurantObject) + '\n        ';
    } else if (restaurantObject.openingStatus === OPENING_STATUSES.PRE_ORDER || restaurantObject.isPreOrderInOneHour) {
      return '\n          ' + renderPreOrderLabel(restaurantObject) + '\n          ' + renderDeliveryCostLabel(restaurantObject) + '\n          ' + renderMinimumOrderValueLabel(restaurantObject) + '\n          ' + renderPromotedLabel(restaurantObject) + '\n          ' + renderDeliveryBadge(restaurantObject) + '\n        ';
    } else if (restaurantObject.openingStatus === OPENING_STATUSES.CLOSED) {
      return '\n          ' + renderClosedLabelDelivery() + '\n        ';
    } else {
      return '';
    }
  };

  var renderRestaurantLabelsPickup = function renderRestaurantLabelsPickup(restaurantObject) {
    if (restaurantObject.openingStatus === OPENING_STATUSES.OPEN && !restaurantObject.isPreOrderInOneHour) {
      return '\n        ' + renderDistanceLabel(restaurantObject) + '\n        ' + renderAddressLabel(restaurantObject) + '\n        ' + renderPromotedLabel(restaurantObject) + '\n      ';
    } else if (restaurantObject.openingStatus === OPENING_STATUSES.PRE_ORDER || restaurantObject.isPreOrderInOneHour) {
      return '\n        ' + renderPreOrderLabel(restaurantObject) + '\n        ' + renderDistanceLabel(restaurantObject) + '\n        ' + renderAddressLabel(restaurantObject) + '\n        ' + renderPromotedLabel(restaurantObject) + '\n      ';
    } else if (restaurantObject.openingStatus === OPENING_STATUSES.CLOSED) {
      return '\n          ' + renderClosedLabelPickup() + '\n        ';
    } else {
      return '';
    }
  };

  var deliveryRender = function deliveryRender(restaurantObject) {
    return '\n    <div class="delivery js-delivery-container">\n      ' + renderRestaurantLabelsDelivery(restaurantObject) + '\n    </div>\n  ';
  };

  var pickupRender = function pickupRender(restaurantObject) {
    return '\n    <div class="pickup wrapper-open-distance ' + (restaurantObject.openingStatus === OPENING_STATUSES.CLOSED ? 'closed-restaurant' : '') + '">\n      ' + renderRestaurantLabelsPickup(restaurantObject) + '\n    </div>\n  ';
  };

  var renderBalloon = function renderBalloon(_ref9) {
    var isFavorite = _ref9.isFavorite,
        label = _ref9.label;

    if (isFavorite) {
      return '<div class="baloon-container restaurantlabel is_favorite" data-label="' + favoriteText + '"></div>';
    } else if (label) {
      return '<div class="baloon-container restaurantlabel ' + label + '" data-label="' + textsObject.newRestaurant + '"></div>';
    } else {
      return '<div class="baloon-container restaurantlabel"></div>';
    }
  };

  var renderMicrodata = function renderMicrodata(_ref10) {
    var reviewAmount = _ref10.reviewAmount,
        reviewScore = _ref10.reviewScore,
        title = _ref10.title;
    return '\n    <div itemProp="review" itemScope="" itemType="http://schema.org/Review">\n      <meta itemProp="name" content="' + title + '"/>\n      <span itemProp="reviewRating" itemScope="" itemType="http://schema.org/Rating">\n          <meta itemProp="worstRating" content="1">\n          <meta itemProp="ratingValue" content="' + Math.floor(reviewScore / 2) + '"/>\n          <meta itemProp="bestRating" content="5"/>\n          <meta itemProp="reviewCount" content="' + reviewAmount + '"/>\n      </span>\n    </div>\n  ';
  };

  return '\n    <div\n      class="restaurant js-restaurant"\n      id="irestaurant' + restaurantObject.id + '"\n      data-id="' + restaurantObject.id + '"\n      itemscope=""\n      itemtype="http://schema.org/Restaurant"\n      ' + restaurantObject.urlAsAttribute + '>\n      <div class="logowrapper">\n        ' + renderBalloon(restaurantObject) + '\n        <div class="logo-n ' + (restaurantObject.label ? 'has_tip' : '') + '">\n          <a href="' + restaurantObject.url + '" class="img-link">\n            <img class="restlogo" src="/assets/images/restaurantlisting/placeholder.png"\n              data-src="' + restaurantObject.logo + '"\n              alt="' + restaurantObject.title + ' - ' + restaurantObject.slogan + '"\n            >\n          </a>\n        </div>\n        <div class="review-rating">\n          <div class="review-stars notranslate">\n            <span\n              style="width: ' + restaurantObject.reviewScore * 10 + '%;"\n              class="review-stars-range">\n            </span>\n          </div>\n          <span class="rating-total">(' + restaurantObject.reviewAmount + ')</span>\n          <span class="rating-total-short">(' + (restaurantObject.reviewAmount > 1000 ? (restaurantObject.reviewAmount / 1000).toFixed(1).replace(/\.0+$/, '') + 'k' : restaurantObject.reviewAmount) + ')</span>\n        </div>\n      </div>\n      <div class="detailswrapper">\n        <h2 class="restaurantname">\n          <a class="restaurantname notranslate" href="' + restaurantObject.url + '" itemprop="name">' + restaurantObject.name + '</a>\n        </h2>\n        ' + (!document.querySelector('body').classList.contains('chains') ? renderMicrodata(restaurantObject) : '') + '\n        <div class="kitchens">\n          <span>' + restaurantObject.categories + '</span>\n        </div>\n        <div class="bottomwrapper details">\n          ' + (Pickup.isPickupStatus() ? pickupRender(restaurantObject) : deliveryRender(restaurantObject)) + '\n        </div>\n      </div>\n    </div>\n  ';
};

// init Restaurants Filter
$(document).ready(function () {
  var sortBy = ALLOWED_SORTING_METHODS.includes(Cookies.get('sortby')) ? Cookies.get('sortby') : ALLOWED_SORTING_METHODS[0];
  window.app.setState({
    listSortBy: sortBy,
    lastScrollTop: 0,
    lastClickedFilter: false,
    visibleRestaurantIds: []
  });

  if (isStep2()) {
    // on page scroll make sure the selected kitchen type is visible
    $(document).scroll(function () {
      stickyKitchenType();
      makeKitchenTypeVisible();
    });

    // Make sure the kitchen bar stays in top when resizing
    $(window).on('resize', function () {
      stickyKitchenType();
    });
  }

  // Find the sorting middle
  var $sortingMiddle = document.querySelector('.js-btn-sorting-middle');
  if ($sortingMiddle) {
    // Find the relevant sorting item
    var $sortingItem = $sortingMiddle.querySelector('[data-name="' + sortBy + '"]');
    var $buttonSorting = $sortingMiddle.querySelector('.btn-sorting-text');
    if ($sortingItem && $buttonSorting) {
      // get the text value
      $buttonSorting.textContent = $sortingItem.textContent.trim();
    }
  }
  // Same for sorting aside (mobile)
  var $sortingAside = document.querySelector('.js-btn-sorting-aside');
  if ($sortingAside) {
    var $sortingItemAside = $sortingAside.querySelector('[data-name="' + sortBy + '"]');
    var $buttonSortingAside = $sortingAside.querySelector('.btn-sorting-text');
    if ($sortingItemAside && $buttonSortingAside) {
      // get the text value
      $buttonSortingAside.textContent = $sortingItemAside.textContent.trim();
    }
  }

  /**
   * The below value sets the timeout for the call to /api/ranking/{location}
   * Please do not change this without permission from Ugur Demiroz, as it affects the loading
   * of the restaurants. The value is the amount of miliseconds after which we will ignore the response of the API.
   */
  var rankingApiData = null;
  try {
    rankingApiData = JSON.parse(document.querySelector('.js-restaurant-results').innerHTML);
  } catch (e) {
    console.log('Can\'t fetch Fastly ranking data');
  }

  /* REMARKS-UGUR : use function isStep2 */
  if (isStep2() && typeof window.AreaId !== 'undefined' && window.AreaId !== '') {
    if (window.scooberRankingEnabled && !rankingApiData) {
      var apiRankingTimeout = 500;
      timeout({
        milliseconds: apiRankingTimeout,
        promise: fetch(site.aPath + 'api/ranking/' + window.AreaId)
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        console.info('[RANKING-API] Call successful, response', response);
        /**
         * The API returns the following data
         *
         * @param response.status
         * @param response.code
         * @param response.message
         * @param response.data
         * @param response.data.restaurantId
         * @param response.data.ranking
         * @param response.errors
         */

        // The API can return an error, so we need to make sure the call is successful
        if (response.status === 'success') {
          addRankingValues(response.data);
          addDynamicDeliveryCosts(response.data);
        } else {
          console.warn('[RANKING-API] The data received from the API was not successful', response.errors);
        }
      }).catch(function (error) {
        return console.warn('[RANKING-API] ' + error.toString());
      }).finally(function () {
        // only init filtering if pickup is not selected
        // pickup switch already inits RestaurantFilterInit()
        if (typeof restaurants !== 'undefined' && Pickup.isPickupStatus() === false) {
          RestaurantFilterInit({ addDistanceRating: true });
          processHash();
        }
      });
    } else {
      if (rankingApiData && rankingApiData.data) {
        addRankingValues(rankingApiData.data);
        addDynamicDeliveryCosts(rankingApiData.data);
      }
      // only init filtering if pickup is not selected
      // pickup switch already inits RestaurantFilterInit()
      if (typeof restaurants !== 'undefined' && Pickup.isPickupStatus() === false) {
        RestaurantFilterInit({ addDistanceRating: true });
        processHash();
      }
    }
  }

  // only init restaurantfilter if we have a proper restaurants array
  // disable filtering for specific step2  pages, like chainpages because those pages are actually missing the filter itself
  // if ($('body').hasClass('chains')) restaurants = null;
  // if (typeof restaurants !== "undefined" || restaurants !== null) {
  if (typeof restaurants !== 'undefined' && document.querySelector('body').classList.contains('chains')) {
    return false;
  }
});

/* Main functions */

/**
 * Returns total number of restaurants based on delivery/pickup selection
 *
 * @returns {number}
 */
var getRestaurantCount = function getRestaurantCount() {
  return app.getState().visibleRestaurantIds.length;
};

var RestaurantFilterInit = function RestaurantFilterInit(_ref11) {
  var _ref11$addDistanceRat = _ref11.addDistanceRating,
      addDistanceRating = _ref11$addDistanceRat === undefined ? true : _ref11$addDistanceRat;

  if ($('body').hasClass('chains') && $('body').hasClass('landingpages')) {
    return false;
  }
  console.log('RestaurantFilter');
  var classSelector = {
    jsRestaurantList: 'js-restaurantlist',
    restaurantClosed: 'restaurant__closed',
    restaurantOpen: 'restaurant__open',
    restaurantPreOrder: 'restaurant__pre-order',
    restaurantsPickup: 'restaurants__pickup'
  };

  var _app$getState3 = app.getState(),
      normalizedServerTime = _app$getState3.normalizedServerTime;

  var updateRestaurantObject = function updateRestaurantObject(_ref12) {
    var restaurant = _ref12.restaurant,
        addDistanceRating = _ref12.addDistanceRating,
        pickupStatus = _ref12.pickupStatus,
        isPostalCodeSearchResult = _ref12.isPostalCodeSearchResult,
        favoriteRestaurants = _ref12.favoriteRestaurants;

    var objectId = restaurant[RESTAURANT_ID];

    // Favorite restaurants update
    restaurant[IS_FAVORITE] = favoriteRestaurants.includes(objectId);

    /* BEGIN Polygon search update */
    var isPolygonSearchEnabled = window.app.services.search.isPolygonSearchEnabled({
      pickupStatus: pickupStatus,
      isPostalCodeSearch: isPostalCodeSearchResult,
      usersLastSearchHasGeolocation: window.app.services.user.location,
      restaurantHasPolygon: polygons !== false && polygons[objectId] // Be sure if the restaurant has a polygon
    });

    if (isPolygonSearchEnabled) {
      // isPointInPolygons() returns polygon object if true
      var polygonId = window.app.services.polygon.isPointInPolygons(window.app.services.user.location, polygons[objectId]);

      if (polygonId !== false) {
        var _polygons$objectId$po = polygons[objectId][polygonId],
            costs = _polygons$objectId$po.costs,
            min = _polygons$objectId$po.min,
            from = _polygons$objectId$po.from;

        var deliveryCosts = parseFloat(costs);
        var restaurantDdc = parseFloat(restaurant.dynamicDeliveryCosts);

        if (isNaN(restaurantDdc) === false) {
          deliveryCosts += restaurantDdc;
        }
        // Set 'polygon' property to true
        restaurant[POLYGON] = true;
        // If delivery cost or min order is set, update DOM
        if (deliveryCosts > 0 || min > 0) {
          restaurant[DELIVERY_COST] = deliveryCosts;
          restaurant[MINIMUM_DELIVERY] = min;
          // @TODO this function manipulates the DOM,
          // and should be moved to UpdateDocumentDom not be here
          setRestaurantDeliveryCosts(min, deliveryCosts, from, objectId);
        }
      } else {
        // If user is not in polygon, hide it by updating DOM
        restaurant[IS_DISABLED_FOR_DELIVERY] = true;
      }
    }
    /* END Polygon search update */

    /* BEGIN Opening/Exception times update */
    var RestaurantTimes = restaurant[OPENING_TIMES_TAKEAWAY];
    var RestaurantExceptionTimes = restaurant[EXCEPTION_TIMES_TAKEAWAY];

    // if pickup is selected, use pickup times to calculate open/closed
    if (Pickup.isPickupStatus() === true) {
      RestaurantTimes = restaurant[OPENING_TIMES_PICKUP];
      RestaurantExceptionTimes = restaurant[EXCEPTION_TIMES_PICKUP];
    }
    /* END Opening/Exception times update */

    /* BEGIN Location-related update */
    // default distance
    var distance = 50;
    // Calculate the distance between the restaurant and the user
    if (window.app.services.user.location) {
      distance = window.app.services.polygon.distance({
        x: restaurant[LONGITUDE],
        y: restaurant[LATITUDE]
      }, window.app.services.user.location);
    }
    /* END Location-related update */

    /* BEGIN Opening status update update */
    // no need to do any calculations if restaurant is closed via TMS
    var status = void 0;

    if (restaurant[RESTAURANT_STATUS] === 0) {
      status = OpeningStatus.Closed;
    } else {
      status = getOpeningStatus(normalizedServerTime, RestaurantTimes, RestaurantExceptionTimes);
    }

    // update restaurant array with newly fetched data
    restaurant[DISTANCE] = distance;
    restaurant[OPENING_STATUS] = status;
    if (addDistanceRating) {
      restaurant[RANKING] += RestaurantWeightDistance(distance);
    }
    /* END Opening status update update */
  };

  var updateRestaurantDOM = function updateRestaurantDOM(_ref13) {
    var $restaurantNode = _ref13.$restaurantNode,
        closedText = _ref13.closedText,
        normalizedServerTime = _ref13.normalizedServerTime,
        restaurant = _ref13.restaurant;

    var RestaurantOpenState = restaurant[OPENING_STATUS];
    var emptyStr = '';

    var classSelectorDistance = '.distance';
    var classSelectorFavorite = '.baloon-container';
    var classSelectorOpen = '.open';
    var classSelectorOpenAbbr = '.openAbbr';
    var classSelectorOpenAndOpenAbbr = '.open, .openAbbr';
    var classSelectorPickupDetails = '.wrapper-open-distance';

    var classClosed = 'closed';
    var classClosedPickup = 'closed-restaurant';
    /**
     * .restaurant-hide is used for hiding SEARCH results (Search.js)
     * .restaurant-disable is used for actually "removing" restaurants that should never show up, for e.g. when they
     * are outside of a polygon.
     *
     * SO NEVER CHANGE .restaurant-disable TO .restaurant-hide
     */
    var classDisabled = 'restaurant-disable';
    var classFavorite = 'is_favorite';
    var classFavoriteBalloon = 'balloon_new';
    var classFavoriteTip = 'has_tip';
    var classOpenPickup = 'openpickup';
    var classNoText = 'no-text';

    if (restaurant[IS_DISABLED_FOR_DELIVERY] === true) {
      $restaurantNode.classList.add(classDisabled);
    }

    if (restaurant[IS_FAVORITE]) {
      var $favoriteDetails = $restaurantNode.querySelector(classSelectorFavorite);
      if ($favoriteDetails) {
        $favoriteDetails.classList.remove(classFavoriteBalloon, classFavoriteTip);
        $favoriteDetails.classList.add(classFavorite);
        $favoriteDetails.setAttribute('data-label', favoriteText);
      }
    }

    switch (RestaurantOpenState) {
      case OpeningStatus.Closed:
        // @TODO combine these class selectors And move logic to same place
        $restaurantNode.classList.add(classSelector.restaurantClosed);
        $restaurantNode.querySelectorAll(classSelectorOpenAndOpenAbbr).forEach(function (target) {
          target.classList.add(classClosed);
          target.textContent = closedText;
        });

        // update pickup details
        var $pickupDetails = $restaurantNode.querySelector(classSelectorPickupDetails);
        if ($pickupDetails) {
          $pickupDetails.classList.add(classClosedPickup);
        }
        break;
      case OpeningStatus.Open:
        $restaurantNode.classList.add(classSelector.restaurantOpen);
        $restaurantNode.querySelectorAll(classSelectorOpenAndOpenAbbr).forEach(function (target) {
          if (Pickup.isTakeawayStatus() === false) {
            // Pickup is selected: Don't show estimation (copy/pasted Iwan's check)
            target.classList.remove(classOpenPickup); // Hide the time icon shown by ":before" pseudo
            target.classList.add(classNoText); // Without this, distance text shifts 2em right

            target.textContent = emptyStr; // Overwrite the text echoed by PHP
          } else {
            target.classList.remove(classClosed);

            target.textContent = (SingleRestaurantHtml.estimation_abbreviation ? SingleRestaurantHtml.estimation_abbreviation + ' ' : '') + restaurant[AVERAGE_DELIVERY_TIME] + SingleRestaurantHtml.minutes_abbreviation;
          }
        });
        break;
      case OpeningStatus.PreOrder:
        $restaurantNode.classList.add(classSelector.restaurantPreOrder);
        var openingTimes = restaurant[OPENING_TIMES_TAKEAWAY];
        var exceptionTimes = restaurant[EXCEPTION_TIMES_TAKEAWAY];

        if (Pickup.isTakeawayStatus() === false) {
          // if pickup is selected, use pickup times to calculate open/closed
          openingTimes = restaurant[OPENING_TIMES_PICKUP];
          exceptionTimes = restaurant[EXCEPTION_TIMES_PICKUP];
        }

        var preOrderTime = getPreorderTime(normalizedServerTime, openingTimes, exceptionTimes);
        var preOrderLabel = moment(preOrderTime.starttime, 'HH:mm:ss').format('HH:mm');

        $restaurantNode.querySelectorAll(classSelectorOpen).forEach(function ($openSelector) {
          $openSelector.classList.remove(classClosed);
          $openSelector.textContent = SingleRestaurantHtml.openfrom + ' ' + preOrderLabel;
        });

        $restaurantNode.querySelectorAll(classSelectorOpenAbbr).forEach(function ($openSelector) {
          $restaurantNode.querySelector(classSelectorOpenAbbr).classList.remove(classClosed);
          $restaurantNode.querySelector(classSelectorOpenAbbr).textContent = SingleRestaurantHtml.openfromAbbr + ' ' + preOrderLabel;
        });
        break;
    }

    var $distanceDetails = $restaurantNode.querySelector(classSelectorDistance);
    if ($distanceDetails) {
      $distanceDetails.textContent = getDistance(restaurant[DISTANCE]);
    }
  };
  // Cache cookie value as it is a slow check
  var postCode = Cookies.get('postcode');
  // searchString may be like '7522 dc', so remove spaces and make it uppercase
  var searchString = Cookies.get('searchstring');
  searchString = typeof searchString === 'string' ? searchString.replace(/\s/g, '').toUpperCase() : '';
  // prevent backbutton being pressed and using outdated lat lng data to calculate polygons
  if (site.cc === '45') {
    if (typeof postCode !== 'undefined') {
      if (AreaId !== formatQueryPostcode(postCode)) {
        polygons = false;
      }
    }
  }

  var isPostalCodeSearchResult = window.app.services.search.isPostalCodeSearch({
    postalCode: postCode,
    countryCode: site.iso,
    searchString: searchString
  });

  var pickupStatus = Pickup.getCurrentStatus();
  var closedText = SingleRestaurantHtml.closedForPickup;
  var $restaurantList = document.querySelector('.' + classSelector.jsRestaurantList);
  if ($restaurantList) {
    if (Pickup.isPickupStatus()) {
      $restaurantList.classList.add(classSelector.restaurantsPickup);
    } else {
      closedText = SingleRestaurantHtml.closedForDelivery;
      $restaurantList.classList.remove(classSelector.restaurantsPickup);
    }
  }

  [classSelector.restaurantOpen, classSelector.restaurantPreOrder, classSelector.restaurantClosed].forEach(function (className) {
    return [].concat(_toConsumableArray($restaurantList.querySelectorAll('.' + className))).forEach(function ($element) {
      return $element.classList.remove(className);
    });
  });

  var favoriteRestaurants = window.app.services.user.getFavoriteRestaurants();
  window.app.setState({
    favorite: favoriteRestaurants
  });
  for (var i = 0; i < restaurants.length; i++) {
    // @TODO: Try to encapsulate these globals within function scope
    restaurantId = restaurants[i][RESTAURANT_ID];
    var $restaurantNode = document.querySelector('#irestaurant' + restaurantId);

    // @TODO: Try to call these functions once
    // @TODO: Try to call all read operations at the beginning together
    // @TODO: Try to call all write operations at the end together
    // restaurants object manipulation
    updateRestaurantObject({
      restaurant: restaurants[i],
      addDistanceRating: addDistanceRating,
      pickupStatus: pickupStatus,
      isPostalCodeSearchResult: isPostalCodeSearchResult,
      favoriteRestaurants: favoriteRestaurants
    });
    if (!app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
      // restaurants DOM manipulation
      updateRestaurantDOM({
        $restaurantNode: $restaurantNode,
        closedText: closedText,
        normalizedServerTime: normalizedServerTime,
        restaurant: restaurants[i]
      });
    }
  }

  var groupRestaurants = function groupRestaurants() {
    // Group restaurants by favorite status
    var restaurantsByFavoriteStatus = restaurantService.groupRestaurantsByProp(restaurants, IS_FAVORITE);
    var normalRestaurants = restaurantsByFavoriteStatus[false] || [];
    var restaurantsFavorite = restaurantsByFavoriteStatus[true] || [];

    // Group normal & favorite restaurants by opening status and update the state
    var normalRestaurantsByOpeningStatus = restaurantService.groupRestaurantsByProp(normalRestaurants, OPENING_STATUS);
    var favoriteRestaurantsByOpeningStatus = restaurantService.groupRestaurantsByProp(restaurantsFavorite, OPENING_STATUS);

    // Re-group PreOrder restaurants by 1 hour: Less than 1 hour and the rest
    var restaurantsPreOrder = normalRestaurantsByOpeningStatus[OpeningStatus.PreOrder] || [];
    var restaurantsPreOrderGroupedByOpeningSoon = Helper.groupBy(restaurantsPreOrder, restaurantService.isOpeningSoon);
    var restaurantsPreOrderInOneHour = restaurantsPreOrderGroupedByOpeningSoon[true] || [];
    var restaurantsPreOrderLater = restaurantsPreOrderGroupedByOpeningSoon[false] || [];

    /**
     * Product wants to mix Open and PreOrderInOneHour restaurants (@see FED-13014).
     * That's why we manually 'open' PreOrderInOneHour restaurants so that sorting methods will work correctly.
     * For now we'll set restaurantsPreOrderInOneHour in state for debugging BUT WON'T USE THEM IN RENDERING.
     * Don't forget that Product may change their mind and ask to order them as usual.
     */
    restaurantsPreOrderInOneHour.forEach(function (rest) {
      rest.isPreOrderInOneHour = true;
      rest[OPENING_STATUS] = OpeningStatus.Open;
    });
    window.app.setState({
      restaurantsOpen: [].concat(_toConsumableArray(normalRestaurantsByOpeningStatus[OpeningStatus.Open] || []), _toConsumableArray(restaurantsPreOrderInOneHour || [])),
      restaurantsPreOrderInOneHour: restaurantsPreOrderInOneHour,
      restaurantsPreOrderLater: restaurantsPreOrderLater,
      restaurantsClosed: normalRestaurantsByOpeningStatus[OpeningStatus.Closed] || [],
      restaurantsFavoriteOpen: favoriteRestaurantsByOpeningStatus[OpeningStatus.Open] || [],
      restaurantsFavoritePreOrder: favoriteRestaurantsByOpeningStatus[OpeningStatus.PreOrder] || [],
      restaurantsFavoriteClosed: favoriteRestaurantsByOpeningStatus[OpeningStatus.Closed] || []
    });
  };

  // Group restaurants by favorite status
  groupRestaurants();

  /**
   * This part below should be refactored
   */

  getPriceRanges(restaurants);

  RestaurantHash();
  RestaurantSortBy();

  // Update total restaurant count
  var restoCount = getRestaurantCount();
  Balloon(restoCount);

  var _window$app$getState = window.app.getState(),
      listSortBy = _window$app$getState.listSortBy;

  RestaurantVisible(listSortBy);
};

var RestaurantVisible = function RestaurantVisible(sortby) {
  $('#irestaurantlist').css('opacity', 1);
  $('#isorting-select').val(sortby);
  $('.restaurants-counter').removeClass('hidden');

  // Hide loading skeleton (shim)
  $('.js-skeleton-restaurants').hide();

  var counterLoading = document.querySelector('.js-restaurants-counter-loading');
  var counterContent = document.querySelector('.js-restaurants-counter-content');
  counterLoading.classList.add('hidden');
  counterContent.classList.remove('hidden');
};

var RestaurantHash = function RestaurantHash() {
  if (window.location.hash.length > 1) {
    processHash();
    var hashObject = _getHashObject();
    $('.btn-filter', '.subnavigation').addClass('active');
    $('.filter-reset-all').removeClass('reset-results-hidden');
    // Check if we need to show MealDeal Filter FED-5597
    if (hashObject.MealDeal) {
      $('.filter-label[data-type="MealDeal"]').parent().show();
    }
  } else if (typeof Pickup.getCurrentStatus() === 'undefined') {
    var restaurantHiddenCount = $('.restaurant-hide').length;
    if (restaurantHiddenCount === restaurants.length) {
      $('.filter-reset-all').removeClass('reset-results-hidden');
      $('.restaurant_noresults').show();
    } else if (restaurantHiddenCount !== 0 && restaurantHiddenCount !== restaurants.length) {
      $('.filter-reset-all').removeClass('reset-results-hidden');
    }
  }

  if (Pickup.getCurrentStatus() !== undefined) {
    var currentStatus = Pickup.isTakeawayStatus() ? 1 : 3;
    if (currentStatus === 1) {
      $('.nopickup').show();
    } else {
      $('.nopickup').hide();
    }
  }
  // with this we make sure that any previously selected kitchen type is visible
  makeKitchenTypeVisible();
};

var RestaurantSortBy = function RestaurantSortBy() {
  console.log('RestaurantSortBy');
  var sortmethods = {
    'default': defaultsort,
    'deliverytime': deliverytimesort,
    'review': reviewsort,
    'distance': distancesort,
    'popularity': popularitysort,
    'averageprice': averagepricesort,
    'deliverycosts': deliverycostssort,
    'minimumorderamount': minimumorderamountsort,
    'alphabet': alphabetsort,
    'hasonlinepayments': hasonlinepaymentsort

    /**
     * Get the restaurants' opening status from the state, sort accordingly and update the state. All the rest is
     * triviality and needs to be removed from this logic
     */
  };
  var _window$app$getState2 = window.app.getState(),
      listSortBy = _window$app$getState2.listSortBy,
      restaurantsOpen = _window$app$getState2.restaurantsOpen,
      restaurantsPreOrderInOneHour = _window$app$getState2.restaurantsPreOrderInOneHour,
      restaurantsPreOrderLater = _window$app$getState2.restaurantsPreOrderLater,
      restaurantsClosed = _window$app$getState2.restaurantsClosed,
      restaurantsFavoriteOpen = _window$app$getState2.restaurantsFavoriteOpen,
      restaurantsFavoritePreOrder = _window$app$getState2.restaurantsFavoritePreOrder,
      restaurantsFavoriteClosed = _window$app$getState2.restaurantsFavoriteClosed;

  console.log('listSortBy: ' + listSortBy);

  // If don't support the sorting method, exit
  if (!(listSortBy in sortmethods)) {
    return;
  }

  window.app.setState({
    restaurantsOpen: restaurantsOpen ? restaurantsOpen.sort(sortmethods[listSortBy]) : [],
    restaurantsPreOrderInOneHour: restaurantsPreOrderInOneHour ? restaurantsPreOrderInOneHour.sort(sortmethods[listSortBy]) : [],
    restaurantsPreOrderLater: restaurantsPreOrderLater ? restaurantsPreOrderLater.sort(sortmethods[listSortBy]) : [],
    restaurantsClosed: restaurantsClosed ? restaurantsClosed.sort(sortmethods[listSortBy]) : [],
    restaurantsFavoriteOpen: restaurantsFavoriteOpen ? restaurantsFavoriteOpen.sort(sortmethods[listSortBy]) : [],
    restaurantsFavoritePreOrder: restaurantsFavoritePreOrder ? restaurantsFavoritePreOrder.sort(sortmethods[listSortBy]) : [],
    restaurantsFavoriteClosed: restaurantsFavoriteClosed ? restaurantsFavoriteClosed.sort(sortmethods[listSortBy]) : []
  });

  restaurantService.UI.renderRestaurants();

  setSortRestaurantsDropdown(listSortBy);
  setSortRestaurantsCookie(listSortBy);
  if (!app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
    updatePromotedOnSort(listSortBy);
    updateLabels();
  }
  initLazyLoad();
};

var updatePromotedOnSort = function updatePromotedOnSort(sortedType) {
  if (sortedType !== 'default') {
    var promoted = document.querySelectorAll('.js-label-promoted.active, .js-label-promoted-pickup.active');

    for (var i = 0; i < promoted.length; i++) {
      promoted[i].classList.remove('active');
      promoted[i].classList.add('filtered');
    }
  } else {
    var _promoted = document.querySelectorAll('.js-label-promoted.filtered, .js-label-promoted-pickup.filtered');

    for (var _i = 0; _i < _promoted.length; _i++) {
      _promoted[_i].classList.remove('filtered');
      _promoted[_i].classList.add('active');
    }
  }
};

/**
 * @return {number}
 */
var RestaurantWeightDistance = function RestaurantWeightDistance(distance) {
  if (distance !== 999 && distance < 5.0) {
    var distanceweight = 50.0;
    // For Belgium, the nearby restaraurants have a weighted ratio of 25 instead of 50, because geo location is less accurate
    // if ($site_config['landCode']==3) var distanceweight = 25.0;
    var distanceplus = distanceweight - distance * (distanceweight / 5.0);

    if (distance > 0) {
      return distanceplus;
    }
    return 0;
  }
  return 0;
};

var setRestaurantDeliveryCosts = function setRestaurantDeliveryCosts(MinOrderAmount, DeliveryCosts, From, objectId) {
  if (Pickup.isTakeawayStatus() === false) {
    return false;
  }
  var $restaurantDOM = $('#irestaurant' + objectId);
  var restaurantDeliveryDOM = $restaurantDOM.find('.js-delivery-container');
  var restaurantHtmlMinimumOrderLabel = restaurantDeliveryDOM.find('.min-order');
  var PriceFormatted = format_price(MinOrderAmount, currency);
  // update minimum order amount dom

  if (MinOrderAmount > 0) {
    if (restaurantHtmlMinimumOrderLabel.length > 0) {
      restaurantHtmlMinimumOrderLabel.html(SingleRestaurantHtml.mindelivery + ' ' + PriceFormatted); // update div
    } else {
      restaurantDeliveryDOM.find('.js-delivery-cost').after('<div class="min-order">' + SingleRestaurantHtml.mindelivery + ' ' + PriceFormatted + '</div>'); // div doenst exists, append div
    }
  } else {
    restaurantDeliveryDOM.find('.min-order').remove();
  }

  // update delivery costs dom
  if (DeliveryCosts > 0 && From === 0) {
    var restaurantHtmlDeliveryLabel = restaurantDeliveryDOM.find('.js-delivery-cost');
    if (restaurantHtmlDeliveryLabel.length > 0) {
      var DeliveryCostsFormatted = format_price(DeliveryCosts, currency);
      restaurantHtmlDeliveryLabel.html(DeliveryCostsFormatted);
    } else {
      // update div
      restaurantDeliveryDOM.find('.open').after('<div class="delivery-cost">' + PriceFormatted + '</div>');
    } // div doesnt exists, append div
  } else {
    restaurantDeliveryDOM.find('.delivery').html(SingleRestaurantHtml.freedelivery);
  }
};

var setSortRestaurantsCookie = function setSortRestaurantsCookie(sorttype) {
  Cookies.set('sortby', sorttype, { path: site.path, secure: true });
};

var setSortRestaurantsDropdown = function setSortRestaurantsDropdown(sorttype) {
  $('.subnav-sortmode li').removeClass('active');
  $('.subnav-sortmode li[data-name=' + sorttype + ']').addClass('active');
};

/* start sort methods */
function reviewsort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[REVIEW] < elt2[REVIEW]) {
    return 1;
  }

  if (elt1[REVIEW] > elt2[REVIEW]) {
    return -1;
  }
  return alphabetsort(elt1, elt2);
}

function distancesort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[DISTANCE] < elt2[DISTANCE]) {
    return -1;
  }

  if (elt1[DISTANCE] > elt2[DISTANCE]) {
    return 1;
  }
  return alphabetsort(elt1, elt2);
}

function popularitysort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[8] < elt2[8]) {
    return 1;
  }

  if (elt1[8] > elt2[8]) {
    return -1;
  }
  return alphabetsort(elt1, elt2);
}

function averagepricesort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[9] < elt2[9]) {
    return -1;
  }

  if (elt1[9] > elt2[9]) {
    return 1;
  }
  return alphabetsort(elt1, elt2);
}

function deliverycostssort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[DELIVERY_COST] < elt2[DELIVERY_COST]) {
    return -1;
  }

  if (elt1[DELIVERY_COST] > elt2[DELIVERY_COST]) {
    return 1;
  }
  return alphabetsort(elt1, elt2);
}

function minimumorderamountsort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[MINIMUM_DELIVERY] < elt2[MINIMUM_DELIVERY]) {
    return -1;
  }

  if (elt1[MINIMUM_DELIVERY] > elt2[MINIMUM_DELIVERY]) {
    return 1;
  }
  return alphabetsort(elt1, elt2);
}

function alphabetsort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[NAME] < elt2[NAME]) {
    return -1;
  }

  if (elt1[NAME] > elt2[NAME]) {
    return 1;
  }
  return 0;
}

function hasonlinepaymentsort(elt1, elt2) {
  if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
    return 1;
  }

  if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
    return -1;
  }

  if (elt1[HAS_ONLINE_PAYMENT] == 0 && elt2[HAS_ONLINE_PAYMENT] != 0) {
    return 1;
  }

  if (elt2[HAS_ONLINE_PAYMENT] == 0 && elt1[HAS_ONLINE_PAYMENT] != 0) {
    return -1;
  }

  if (elt1[INDEX_KEY] < elt2[INDEX_KEY]) {
    return -1;
  }

  if (elt1[INDEX_KEY] > elt2[INDEX_KEY]) {
    return 1;
  }
  return 0;
}

function deliverytimesort(elt1, elt2) {
  if (elt1[OPENING_STATUS] === 0 && elt2[OPENING_STATUS] !== 0) {
    return 1;
  }

  if (elt2[OPENING_STATUS] === 0 && elt1[OPENING_STATUS] !== 0) {
    return -1;
  }

  if (elt1[AVERAGE_DELIVERY_TIME] > elt2[AVERAGE_DELIVERY_TIME]) {
    return 1;
  }

  if (elt1[AVERAGE_DELIVERY_TIME] < elt2[AVERAGE_DELIVERY_TIME]) {
    return -1;
  }
  return alphabetsort(elt1, elt2);
}

function defaultsort(elt1, elt2) {
  var standardSort = function standardSort(nextSort) {
    return function (elt1, elt2) {
      // favorites
      if (elt1[IS_FAVORITE] < elt2[IS_FAVORITE]) {
        return 1;
      }

      if (elt1[IS_FAVORITE] > elt2[IS_FAVORITE]) {
        return -1;
      }

      // open/preorder/closed
      var val1 = elt1[OPENING_STATUS];
      var val2 = elt2[OPENING_STATUS];
      if (val1 === 0) {
        val1 = 99;
      }

      if (val2 === 0) {
        val2 = 99;
      }

      if (val1 < val2) {
        return -1;
      }
      if (val1 > val2) {
        return 1;
      }
      return nextSort(elt1, elt2);
    };
  };
  var sortRankingPickup = function sortRankingPickup(elt1, elt2) {
    var rankingElt1 = elt1.rankingPickup || elt1[RANKING];
    var rankingElt2 = elt2.rankingPickup || elt2[RANKING];
    // weight
    if (rankingElt1 < rankingElt2) {
      return 1;
    }

    if (rankingElt1 > rankingElt2) {
      return -1;
    }

    return 0;
  };
  var sortRankingDelivery = function sortRankingDelivery(elt1, elt2) {
    // weight
    if (elt1[RANKING] < elt2[RANKING]) {
      return 1;
    }

    if (elt1[RANKING] > elt2[RANKING]) {
      return -1;
    }

    return 0;
  };
  var sortMethod = Pickup.isTakeawayStatus() ? standardSort(sortRankingDelivery) : standardSort(sortRankingPickup);
  return sortMethod(elt1, elt2);
}

/* end sort methods */

function setFavorite(favid, restfiltering, extrapath) {
  var thefavoicon, i, j, p;
  p = '/';
  if (extrapath) p = extrapath;
  for (i = 0; i < restaurants.length; i++) {
    if (restaurants[i][RESTAURANT_ID] === favid) {
      // toggle
      if (restaurants[i][IS_FAVORITE] === 1) {
        restaurants[i][IS_FAVORITE] = 0;
        xmlRequest(p + 'setFavorite.php', 'action=removefavorite&bid=' + favid, 'idummy');

        if (!restfiltering) {
          thefavoicon = document.getElementById('irestaurantfavo' + favid);
          if (thefavoicon) thefavoicon.src = '/images/icons/favo.png';
          RestaurantSortBy();
        } else {
          j = 1;
          // below should be fixed but im not touching this nasty code
          while (thefavoicon = document.getElementById('irestaurantfavo' + favid + '-' + j)) {
            // eslint-disable-line
            thefavoicon.src = '/images/icons/favo.png';
            j++;
          }
        }
        return false;
      } else {
        restaurants[i][IS_FAVORITE] = 1;
        xmlRequest(p + 'setFavorite.php', 'action=addfavorite&bid=' + favid, 'idummy');
        if (!restfiltering) {
          thefavoicon = document.getElementById('irestaurantfavo' + favid);
          if (thefavoicon) thefavoicon.src = '/images/icons/favo_selected.png';
          RestaurantSortBy();
          scrollToElement('irestaurantfavo' + favid);
        } else {
          j = 1;
          while (thefavoicon = document.getElementById('irestaurantfavo' + favid + '-' + j)) {
            // eslint-disable-line
            thefavoicon.src = '/images/icons/favo_selected.png';
            j++;
          }
        }
        return false;
      }
    }
  }
}

function toggleCategories(el) {
  var catid = $(el).data('subcats');
  var subcatids = categoriesindex[catid];

  if (!$(el).hasClass('manual-closed') && !$(el).hasClass('groupfilter-on')) {
    addHash('cat', subcatids);
  } else {
    removeHash('cat', subcatids);
  }
}

function toggleMainCategories(el, subcats) {
  var catid = void 0;
  if (el !== false) {
    catid = $(el).data('subcats');
  } else {
    catid = subcats;
  }
  var subcatids = categoriesindex[catid];

  clearHash();
  addHash('cat', subcatids);
  toggleCategoryHeading(catid);
}

function toggleCategoryHeading(catid) {
  var filterpanel = $('#filter-panel');

  $('.maincatmenu', filterpanel).removeClass('groupfilter-on');
  $('[data-subcats=' + catid + ']', filterpanel).addClass('groupfilter-on');
}

function clearHash() {
  // old code will work for every browser except IE.
  // history.pushState("", document.title, window.location.pathname
  //   + window.location.search);

  // new code will remove # in all browsers.
  var scrollV = void 0;
  var scrollH = void 0;
  var location = window.location;
  if ('pushState' in history) {
    history.pushState('', document.title, location.pathname + location.search);
  } else {
    // Prevent scrolling by storing the page's current scroll offset
    scrollV = document.body.scrollTop;
    scrollH = document.body.scrollLeft;

    location.hash = '';

    // Restore the scroll offset, should be flicker free
    document.body.scrollTop = scrollV;
    document.body.scrollLeft = scrollH;
  }
}

function Balloon(numberOfRestaurants) {
  if (typeof numberOfRestaurants === 'number' && numberOfRestaurants > 0) {
    $('.js-restaurants-counter').find('.restaurant-amount').html(numberOfRestaurants);
    $('.js-restaurants-counter').removeClass('hidden');
    $('.js-restaurants-counter-default').addClass('hidden');
  } else {
    $('.js-restaurants-counter').find('.restaurant-amount').html(0);
    $('.js-restaurants-counter').addClass('hidden');
    $('.js-restaurants-counter-default').removeClass('hidden');
  }

  if (Balloon.caller.name !== 'RestaurantFilterInit') {
    // Ugly fix to prevent firing multiple events
    window.dispatchEvent(new CustomEvent(app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, {
      detail: { visibleRestaurantsCount: numberOfRestaurants }
    }));
  }
}

function _getHashFromLocation() {
  var hash = window.location.hash.substring(1);
  if (hash.indexOf('!') === 0) hash = hash.substring(1);
  if (hash.indexOf('=&') === 0) hash = hash.substring(2);

  return hash;
}

function _getHashObject() {
  var hash = _getHashFromLocation();
  var hashObject = _parseQueryString(hash);

  for (var key in hashObject) {
    if (hashObject.hasOwnProperty(key) && hashObject[key].indexOf(',') !== -1) {
      hashObject[key] = hashObject[key].split(',');
    }
  }
  return hashObject;
}

function _parseQueryString(str) {
  var pairs = str.split('&');

  var result = {};
  pairs.forEach(function (pair) {
    pair = pair.split('=');
    result[pair[0]] = decodeURIComponent(pair[1] || '');
  });
  return result;
}

function _setHash(hashObject) {
  for (var key in hashObject) {
    if (hashObject.hasOwnProperty(key)) {
      if ($.isArray(hashObject[key])) {
        hashObject[key] = hashObject[key].join(',');
      }

      if (hashObject[key] === '') delete hashObject[key];
    }
  }

  var hash = $.param(hashObject);

  hash = hash.replace(/%2C/g, ',');
  history.replaceState(undefined, undefined, location.pathname + '#' + hash);
  processHash();
}

function toggleHash(key, value) {
  if (!$.isArray(value)) return toggleHash(key, [value]);

  var hashObject = _getHashObject();

  if (hashObject.hasOwnProperty(key) && !$.isArray(hashObject[key])) hashObject[key] = [hashObject[key]];

  if (hashObject.hasOwnProperty(key)) {
    $.each(value, function (i, v) {
      v = v.toString();
      if (hashObject[key].indexOf(v) === -1) {
        hashObject[key].push(v);
      } else {
        hashObject[key] = $.grep(hashObject[key], function (v2) {
          return v !== v2;
        });
      }
    });
  } else {
    hashObject[key] = value;
  }
  _setHash(hashObject);
}

function addHash(key, value) {
  if (!$.isArray(value)) return addHash(key, [value]);

  var hashObject = _getHashObject();

  if (hashObject.hasOwnProperty(key) && !$.isArray(hashObject[key])) hashObject[key] = [hashObject[key]];

  if (hashObject.hasOwnProperty(key)) {
    $.each(value, function (i, v) {
      v = v.toString();
      if (hashObject[key].indexOf(v) === -1) {
        hashObject[key].push(v);
      }
    });
  } else {
    hashObject[key] = value;
  }
  _setHash(hashObject);
}

function removeHash(key, value) {
  if (!$.isArray(value)) return removeHash(key, [value]);

  var hashObject = _getHashObject();

  if (hashObject.hasOwnProperty(key) && !$.isArray(hashObject[key])) hashObject[key] = [hashObject[key]];

  if (hashObject.hasOwnProperty(key)) {
    if (value[0] === 'reset') {
      delete hashObject[key];
    } else {
      $.each(value, function (i, v) {
        if (v == -1) {
          delete hashObject[key];
        } else if (hashObject[key].indexOf(v.toString()) !== -1) {
          hashObject[key] = $.grep(hashObject[key], function (v2) {
            return v2 != v;
          });
        }
      });
    }
    _setHash(hashObject);
  }
}

var getPriceRanges = function getPriceRanges(restaurantList) {
  var priceRangeRestaurants = {
    low: [],
    medium: [],
    high: []
  };

  var numberOfRestaurants = restaurantList.length;
  if (numberOfRestaurants) {
    var sortRestaurantsByPriceIndex = [].concat(_toConsumableArray(restaurantList)).sort(function (restaurant1, restaurant2) {
      return restaurant1[PRICE_INDEX] - restaurant2[PRICE_INDEX];
    });
    priceRangeRestaurants = sortRestaurantsByPriceIndex.reduce(function (accumulator, restaurant, index) {
      var percentPositionOfRestaurant = (index + 1) / numberOfRestaurants;
      if (percentPositionOfRestaurant <= 0.3) {
        accumulator.low.push(restaurant[RESTAURANT_ID]);
      } else if (percentPositionOfRestaurant < 0.7) {
        accumulator.medium.push(restaurant[RESTAURANT_ID]);
      } else {
        accumulator.high.push(restaurant[RESTAURANT_ID]);
      }
      return accumulator;
    }, priceRangeRestaurants);
  }

  window.app.setState({
    priceRangeRestaurants: priceRangeRestaurants
  });
};

function processHash() {
  var hashObject = _getHashObject();
  var Discount = !!hashObject.Discount;
  var Stampcards = !!hashObject.Stampcards;
  var MealDeal = !!hashObject.MealDeal;
  var Cuisines = hashObject.Cuisine || [];
  var Rating = hashObject.Rating || false;
  var PriceRangeUnfiltered = hashObject.PriceRange || false;
  var PriceRange = void 0;
  var MinimumOrderCosts = hashObject.MinimumOrderCosts || false;
  var DeliveryCosts = hashObject.DeliveryCosts || false;

  if (!$.isArray(Cuisines)) {
    Cuisines = [Cuisines];
  }
  if (PriceRangeUnfiltered !== false) {
    if (!Array.isArray(PriceRangeUnfiltered)) {
      PriceRangeUnfiltered = [PriceRangeUnfiltered];
    }
    PriceRange = PriceRangeUnfiltered.filter(function (option) {
      return Object.values(PRICE_RANGE_STRUCTURE.OPTIONS).includes(option);
    });
  }

  var _app$getState4 = app.getState(),
      lastClickedFilter = _app$getState4.lastClickedFilter;

  if (lastClickedFilter === 'Cuisine' && Cuisines && Cuisines.length > 0) {
    var $clickedElement = $('.filter-label[data-value=' + Cuisines + ']', '.filter-kitchen');
    if ($clickedElement.hasClass('filter-label-selected')) {
      $clickedElement.removeClass('filter-label-selected');
      Cuisines = [];
      removeHash('Cuisine', 'reset');
      if (window.location.hash === '' || window.location.hash === '#') {
        clearHash();
        resetFilter();
        processHash();
      }
    }
  }

  var allCuisines = $('.filter-label').filter('[data-type="Cuisine"]');
  $.each(allCuisines, function (index, value) {
    $(value).removeClass('filter-label-selected');
  });

  $.each(Cuisines, function (i, v) {
    var $catlink = $('.filter-label[data-value=' + v + ']', '.filter-kitchen');
    $catlink.addClass('filter-label-selected');
    makeKitchenTypeVisible();
  });

  if (Cuisines.length === 0) {
    var $catlink = $('.filter-label[data-value=reset]', '.filter-kitchen');
    $catlink.addClass('filter-label-selected');
    makeKitchenTypeVisible();
  }

  if (Discount) {
    $('.filter-label[data-type="Discount"]').addClass('filter-label-selected');
  } else {
    $('.filter-label[data-type="Discount"]').removeClass('filter-label-selected');
  }

  if (Stampcards) {
    $('.filter-label[data-type="Stampcards"]').addClass('filter-label-selected');
  } else {
    $('.filter-label[data-type="Stampcards"]').removeClass('filter-label-selected');
  }

  if (MealDeal) {
    $('.filter-label[data-type="MealDeal"]').addClass('filter-label-selected');
  } else {
    $('.filter-label[data-type="MealDeal"]').removeClass('filter-label-selected');
  }

  if (Rating.length !== false) {
    var value = '"[' + Rating + ']"';
    $('.filter-label[data-value=' + value + ']', '.ratings-filter').addClass('starfilter-selected');
  }

  var allMinimumOrderCosts = $('.filter-label[data-type="MinimumOrderCosts"]');
  $.each(allMinimumOrderCosts, function (index, value) {
    $(value).removeClass('filter-label-selected');
  });

  if (MinimumOrderCosts !== false) {
    var _value = '"[' + MinimumOrderCosts.toString() + ']"';
    $('.filter-label[data-value=' + _value + ']', '.minimumordercosts-filter').addClass('filter-label-selected');
  } else {
    $('.filter-label[data-value=reset]', '.minimumordercosts-filter').addClass('filter-label-selected');
  }

  var allDeliveryCosts = $('.filter-label[data-type="DeliveryCosts"]');
  $.each(allDeliveryCosts, function (index, value) {
    $(value).removeClass('filter-label-selected');
  });

  if (DeliveryCosts !== false) {
    var _value2 = '"[' + DeliveryCosts.toString() + ']"';
    $('.filter-label[data-value=' + _value2 + ']', '.deliverycosts-filter').addClass('filter-label-selected');
  } else {
    $('.filter-label[data-value=reset]', '.deliverycosts-filter').addClass('filter-label-selected');
  }

  var $$priceToggleButtons = [].concat(_toConsumableArray(document.querySelectorAll('.' + PRICE_RANGE_STRUCTURE.CLASS_NAMES.buttons)));

  $$priceToggleButtons.forEach(function (button) {
    button.classList.remove(PRICE_RANGE_STRUCTURE.CLASS_NAMES.active);
  });
  if (typeof PriceRange !== 'undefined') {
    PriceRange.forEach(function (selectedOption) {
      document.querySelector('.' + PRICE_RANGE_STRUCTURE.CLASS_NAMES.buttons + '[data-value="' + selectedOption + '"]').classList.add(PRICE_RANGE_STRUCTURE.CLASS_NAMES.active);
    });
  }

  // @TODO: For multiple priceRange selection, remove [0]
  filterRestaurants(Cuisines, Discount, Rating, MinimumOrderCosts, DeliveryCosts, MealDeal, typeof PriceRange !== 'undefined' ? PriceRange[0] : null, Stampcards);
  restaurantService.UI.renderRestaurants();
  checkNoResultsScreen(getRestaurantCount());
  Balloon(getRestaurantCount());

  $('#irestaurantsearchstring').val('');
  if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape')) {
    resetView();
  } else {
    if (!isStep2()) {
      $(window).scrollTop(245);
    }
  }

  app.setState({ lastClickedFilter: false });
  window.app.components.languageDropDown.updateLinksWithHash(_getHashFromLocation());

  restaurantService.UI.hideOrShowHeadersBasedOnNumberOfShownRestaurants();

  return false;
}

function updateFilters() {
  // delivery = 1, delivery and pickup = 2, pickup = 3
  var currentStatus = 1;

  if (Pickup.getCurrentStatus() === undefined) {
    currentStatus = 1;
  } else {
    currentStatus = Pickup.isTakeawayStatus() ? 1 : 3;
  }

  if (currentStatus <= 2) {
    $('.deliverycosts-filter', '.restaurants-filter').removeClass('hidden');
    $('.minimumordercosts-filter', '.restaurants-filter').removeClass('hidden');
    $('.title-pickup, .headlines').addClass('hidden');
    $('.title-delivery').removeClass('hidden');
    $('label.category-amount.deliverycount', '.filter-kitchen').removeClass('hidden');
    $('label.category-amount.pickupcount', '.filter-kitchen').addClass('hidden');
  } else {
    $('.deliverycosts-filter', '.restaurants-filter').addClass('hidden');
    $('.minimumordercosts-filter', '.restaurants-filter').addClass('hidden');
    $('.title-pickup, .headlines').removeClass('hidden');

    // Step 3 uses the title-delivery class for the restaurant name,
    // so to prevent this, title-delivery may only be hidden on step 2.
    if ($('body').hasClass('step2')) {
      $('.title-delivery').addClass('hidden');
    }

    $('label.category-amount.deliverycount', '.filter-kitchen').addClass('hidden');
    $('label.category-amount.pickupcount', '.filter-kitchen').removeClass('hidden');
  }
}

// 'UGUR - Future fix, prefill all data and just toggle the main elemnent'
function updateLabels() {
  // delivery = 1, delivery and pickup = 2, pickup = 3
  var currentStatus = 1;

  if (Pickup.getCurrentStatus() === undefined) {
    currentStatus = 1;
  } else {
    currentStatus = Pickup.isTakeawayStatus() ? 1 : 3;
  }

  // dont loop trough restaurants if its not defined
  if (window.restaurants === undefined) {
    return;
  }
  if (app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
    restaurantService.UI.clearRestaurantsContainers();
    restaurantService.UI.insertRestaurantsIntoContainerOpen(restaurants);
    restaurantService.UI.insertRestaurantsIntoContainerPreOrder(restaurants);
    restaurantService.UI.insertRestaurantsIntoContainerClosed(restaurants);
  } else {
    restaurants.filter(function (restaurant) {
      return restaurant[IS_DISABLED_FOR_DELIVERY] !== true;
    }).forEach(function (restaurant) {
      var $restaurantDOM = document.querySelector('#irestaurant' + restaurant[RESTAURANT_ID]);
      var $detailsDOM = $restaurantDOM.querySelector('.details');
      var $deliveryElement = $detailsDOM.querySelector('.delivery');
      var $pickupElement = $detailsDOM.querySelector('.pickup');
      var promotedElementDelivery = $restaurantDOM.querySelector('.js-label-promoted');
      var promotedElementPickup = $restaurantDOM.querySelector('.js-label-promoted-pickup');

      var _window$app$getState3 = window.app.getState(),
          listSortBy = _window$app$getState3.listSortBy;

      if (restaurant.promoted && listSortBy === 'default') {
        if (promotedElementDelivery) {
          promotedElementDelivery.classList.add('is-promoted');
        }

        if (promotedElementPickup) {
          promotedElementPickup.classList.add('is-promoted');
        }
      } else {
        if (promotedElementDelivery) {
          promotedElementDelivery.classList.remove('is-promoted');
        }

        if (promotedElementPickup) {
          promotedElementPickup.classList.remove('is-promoted');
        }
      }

      if ($pickupElement) {
        currentStatus === 1 ? $pickupElement.classList.add('hidden') : $pickupElement.classList.remove('hidden');
      }
      if ($deliveryElement) {
        currentStatus === 1 ? $deliveryElement.classList.remove('hidden') : $deliveryElement.classList.add('hidden');
      }
    });
  }
}

/**
 * Filter restaurants.
 * @param {array} cuisine Only restaurants that supports the type of cuisines.
 * @param {boolean} discountFilter Only restaurants with discount(s)
 * @param {float} rating The minimum rating
 * @param {array} minimumOrderCosts The minimum and maxium order costs
 * @param {array} deliveryCosts The minimum and maximum delivery costs.
 * @param {boolean} mealDealFilter Only restaurants with meal deal(s)
 * @param {string|null} priceRange Only restaurants within the price range, if none selected show all
 * @param {boolean} hasStampcards Only restaurants supporting hasStampcards
 */
function filterRestaurants(cuisine, discountFilter, rating, minimumOrderCosts, deliveryCosts, mealDealFilter, priceRange, stampcardFilter) {
  var DELIVERY = 1;
  // 2 IS DELIVERY AND PICKUP
  var PICKUP = 3;
  // Based on current status being delivery or pickup
  var isOrderingPossibleBasedOnStatus = function isOrderingPossibleBasedOnStatus(currentStatus) {
    return function (restaurant) {
      if (currentStatus === DELIVERY) {
        return !restaurant[IS_DISABLED_FOR_DELIVERY];
      }

      return restaurant[IS_PICKUP] !== DELIVERY;
    };
  };

  var hasOneOrMoreCuisines = function hasOneOrMoreCuisines(cuisines) {
    return function (restaurant) {
      // If at least one cuisine is found it should show
      return cuisines.some(function (cuisine) {
        return restaurant[SUB_CATEGORY_IDS].includes(Number(cuisine));
      });
    };
  };

  var hasMinimumRatingOf = function hasMinimumRatingOf(_ref14) {
    var _ref15 = _slicedToArray(_ref14, 2),
        minRating = _ref15[0],
        maxRating = _ref15[1];

    return function (restaurant) {
      var restaurantRating = restaurant[REVIEW];
      return restaurantRating >= parseFloat(minRating) * 2 && restaurantRating <= parseFloat(maxRating) * 2;
    };
  };

  var hasDeliveryCostBetween = function hasDeliveryCostBetween(_ref16) {
    var _ref17 = _slicedToArray(_ref16, 2),
        minValue = _ref17[0],
        maxValue = _ref17[1];

    return function (restaurant) {
      return parseFloat(restaurant[DELIVERY_COST]) >= parseFloat(minValue) && parseFloat(restaurant[DELIVERY_COST]) <= parseFloat(maxValue);
    };
  };

  var hasDiscount = function hasDiscount(weekDay) {
    return function (restaurant) {
      return !(restaurant[DISCOUNTS_WEEK] && restaurant[DISCOUNTS_WEEK][weekDay] === false || restaurant[DISCOUNTS_TOTAL] === 0); // fallback to the 'old' value, remove if we will 'cache' restaurant data for more then a day
    };
  };

  var hasStampCards = function hasStampCards(restaurant) {
    return restaurant[HAS_STAMPCARDS] && restaurant[HAS_STAMPCARDS] !== false;
  };

  var hasMealDeals = function hasMealDeals(restaurant) {
    return restaurant[HAS_MEAL_DEALS] && restaurant[HAS_MEAL_DEALS] !== false;
  };

  var isInPriceRange = function isInPriceRange(priceRange, priceRangeRestaurants) {
    return function (restaurant) {
      return priceRangeRestaurants[priceRange].includes(restaurant[RESTAURANT_ID]);
    };
  };

  var hasMinimumOrderValueBetween = function hasMinimumOrderValueBetween(_ref18) {
    var _ref19 = _slicedToArray(_ref18, 2),
        minValue = _ref19[0],
        maxValue = _ref19[1];

    return function (restaurant) {
      return parseFloat(restaurant[MINIMUM_DELIVERY]) >= parseFloat(minValue) && parseFloat(restaurant[MINIMUM_DELIVERY]) <= parseFloat(maxValue);
    };
  };
  var currentStatus = Pickup.isPickupStatus() ? PICKUP : DELIVERY;

  var isRestaurantFoundBySearch = function isRestaurantFoundBySearch(restaurantIdsFoundBySearch) {
    return function (_ref20) {
      var _ref21 = _slicedToArray(_ref20, 1),
          restaurantId = _ref21[0];

      return restaurantIdsFoundBySearch.includes(restaurantId);
    };
  };
  var activeFilters = [isOrderingPossibleBasedOnStatus(currentStatus)];

  var _app$getState5 = app.getState(),
      _app$getState5$restau = _app$getState5.restaurantSearchString,
      restaurantSearchString = _app$getState5$restau === undefined ? '' : _app$getState5$restau,
      _app$getState5$restau2 = _app$getState5.restaurantIdsFoundBySearch,
      restaurantIdsFoundBySearch = _app$getState5$restau2 === undefined ? [] : _app$getState5$restau2;

  if (restaurantSearchString === '') {
    if (cuisine.length > 0) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasOneOrMoreCuisines(cuisine)]);
    }

    if (rating !== false) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasMinimumRatingOf(rating)]);
    }

    if (discountFilter !== false) {
      var weekDay = new Date().getDay();
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasDiscount(weekDay)]);
    }

    if (minimumOrderCosts !== false) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasMinimumOrderValueBetween(minimumOrderCosts)]);
    }

    if (mealDealFilter !== false) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasMealDeals]);
    }

    if (stampcardFilter !== false) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasStampCards]);
    }

    if (deliveryCosts !== false) {
      activeFilters = [].concat(_toConsumableArray(activeFilters), [hasDeliveryCostBetween(deliveryCosts)]);
    }
    if (priceRange !== null) {
      var _window$app$getState4 = window.app.getState(),
          priceRangeRestaurants = _window$app$getState4.priceRangeRestaurants;

      activeFilters = [].concat(_toConsumableArray(activeFilters), [isInPriceRange(priceRange, priceRangeRestaurants)]);
    }
  } else {
    activeFilters = [].concat(_toConsumableArray(activeFilters), [isRestaurantFoundBySearch(restaurantIdsFoundBySearch)]);
  }

  // Show reset button when filter is active
  var $resetAllButton = document.querySelector('.filter-reset-all');
  if (activeFilters.length === 1 && $resetAllButton !== null) {
    $resetAllButton.classList.add('reset-results-hidden');
  }

  // Visible restaurants is only the a list of restaurant id's which are visible
  visibleRestaurantIds = restaurants.filter(function (restaurant) {
    var isVisible = activeFilters.every(function (activeFilter) {
      return activeFilter(restaurant);
    });
    restaurant.isHidden = !isVisible;
    return isVisible;
  }).map(function (restaurant) {
    return restaurant[RESTAURANT_ID];
  });
  app.setState({
    visibleRestaurantIds: visibleRestaurantIds
  });
}

function checkNoResultsScreen(count) {
  if (count === 0) {
    // should bring back the no-results-filter screen when it is time to do so.
    // for now, we have implemented the same no results screen for both filter and search.
    // $('#no-results-filter').show()
    if (document.querySelector('.js-noresults-area') === null) {
      $('.js-noresults-search').show();
    } else {
      $('.js-noresults-area').show();
    }
  } else {
    $('#filteringError, .restaurant_noresults, .noresults--pickup').hide();
    initLazyLoad();
  }
}

// 'UGUR - check resetFilter if we still need all the dom manipulation')
function resetFilter() {
  console.log('resetFilter');
  var currentSelectedRating = $('.starfilter-selected[data-type="Rating"]')[0];
  if (currentSelectedRating !== undefined) {
    $(currentSelectedRating).removeClass('starfilter-selected');
  }
  $('.filter-reset-all').addClass('reset-results-hidden');
  $('.btn-search', '.subnavigation').removeClass('active');
  $('.btn-filter', '.subnavigation').removeClass('active');
}

function clearSearch() {
  console.log('Clear Search');
  $('.restaurant_noresults').hide();
  $('#irestaurantsearchstring').val('');
  $('#irestaurantsearchstring-middle').val(''); // for utility middle bar (step2)

  if (searchRestaurant && searchRestaurant.hasOwnProperty('clear')) {
    searchRestaurant.clear();
  }
  window.app.setState({
    restaurantSearchString: ''
  });
}

function toggleHashUrl(type, value) {
  if (value === 'reset') {
    removeHash(type, value);
    if (window.location.hash === '' || window.location.hash === '#') {
      clearHash();
      resetFilter();
      processHash();
    }
    return;
  }

  $('.filter-reset-all').removeClass('reset-results-hidden');
  $('.btn-filter', '.subnavigation').addClass('active');

  if (value === 'toggle') {
    toggleHash(type, 1);

    if (type === 'Stampcards') {
      // get hashValue returns undefined if not found
      var trackingValue = getHashValue(type) === '1' ? '1' : '0';

      window.app.services.tracking.send({
        eventName: 'hasFilteredRestaurants',
        eventData: {
          filterType: 'StampCard',
          filterStampcard: trackingValue,
          countRestaurantShown: getRestaurantCount()
        }
      });
    }

    if (window.location.hash === '' || window.location.hash === '#') {
      clearHash();
      resetFilter();
      processHash();
    }
    return;
  }

  if (type === 'Rating') {
    var currentSelectedRating = $('.starfilter-selected[data-type="Rating"]')[0];
    var ratingString = void 0;
    if (currentSelectedRating !== undefined) {
      ratingString = $(currentSelectedRating).data('value').toString();
    }
    var allRatings = $('.filter-label[data-type="Rating"]');
    $.each(allRatings, function (index, value) {
      $(value).removeClass('starfilter-selected');
    });

    if (ratingString === value.toString()) {
      removeHash(type, value);
      if (window.location.hash === '' || window.location.hash === '#') {
        clearHash();
        resetFilter();
        processHash();
      }
    } else {
      updateHash(type, value);
    }
    return;
  }

  if (type === PRICE_RANGE_STRUCTURE.HASH) {
    var PriceRange = getHashValue(PRICE_RANGE_STRUCTURE.HASH);
    if (typeof PriceRange !== 'undefined') {
      if (!Array.isArray(PriceRange)) {
        PriceRange = [PriceRange];
      }
      if (PriceRange.includes(value)) {
        var eventToBeFired = function eventToBeFired(event) {
          window.app.services.tracking.send({
            eventName: 'hasFilteredbyPrice',
            eventData: {
              countRestaurantShown: event.detail.visibleRestaurantsCount || getRestaurantCount(),
              priceFilter: 'none'
            }
          });
          window.removeEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, eventToBeFired);
        };
        window.addEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, eventToBeFired);
        console.log('Price filter deactivated: ', value);

        removeHash(type, value);
        if (window.location.hash === '' || window.location.hash === '#') {
          clearHash();
          resetFilter();
          processHash();
        }
        return;
      } else {
        var _eventToBeFired = function _eventToBeFired(event) {
          window.app.services.tracking.send({
            eventName: 'hasFilteredbyPrice',
            eventData: {
              countRestaurantShown: event.detail.visibleRestaurantsCount || getRestaurantCount(),
              priceFilter: value
            }
          });
          window.removeEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, _eventToBeFired);
        };
        window.addEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, _eventToBeFired);
        console.log('Price filter changed to: ', value);
      }
    } else {
      var _eventToBeFired2 = function _eventToBeFired2(event) {
        window.app.services.tracking.send({
          eventName: 'hasFilteredbyPrice',
          eventData: {
            countRestaurantShown: event.detail.visibleRestaurantsCount || getRestaurantCount(),
            priceFilter: value
          }
        });
        window.removeEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, _eventToBeFired2);
      };
      window.addEventListener(window.app.enums.CUSTOM_EVENTS.VISIBLE_RESTAURANTS_COUNTER_UPDATED, _eventToBeFired2);
      console.log('Price filter activated: ', value);
    }
  }

  updateHash(type, value);
}

function getHashValue(type) {
  var curr = _getHashObject();
  if (typeof curr[type] !== 'undefined') {
    return curr[type];
  }
}

function updateHash(key, value) {
  var hashObject = _getHashObject();
  hashObject[key] = value;
  _setHash(hashObject);
}

function isFilterActive() {
  var hashObject = _getHashObject();
  // !! so it returns boolean
  return !!(hashObject.Cuisine || hashObject.Discount || hashObject.MealDeal || hashObject.Stampcards || hashObject.Rating || hashObject.MinimumOrderCosts || hashObject.DeliveryCosts || false);
}

/* click / change / resize functions */
$(document).ready(function () {
  var _this = this;

  if (isStep2()) {
    var $filter = $('.filter-wrapper');
    var scrollUpRestaurantListing = function scrollUpRestaurantListing() {
      enableAutoScroll = false; // Used for canceling side effects of scrolling
      var $isSticky = document.querySelector('.js-kitchen-type-sticky .kitchen-type-scrolling');
      var $restaurantListContainer = document.querySelector('.js-restaurant-list-container');
      var $deviceBanner = document.querySelector('.smartbnr');

      if ($restaurantListContainer && $isSticky) {
        var scrollOffset = $restaurantListContainer.offsetTop;
        if ($deviceBanner) {
          scrollOffset -= $deviceBanner.offsetHeight;
        }
        setTimeout(window.scrollTo({
          top: scrollOffset,
          left: 0,
          behavior: 'smooth'
        }), 1);
      }
      enableAutoScroll = true;
    };

    $(document).on('click', '.filter-label', function (event) {
      event.preventDefault();
      event.stopPropagation();
      // If there are no area results, don't execute the search
      if (document.querySelector('.js-noresults-area') !== null) {
        return;
      }

      app.setState({ lastClickedFilter: $(event.currentTarget).data('type') });
      var $inputEl = $('#irestaurantsearchstring-middle');
      if ($inputEl && $inputEl.val().length > 0) {
        $inputEl.val('');
        window.app.setState({
          restaurantSearchString: ''
        });
      }
      toggleHashUrl($(this).data('type'), $(this).data('value'));

      scrollUpRestaurantListing();

      return false;
    });

    $filter.on('click', '.show-results', function (e) {
      e.preventDefault();
      toggleBottomHeader('showResults', false);
      resetView($(this));
    });

    var onClickResetFilters = function onClickResetFilters(e) {
      e.preventDefault();

      $(_this).addClass('reset-results-hidden');
      $('.btn-filter', '.subnavigation').removeClass('active');

      clearHash();
      clearSearch();
      resetFilter();
      processHash();
      // if you don't call this again, "reset filter" resets the filter, but doesn't update the list
      scrollUpRestaurantListing();
      return false;
    };

    $(document).on('click', '.js-reset-restaurant-filter', onClickResetFilters);

    $(document).on('change', '#isorting-select', function () {
      var listSortBy = $(this).val();
      window.app.setState({ listSortBy: listSortBy });
      RestaurantSortBy();
    });

    $(document).on('click', '.maincatmenu', function () {
      var addGroupFilter = !$(this).hasClass('groupfilter-on');
      toggleCategories(this);
      $(this).toggleClass('groupfilter-on', addGroupFilter);
    });
    $(document).on('click', '#irestfiltercont a', function () {
      toggleMainCategories(this);
      return false;
    });
    $(document).on('change', '#categoryFilterMapview', function () {
      toggleMainCategories(false, $(this).find(':selected').data('subcats'));
      return false;
    });
    $(document).on('click', '#filteringError a', function () {
      clearHash();
      clearSearch();
    });

    var enableAutoScroll = true;
    var body = document.body;
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    window.app.setState({ lastScrollTop: lastScrollTop });
    var filter = $filter[0];

    /* scrolling */
    $(window).scroll(function () {
      if (!enableAutoScroll) {
        return;
      }
      if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape')) {
        var currentScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;

        // Scroll bottom

        var _window$app$getState5 = window.app.getState(),
            _lastScrollTop = _window$app$getState5.lastScrollTop;

        if (currentScrollTop > _lastScrollTop && filter.scrollTop !== filter.scrollHeight) {
          var scrollDistance = currentScrollTop - _lastScrollTop;
          filter.scrollTop += scrollDistance;

          // Scroll reach 98% of the total will scroll the filter to top.
          var scrollPercentage = 100 * (body.scrollTop / body.scrollHeight) / (1 - body.clientHeight / body.scrollHeight);
          if (scrollPercentage >= 98) {
            filter.scrollTop = filter.scrollHeight;
          }
        } else if (filter.scrollTop !== 0) {
          // Scroll up
          var _scrollDistance = _lastScrollTop - currentScrollTop;
          filter.scrollTop -= _scrollDistance;
        }
        window.app.setState({ lastScrollTop: currentScrollTop });
      }
    });

    // 'UGUR - do we still use this?'
    /**
     * The code below is a workaround for FED-3051.
     * Due to the way we're handling filter selection, we need to "simulate" clicking the filter.
     * If this does not happen, the filters won't be set automatically when visiting a subcategory
     * of the restaurant list on step 2.
     **/
    var urlPath = window.location.pathname;

    if ($('a.filter-label[href=\'' + urlPath + '\']').length) {
      var $filterLabel = $('a.filter-label[href=\'' + urlPath + '\']');

      $filterLabel[0].click();
    }
  }
});

var isStep2 = function isStep2() {
  return document.querySelector('body').classList.contains('is-restaurant-list');
};

var timeout = function timeout(_ref22) {
  var milliseconds = _ref22.milliseconds,
      promise = _ref22.promise;

  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      return reject(new Error('Connection timeout: ' + milliseconds + 'ms'));
    }, milliseconds);
    promise.then(resolve, reject);
  });
};

var addRankingValues = function addRankingValues(rankings) {
  // If there is no data, we don't have to execute the logic
  if (rankings && rankings.length > 0) {
    var restaurantIndex = void 0;
    rankings.forEach(function (entry) {
      restaurantIndex = restaurants.findIndex(function (restaurant) {
        return restaurant[RESTAURANT_ID] === entry.restaurantId;
      });
      if (restaurantIndex > -1) {
        restaurants[restaurantIndex].rankingPickup = restaurants[restaurantIndex][RANKING];
        if (entry.ranking > 0) {
          restaurants[restaurantIndex].rankingPickup += entry.ranking;
        }
        restaurants[restaurantIndex][RANKING] += entry.ranking;
        restaurants[restaurantIndex].promoted = entry.promoted;
      }
    });
  }
};

var addDynamicDeliveryCosts = function addDynamicDeliveryCosts(rankings) {
  if (rankings.length > 0) {
    var foundRanking = void 0;

    var _loop = function _loop(i, j) {
      foundRanking = rankings.find(function (entry) {
        return entry.dynamicDeliveryCosts > 0 && entry.restaurantId === restaurants[i][RESTAURANT_ID];
      });
      if (foundRanking) {
        // add the dynamic delivery costs
        restaurants[i][DELIVERY_COST] = parseFloat(restaurants[i][DELIVERY_COST]) + parseFloat(foundRanking.dynamicDeliveryCosts);
        restaurants[i].dynamicDeliveryCosts = foundRanking.dynamicDeliveryCosts;
        // re-render
        try {
          if (Pickup.isTakeawayStatus() === true) {
            restaurantDOM = $('#irestaurant' + foundRanking.restaurantId);
            var restaurantHtmlDeliveryLabel = restaurantDOM.find('.js-delivery-cost');
            var DeliveryCostsFormatted = format_price(restaurants[i][DELIVERY_COST], currency);
            if (restaurantHtmlDeliveryLabel.length > 0) {
              restaurantHtmlDeliveryLabel.html(DeliveryCostsFormatted);
            } else {
              // update div
              restaurantDOM.find('.open').after('<div class="delivery-cost">' + DeliveryCostsFormatted + '</div>');
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
    };

    for (var i = 0, j = restaurants.length; i < j; i++) {
      _loop(i, j);
    }

    var _window$app$getState6 = window.app.getState(),
        listSortBy = _window$app$getState6.listSortBy;
    // if sorted by delivery costs, resort, just to be sure


    if (listSortBy === 'deliverycosts') {
      RestaurantSortBy();
    }
  }
};

var makeKitchenTypeVisible = function makeKitchenTypeVisible() {
  var selectedSlide = $('.filter-label-selected[data-type=\'Cuisine\']');
  if (app && window.app.components && window.app.components.kitchenBar) {
    window.app.components.kitchenBar.props.swiper.slideTo(selectedSlide.index(), 1000, false);
  }
};
// @TODO: Create a new component for this sticky kitchen type thingy.
var stickyKitchenType = function stickyKitchenType() {
  var kitchenType = document.querySelector('.js-kitchen-type-sticky');
  if (kitchenType) {
    var bar = kitchenType.querySelector('.kitchen-type-wrapper');
    if (bar) {
      var smartBanner = document.querySelector('.smartbnr');
      var fromTop = smartBanner ? smartBanner.getBoundingClientRect().height : 0;
      var scrollingClass = 'kitchen-type-scrolling';
      if (kitchenType.getBoundingClientRect().top <= fromTop) {
        bar.classList.add(scrollingClass);
      } else {
        bar.classList.remove(scrollingClass);
      }
    }
  }
};

/**
 * First attempt to clean up this file. Out of this file it's only used once in global scope: Search.js
 */
var restaurantService = {
  getNumberOfOpenRestaurants: function getNumberOfOpenRestaurants() {
    return document.querySelectorAll(restaurantService.UI.restaurantsContainerOpenSelector + ' .js-restaurant:not(.restaurant-hide):not(.restaurant-disable)').length;
  },

  getNumberOfPreOrderRestaurants: function getNumberOfPreOrderRestaurants() {
    return document.querySelectorAll(restaurantService.UI.restaurantsContainerPreOrderSelector + ' .js-restaurant:not(.restaurant-hide):not(.restaurant-disable)').length;
  },

  getNumberOfClosedRestaurants: function getNumberOfClosedRestaurants() {
    return document.querySelectorAll(restaurantService.UI.restaurantsContainerClosedSelector + ' .js-restaurant:not(.restaurant-hide):not(.restaurant-disable)').length;
  },

  getOpeningAndExceptionTimesConsideringPickupStatus: function getOpeningAndExceptionTimesConsideringPickupStatus(restaurant) {
    var opening = restaurant[OPENING_TIMES_TAKEAWAY];
    var exception = restaurant[EXCEPTION_TIMES_TAKEAWAY];

    // If pickup is selected, use pickup times for calculation
    if (Pickup.isPickupStatus() === true) {
      opening = restaurant[OPENING_TIMES_PICKUP];
      exception = restaurant[EXCEPTION_TIMES_PICKUP];
    }

    return { opening: opening, exception: exception };
  },

  /**
   * Groups restaurants by property
   *
   * @param {Object} restaurants
   * @param {String} propName
   */
  groupRestaurantsByProp: function groupRestaurantsByProp(restaurants) {
    var propName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'status';

    return restaurants.reduce(function (groups, item) {
      var val = item[propName];
      groups[val] = groups[val] || [];
      groups[val].push(item);
      return groups;
    }, {});
  },

  /**
   * Returns whether restaurant opens in given hours
   * @param restaurant
   * @param hours
   * @returns {boolean}
   */
  isOpeningSoon: function isOpeningSoon(restaurant) {
    var hours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var _app$getState6 = app.getState(),
        normalizedServerTime = _app$getState6.normalizedServerTime;

    var _restaurantService$ge = restaurantService.getOpeningAndExceptionTimesConsideringPickupStatus(restaurant),
        opening = _restaurantService$ge.opening,
        exception = _restaurantService$ge.exception;

    var currentTimeStamp = normalizedServerTime.time.clone();
    var ONE_HOUR_SECONDS = 3600; // Number of seconds
    var GRAY_AREA_SECONDS = 25200; // 07:00 AM
    var SECONDS_ONE_DAY = 86400; // 24 hours
    var startTime = getPreorderTime(normalizedServerTime, opening, exception);

    var preOrderStartTimeSeconds = moment.duration(startTime.starttime).asSeconds();
    var numberOfSecondsFromMidnight = currentTimeStamp.diff(currentTimeStamp.clone().startOf('day'), 'seconds');
    // When preorder time is in gray area and the current time
    // is before midnight it should check the next day
    // Example: Current time 23:45
    // Opening Time: 0:30
    // Then it should compare check from: 23:45 with 24:30 (24 hours added)
    if (preOrderStartTimeSeconds < GRAY_AREA_SECONDS && numberOfSecondsFromMidnight > GRAY_AREA_SECONDS) {
      preOrderStartTimeSeconds = preOrderStartTimeSeconds + SECONDS_ONE_DAY;
    }

    return numberOfSecondsFromMidnight < preOrderStartTimeSeconds && numberOfSecondsFromMidnight > preOrderStartTimeSeconds - ONE_HOUR_SECONDS;
  },

  UI: {
    // <editor-fold desc="Render: Restaurants">
    insertRestaurantsIntoContainer: function insertRestaurantsIntoContainer(restaurants, $container) {
      if (app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
        var renderAllRestaurants = function renderAllRestaurants(restaurant) {
          var restaurantHTML = renderRestaurantHTML(restaurant);
          $container.insertAdjacentHTML('beforeend', restaurantHTML);
        };

        var _app$getState7 = app.getState(),
            _app$getState7$visibl = _app$getState7.visibleRestaurantIds,
            _visibleRestaurantIds = _app$getState7$visibl === undefined ? [] : _app$getState7$visibl;

        restaurants.filter(function (restaurant) {
          return _visibleRestaurantIds.includes(restaurant[RESTAURANT_ID]);
        }).forEach(renderAllRestaurants);
        return;
      }

      restaurants.forEach(function (restaurant) {
        $container.appendChild(document.querySelector('#irestaurant' + restaurant[RESTAURANT_ID]));
      });
    },

    restaurantsContainerOpenSelector: '.js-restaurant-list-open',
    restaurantsContainerPreOrderSelector: '.js-restaurant-list-preorder',
    restaurantsContainerClosedSelector: '.js-restaurant-list-closed',

    getRestaurantsContainerOpen: function getRestaurantsContainerOpen() {
      return document.querySelector(restaurantService.UI.restaurantsContainerOpenSelector);
    },
    getRestaurantsContainerPreOrder: function getRestaurantsContainerPreOrder() {
      return document.querySelector(restaurantService.UI.restaurantsContainerPreOrderSelector);
    },
    getRestaurantsContainerClosed: function getRestaurantsContainerClosed() {
      return document.querySelector(restaurantService.UI.restaurantsContainerClosedSelector);
    },

    clearContainer: function clearContainer($container) {
      $container.innerHTML = '';
    },

    clearRestaurantsContainerOpen: function clearRestaurantsContainerOpen() {
      restaurantService.UI.clearContainer(restaurantService.UI.getRestaurantsContainerOpen());
    },

    clearRestaurantsContainerPreOrder: function clearRestaurantsContainerPreOrder() {
      restaurantService.UI.clearContainer(restaurantService.UI.getRestaurantsContainerPreOrder());
    },

    clearRestaurantsContainerClosed: function clearRestaurantsContainerClosed() {
      restaurantService.UI.clearContainer(restaurantService.UI.getRestaurantsContainerClosed());
    },

    clearRestaurantsContainers: function clearRestaurantsContainers() {
      restaurantService.UI.clearRestaurantsContainerOpen();
      restaurantService.UI.clearRestaurantsContainerPreOrder();
      restaurantService.UI.clearRestaurantsContainerClosed();
    },

    insertRestaurantsIntoContainerOpen: function insertRestaurantsIntoContainerOpen(restaurants) {
      restaurantService.UI.insertRestaurantsIntoContainer(restaurants, restaurantService.UI.getRestaurantsContainerOpen());
    },

    insertRestaurantsIntoContainerPreOrder: function insertRestaurantsIntoContainerPreOrder(restaurants) {
      restaurantService.UI.insertRestaurantsIntoContainer(restaurants, restaurantService.UI.getRestaurantsContainerPreOrder());
    },

    insertRestaurantsIntoContainerClosed: function insertRestaurantsIntoContainerClosed(restaurants) {
      restaurantService.UI.insertRestaurantsIntoContainer(restaurants, restaurantService.UI.getRestaurantsContainerClosed());
    },

    /**
     * This method may be replaced by ReactDOM.render() one day
     *
     * Order of the restaurants is defined in FED-13050 and FED-13014:
     *
     * # Open restaurants (An invisible <div>)
     *   ## No header
     *     1. Favorites: Open
     *     2. Favorites: PreOrder
     *     3. Open
     *        │
     *        │  This is a mix of Open and PreOrderInOneHour restaurants as shown below.
     *        │  It doesn't indicate the order, order is defined by selected sorting.
     *        │  Thus, you can see restaurant labels like "from 13:00" in the middle of
     *        │  open restaurants. To achieve that, we manually 'open' these PreOrder
     *        │  restaurants. You can see how we do that in RestaurantFilterInit() method.
     *        │
     *        │  This mix was a request from Product in FED-13014.
     *        │
     *        ├─ A. Regular open restaurants
     *        └─ B. PreOrder (in one hour)
     *
     * # PreOrder restaurants (An invisible <div>)
     *   ## No header
     *     4. PreOrder (later than one hour)
     *
     * # Closed restaurants (An invisible <div>)
     *   ## Closed header (text depends on delivery or pickup mode)
     *     5. Favorites: Closed
     *     6. Closed
     */
    renderRestaurants: function renderRestaurants() {
      /**
       * We won't use restaurantsPreOrderInOneHour as they're already included in Open restaurants.
       * They're in state only for debugging. You can learn how/why we mix them in the doc block above
       * and in RestaurantFilterInit() method's doc block.
       */
      var _window$app$getState7 = window.app.getState(),
          _window$app$getState8 = _window$app$getState7.restaurantsOpen,
          restaurantsOpen = _window$app$getState8 === undefined ? [] : _window$app$getState8,
          _window$app$getState9 = _window$app$getState7.restaurantsPreOrderLater,
          restaurantsPreOrderLater = _window$app$getState9 === undefined ? [] : _window$app$getState9,
          _window$app$getState10 = _window$app$getState7.restaurantsClosed,
          restaurantsClosed = _window$app$getState10 === undefined ? [] : _window$app$getState10,
          _window$app$getState11 = _window$app$getState7.restaurantsFavoriteOpen,
          restaurantsFavoriteOpen = _window$app$getState11 === undefined ? [] : _window$app$getState11,
          _window$app$getState12 = _window$app$getState7.restaurantsFavoritePreOrder,
          restaurantsFavoritePreOrder = _window$app$getState12 === undefined ? [] : _window$app$getState12,
          _window$app$getState13 = _window$app$getState7.restaurantsFavoriteClosed,
          restaurantsFavoriteClosed = _window$app$getState13 === undefined ? [] : _window$app$getState13;

      restaurantService.UI.removeHeadersIfExist();
      if (app.services.feature.isActive(app.enums.FEATURES.RENDER_RESTAURANTS_CLIENT_SIDE)) {
        restaurantService.UI.clearRestaurantsContainers();
      }

      // <editor-fold desc="Open restaurants container">
      if (restaurantsFavoriteOpen.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerOpen(restaurantsFavoriteOpen);
      }

      if (restaurantsFavoritePreOrder.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerOpen(restaurantsFavoritePreOrder);
      }

      if (restaurantsOpen.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerOpen(restaurantsOpen);
      }
      // </editor-fold>

      // <editor-fold desc="PreOrder restaurants container">
      if (restaurantsPreOrderLater.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerPreOrder(restaurantsPreOrderLater);
      }
      // </editor-fold>

      // <editor-fold desc="Closed restaurants container">
      if (restaurantsClosed.length > 0 || restaurantsFavoriteClosed.length > 0) {
        restaurantService.UI.addHeaderClosed();
      }

      if (restaurantsFavoriteClosed.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerClosed(restaurantsFavoriteClosed);
      }

      if (restaurantsClosed.length > 0) {
        restaurantService.UI.insertRestaurantsIntoContainerClosed(restaurantsClosed);
      }
      // </editor-fold>

      restaurantService.UI.hideOrShowHeadersBasedOnNumberOfShownRestaurants();
    },
    // </editor-fold>

    // <editor-fold desc="Render: Headers">
    addHeaderClosed: function addHeaderClosed() {
      var $container = document.querySelector('.js-restaurant-list-closed');
      var header = Pickup.isPickupStatus() === true ? _i18n.components.restaurantListHeader.CLOSED_FOR_PICKUP : _i18n.components.restaurantListHeader.CLOSED_FOR_DELIVERY;

      $container.insertAdjacentHTML('beforeend', '\n      <h1 class="restaurant-list-header js-restaurant-list-header js-restaurant-list-header-closed">\n          ' + header + '\n      </h1>\n    ');
    },

    addHeaderPreOrder: function addHeaderPreOrder() {
      var $container = document.querySelector('.js-restaurant-list-preorder');

      $container.insertAdjacentHTML('beforeend', '\n      <h1 class="restaurant-list-header js-restaurant-list-header js-restaurant-list-header-preorder">\n          ' + _i18n.components.restaurantListHeader.PREORDER + '\n      </h1>\n    ');
    },

    removeHeadersIfExist: function removeHeadersIfExist() {
      document.querySelectorAll('.js-restaurant-list-header').forEach(function ($header) {
        return $header.remove();
      });
    },

    removeHeaderPreOrderIfExists: function removeHeaderPreOrderIfExists() {
      var $title = document.querySelector('.js-restaurant-list-header-preorder');

      if ($title) {
        $title.remove();
      }
    },

    removeHeaderClosedIfExists: function removeHeaderClosedIfExists() {
      var $title = document.querySelector('.js-restaurant-list-header-closed');

      if ($title) {
        $title.remove();
      }
    },

    removeHeadersIfThereIsNoRestaurants: function removeHeadersIfThereIsNoRestaurants() {
      if (restaurantService.getNumberOfClosedRestaurants() > 0) {
        restaurantService.UI.removeHeaderClosedIfExists();
      }
    },

    // <editor-fold desc="Render: Headers - Hide/Show for filters & search">
    hideOrShowHeadersBasedOnNumberOfShownRestaurants: function hideOrShowHeadersBasedOnNumberOfShownRestaurants() {
      if (restaurantService.getNumberOfClosedRestaurants() > 0) {
        restaurantService.UI.showHeaderClosed();
      } else {
        restaurantService.UI.hideHeaderClosed();
      }
    },

    hideHeaderClosed: function hideHeaderClosed() {
      var $header = document.querySelector('.js-restaurant-list-header-closed');

      if ($header) {
        $header.classList.add('hidden');
      }
    },

    hideHeaderPreOrder: function hideHeaderPreOrder() {
      var $header = document.querySelector('.js-restaurant-list-header-preorder');

      if ($header) {
        $header.classList.add('hidden');
      }
    },

    showHeaderClosed: function showHeaderClosed() {
      var $header = document.querySelector('.js-restaurant-list-header-closed');

      if ($header) {
        $header.classList.remove('hidden');
      }
    },

    showHeaderPreOrder: function showHeaderPreOrder() {
      var $header = document.querySelector('.js-restaurant-list-header-preorder');

      if ($header) {
        $header.classList.remove('hidden');
      }
    }
    // </editor-fold>
    // </editor-fold>
  }
};

Helper.ready(function () {
  var _window$app$enums = window.app.enums,
      _window$app$enums$SEL = _window$app$enums.SELECTOR_CLASS_NAMES.RESTAURANT_LIST,
      LIST_RESTAURANT = _window$app$enums$SEL.LIST_RESTAURANT,
      SINGLE_RESTAURANT = _window$app$enums$SEL.SINGLE_RESTAURANT,
      HAS_SELECTED_RESTAURANT = _window$app$enums.TRACKING_EVENT_NAMES.HAS_SELECTED_RESTAURANT;


  var $containerRestaurants = document.querySelector('.' + LIST_RESTAURANT);

  var trackRestaurantData = function trackRestaurantData(event) {
    var $restaurant = event.target.closest('.' + SINGLE_RESTAURANT);
    if ($restaurant) {
      var restaurant = restaurants.find(function (restaurant) {
        return restaurant[RESTAURANT_ID] === $restaurant.dataset.id;
      });
      if (restaurant) {
        var restaurantOpeningStatuses = ['Closed', 'Open', 'Pre-order'];
        var restaurantOpeningStatus = restaurantOpeningStatuses[restaurant[OPENING_STATUS]];

        var _window$app$getState14 = window.app.getState(),
            restaurantSearchString = _window$app$getState14.restaurantSearchString;

        if (restaurantOpeningStatus) {
          window.app.services.tracking.send({
            onlyTrackOnce: true,
            eventName: HAS_SELECTED_RESTAURANT,
            eventData: {
              restaurantName: restaurant[NAME],
              restaurantOpeningStatus: restaurantOpeningStatuses[restaurant[OPENING_STATUS]],
              searchString: window.app.services.piiDataReplacer({ data: restaurantSearchString })

            }
          });
        }
      }
    }
  };

  /**
   * If Version3 support is enabled, add shipping method to restaurant url as query param
   * @issue FED-10342
   */
  var addShippingParamToRestaurantUrl = function addShippingParamToRestaurantUrl(event) {
    var $restaurant = event.target.closest('.js-restaurant');
    if ($restaurant) {
      event.preventDefault();
      var paramShipping = Pickup.isPickupStatus() ? '?shipping=pickup' : '';
      window.location.href = $restaurant.dataset.url + paramShipping;
    }
  };
  /**
   * NOTE ON AUXCLICK
   * "auxclick" will prevent default middle/right click behaviours. This may seem weird but for the sake of this
   * feature we need to add shipping param no matter what. That's why I used it. As VERSION_3_SUPPORT is a migration
   * flag, I find this exception usable.
   * If product finds this solution unusable, we can try to override each restaurant url at each delivery/pickup
   * click which will be less performant.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/auxclick_event
   */
  if ($containerRestaurants) {
    ['auxclick', 'click'].forEach(function (eventName) {
      $containerRestaurants.addEventListener(eventName, function (event) {
        trackRestaurantData(event);
        if (app.services.feature.isActive(app.enums.FEATURES.VERSION_3_SUPPORT)) {
          addShippingParamToRestaurantUrl(event);
        }
      });
    });
  }
});
/* global moment */

/**
 * This file should be replaced with Restaurant.js and Utils.js.
 * There is tight coupling with data from PHP for step2.
 */
var intervalStartTime = moment({ hour: 0, minute: 0, second: 0, millisecond: 0 });
var intervalEndTime = moment({ hour: 7, minute: 0, second: 0, millisecond: 0 });

var TimeStatus = Object.freeze({
  Before: 1,
  Between: 2,
  After: 3
});

var OpeningStatus = Object.freeze({
  Closed: 0,
  Open: 1,
  PreOrder: 2
});

var DeliveryMethod = Object.freeze({
  Delivery: 1,
  DeliveryAndPickup: 2,
  Pickup: 3
});

var getOpeningStatus = function getOpeningStatus(serverDateTime, times, exceptionTimes) {
  var openingTimes = getCurrentOpeningTimes(serverDateTime, times, exceptionTimes);
  for (var x in openingTimes) {
    var openingTime = openingTimes[x];
    var startTime = timeToToday(moment(openingTime.starttime, 'HH:mm:ss'), serverDateTime.time);
    var endTime = timeToToday(moment(openingTime.endtime, 'HH:mm:ss'), serverDateTime.time);

    // if opening time is set to 00:00 then the restaurant is closed.
    if (getSeconds(startTime) === 0 && getSeconds(endTime) === 0) {
      return OpeningStatus.Closed;
    }

    var timeStatus = checkTimeBetween(openingTime, serverDateTime.time, serverDateTime.time);
    if (timeStatus === TimeStatus.Before) {
      return OpeningStatus.PreOrder;
    } else if (timeStatus === TimeStatus.Between) {
      return OpeningStatus.Open;
    } else {
      OpeningStatus.Closed;
    }
  }
  return OpeningStatus.Closed; // No opening times available, close it.
};

var getPreorderTime = function getPreorderTime(serverDateTime, times, exceptionTimes) {
  var openingTimes = getCurrentOpeningTimes(serverDateTime, times, exceptionTimes);
  for (var x in openingTimes) {
    var openingTime = openingTimes[x];
    var timeStatus = checkTimeBetween(openingTime, serverDateTime.time, serverDateTime.time);
    if (timeStatus === TimeStatus.Before) {
      return openingTime;
    }
  }
};

var getCurrentOpeningTimes = function getCurrentOpeningTimes(serverDateTime, times, exceptionTimes) {
  var openingTimes = [];
  // Check if there is an exception time for today.
  if (exceptionTimes !== false && exceptionTimes != 'false') {
    var date = getDate(serverDateTime.time);
    // Filters the exceptionTimes on current date
    openingTimes = exceptionTimes.filter(function (exceptionTime) {
      return moment(exceptionTime.starttime * 1000).isSame(date, 'day');
    }).map(function (openingTime) {
      // Converts the starttime and endtime from unix timestamp to a string of hh:mm:ss
      return {
        starttime: moment(openingTime.starttime * 1000).format('HH:mm:ss'),
        endtime: moment(openingTime.endtime * 1000).format('HH:mm:ss')
      };
    });
  }

  // Do the regular times if there are no exception times.
  if (openingTimes.length === 0) {
    openingTimes = times[serverDateTime.weekDay];
  }
  return openingTimes;
};

/**
 * Set the time into the current time.
 * @property {moment} time
 * @property {moment} currentTime
 * @return {moment} the converted time.
 */
var timeToToday = function timeToToday(time, currentTime) {
  return currentTime.clone().set({
    hours: time.hours(),
    minutes: time.minutes(),
    seconds: 0
  });
};

/**
 * Set the date into the current time.
 * @property {moment} time
 * @return {moment} the converted date.
 */
var getDate = function getDate(date) {
  return moment({
    year: date.year(),
    month: date.month(),
    date: date.date()
  });
};

/**
 * Pass moment" and get seconds back.
 * @param {moment} time
 * @return {long} time in seconds
 */
var getSeconds = function getSeconds(time) {
  return (time.hours() * 60 + time.minutes()) * 60;
};

/**
 * Check the given time is it between two times.
 * @param {TimeWindow} timeWindow contains the start and end time.
 * @param {moment} compareTime the time that you want to check.
 * @param {moment} serverTime the time that is passed from the server.
 */
var checkTimeBetween = function checkTimeBetween(timeWindow, compareTime, serverTime) {
  // Convert time to sever time.
  var mStartTime = moment(timeWindow.starttime, 'HH:mm:ss');
  var mEndTime = moment(timeWindow.endtime, 'HH:mm:ss');
  var startTime = timeToToday(mStartTime, serverTime);
  var endTime = timeToToday(mEndTime, serverTime);
  var iStartTime = timeToToday(intervalStartTime, serverTime);
  var iEndTime = timeToToday(intervalEndTime, serverTime);

  // Convert time in seconds
  var serverSec = getSeconds(serverTime);
  var startSec = getSeconds(mStartTime);
  var endSec = getSeconds(mEndTime);
  var compareSec = getSeconds(compareTime);
  var intervalStartSec = getSeconds(iStartTime);
  var intervalEndSec = getSeconds(iEndTime);

  // Midnight
  var isMidnight = false;
  if (serverSec > intervalStartSec && compareSec < intervalEndSec) {
    isMidnight = true;
  }

  // It is not midnight, but maybe the start time is.
  if (!isMidnight && startSec >= intervalStartSec && startSec < intervalEndSec) {
    startTime.add(1, 'days');
  } else if (isMidnight && startSec > intervalStartSec && startSec < intervalEndSec) {
    // it means the server and start time are midnight and don't need to do any fancy stuff.
  } else if (isMidnight) {
    // it is midnight, but the start time isn't.
    startTime.add(-1, 'days');
  }

  // It is not midnight, but maybe the end time is.
  if (!isMidnight && endSec >= intervalStartSec && endSec < intervalEndSec) {
    endTime.add(1, 'days');
  } else if (isMidnight && endSec > intervalStartSec && endSec < intervalEndSec) {
    // it means the server and end time is midnight and don't need to do any fancy stuff.
  } else if (isMidnight) {
    // it is midnight, but the end time isn't.
    endTime.add(-1, 'days');
  }

  if (compareTime.isBefore(startTime)) {
    return TimeStatus.Before;
  } else if (compareTime.isBetween(startTime, endTime) || compareTime.isSame(startTime) || compareTime.isSame(endTime)) {
    return TimeStatus.Between;
  } else if (compareTime.isAfter(endTime)) {
    return TimeStatus.isAfter;
  }
};
/* global
$,
Fuse,
restaurants,
isFilterActive,
getRestaurantCount,
processHash,
Balloon,
initLazyLoad,
restaurantService,
debounce
*/

var itemsIndexed = [];
var searchRestaurant = {};

$(document).ready(function () {
  if (!$('body').hasClass('step2') || $('#irestaurantlist').length === 0) {
    return;
  }

  var options = {
    shouldSort: true,
    threshold: 0.38,
    location: 0,
    distance: 100,
    maxPatternLength: 32,
    keys: ['name']
  };
  var fuse = new Fuse(itemsIndexed, options);
  window.app.setState({
    restaurantSearchString: ''
  });

  var updateItemsIndexed = function updateItemsIndexed() {
    itemsIndexed = [];
    if (restaurants.length === 0) {
      return;
    }

    itemsIndexed = restaurants.map(function (restaurant) {
      return {
        id: restaurant[0],
        name: restaurant[4],
        hidden: restaurant.isHidden
      };
    });

    fuse = new Fuse(itemsIndexed, options);
  };

  updateItemsIndexed();

  $(document).on('keyup', '#isearchrestaurantform, #isearchrestaurantform2, #isearchrestaurantform-middle', debounce(function (event) {
    event.preventDefault();
    var searchVal = event.target.id === 'irestaurantsearchstring' || event.target.id === 'irestaurantsearchstring-middle' ? $('#' + event.target.id).val().trim() : [];
    if (itemsIndexed.length !== restaurants.length) {
      updateItemsIndexed();
    }
    if (searchVal.length === 0) {
      sponsoredLabels.hide();
      searchItems(searchVal, itemsIndexed, fuse);
      if (isFilterActive() && getRestaurantCount() === 0) {
        $('.restaurant_noresults').show();
      }
    } else {
      sponsoredLabels.show();
      searchItems(searchVal, itemsIndexed, fuse);
    }
  }, 100));

  function searchItems(searchVal, itemsIndexed, fuse) {
    var _window$app$getState = window.app.getState(),
        oldVal = _window$app$getState.restaurantSearchString;

    if (oldVal === searchVal) {
      return;
    }
    // If there are no area results, don't execute the search
    if (document.querySelector('.js-noresults-area') !== null) {
      return;
    }
    scrollUpRestaurantListingMobileSearch(searchVal);
    window.app.setState({
      restaurantSearchString: searchVal
    });
    if (searchVal.length === 0) {
      var numberOfVisibleRestaurants = restaurants.filter(function (restaurant) {
        return !restaurant.isHidden;
      }).length;

      var _window$app$getState2 = window.app.getState(),
          visibleRestaurantIds = _window$app$getState2.visibleRestaurantIds;

      if (visibleRestaurantIds.length === numberOfVisibleRestaurants) {
        $('.filter-reset-all').find('.reset-results').addClass('reset-results-hidden');
      }

      $('.restaurant_noresults').hide();
      $('.btn-search', '.subnavigation').removeClass('active');

      if (oldVal.length > 0) {
        window.app.services.tracking.send({
          eventName: 'hasResetSearching',
          eventData: {
            searchType: 'restaurant'
          }
        });
      }
      processHash();
      return false;
    }

    var result = fuse.search(searchVal);

    var lookup = {};
    for (var j in result) {
      lookup[result[j].id] = result[j].id;
    }

    var foundIds = [];
    for (var i in itemsIndexed) {
      var item = itemsIndexed[i];
      if (typeof lookup[item.id] !== 'undefined') {
        foundIds.push(item.id);
      }
    }

    window.app.setState({
      restaurantIdsFoundBySearch: foundIds
    });

    if (searchVal.length === 1 && oldVal.length <= 0) {
      window.app.services.tracking.send({
        eventName: 'hasStartedSearching',
        eventData: {
          searchType: 'restaurant'
        }
      });
    }

    if (result.length === 0) {
      $('.restaurant_noresults').show();

      window.app.services.tracking.send({
        eventName: 'hasNoSearchResults',
        eventData: {
          searchString: window.app.services.piiDataReplacer({ data: searchVal }),
          searchType: 'restaurant'
        }
      });
    } else {
      $('.restaurant_noresults').hide();
      $('.noresults--pickup').hide();
    }

    processHash();
    Balloon(getRestaurantCount());

    $('.btn-search', '.subnavigation').addClass('active');
    $(document.body).scrollTop(0);

    $('.filter-reset-all').find('.reset-results').removeClass('reset-results-hidden');

    initLazyLoad();

    // That's the only place we use restaurantService globally.
    restaurantService.UI.hideOrShowHeadersBasedOnNumberOfShownRestaurants();

    return false;
  }

  searchRestaurant.clear = function () {
    searchItems('', itemsIndexed, fuse);
  };
});

var sponsoredLabels = function () {
  var restaurantListClass = '.js-restaurantlist';
  var withoutSponsoredLabelClass = 'without-sponsored-label';

  var show = function show() {
    var restaurantListContainer = document.querySelector(restaurantListClass);
    if (restaurantListContainer) {
      restaurantListContainer.classList.add(withoutSponsoredLabelClass);
    }
  };

  var hide = function hide() {
    var restaurantListContainer = document.querySelector(restaurantListClass);
    if (restaurantListContainer) {
      restaurantListContainer.classList.remove(withoutSponsoredLabelClass);
    }
  };

  return {
    show: show, hide: hide
  };
}();

var scrollUpRestaurantListingMobileSearch = function scrollUpRestaurantListingMobileSearch(searchVal) {
  if (window.app.services.mediaQueryService.respondTo('>=tablet-landscape') === false) {
    if (searchVal.length === 0) {
      return window.scrollTo({
        top: 0,
        left: 0,
        behavior: 'auto'
      });
    }

    var $isSticky = document.querySelector('.js-kitchen-type-sticky .kitchen-type-scrolling');
    var $restaurantListContainer = document.querySelector('.js-restaurant-list-container');
    var $deviceBanner = document.querySelector('.smartbnr');
    var $btnSearch = document.querySelector('.js-btn-search');

    if ($restaurantListContainer && $isSticky && $btnSearch) {
      var scrollOffset = $restaurantListContainer.offsetTop;
      scrollOffset -= $btnSearch.offsetHeight;
      if ($deviceBanner) {
        scrollOffset -= $deviceBanner.offsetHeight;
      }

      window.scrollTo({
        top: scrollOffset,
        left: 0,
        behavior: 'auto'
      });
    }
  }
};
/* global xmlRequest, $, Helper, app */

Helper.ready(function () {
  // Update the favorite icon

  var favoriteSelector = '.js-favorite-update';

  function updateFavoriteIcon() {
    var $favoriteIcon = $(favoriteSelector);
    var currentRestaurantEncryptedId = $favoriteIcon.data('restaurant');
    if (currentRestaurantEncryptedId && $favoriteIcon) {
      var favorites = window.app.services.user.getFavoriteRestaurants();
      if (favorites && favorites.includes(currentRestaurantEncryptedId)) {
        $favoriteIcon.addClass('selected');
      }
    }
  }

  var favoriteElement = document.querySelector('.js-favorite-update');

  if (favoriteElement) {
    var currentRestaurant = favoriteElement.dataset.restaurant;
    if (currentRestaurant) {
      var isFavorite = window.app.services.user.getFavoriteRestaurants();
      if (isFavorite.includes(currentRestaurant)) {
        favoriteElement.classList.add('selected');
      }

      favoriteElement.addEventListener('click', function (event) {
        var favoAction = favoriteElement.classList.contains('selected') ? 'remove' : 'add';
        var isLoggedIn = window.app.services.user.isLogged();

        if (!currentRestaurant) {
          return;
        }

        if (isLoggedIn) {
          xmlRequest(site.local + 'setFavorite.php', 'action=' + favoAction + 'favorite&bid=' + currentRestaurant, 'idummy');
        } else {
          window.app.services.user.manageLocalFavorites(favoAction, currentRestaurant);
        }

        if (favoAction === 'add') {
          favoriteElement.classList.add('selected');
        } else {
          favoriteElement.classList.remove('selected');
        }
        return false;
      });
    }
  }

  function init() {
    updateFavoriteIcon();
  }

  init();
});
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global $, site, keyCode */
var lightboxLock = false;
var currentElement = void 0;
var allergensTranslation = void 0;
var lightboxId = 'lightbox';

$(document).on('click', '.aa-switch span.slide', function () {
  $('.meal-allergens').toggleClass('show');
});

var mealAllergensEvent = function mealAllergensEvent(eventHandler) {
  var sideDishId = eventHandler.target.classList.contains('js-meal-allergens') && eventHandler.target.dataset.sidedishId;
  var productId = eventHandler.target.classList.contains('js-product-allergens') && eventHandler.target.dataset.id;
  var documentEscapeEvent = function documentEscapeEvent(eventHandler) {
    if (eventHandler.keyCode === keyCode.ESCAPE) {
      eventHandler.preventDefault();
      eventHandler.stopPropagation();
      closeAllergensPopup(eventHandler);
    }
  };
  var closeOnClickOutside = function closeOnClickOutside(event) {
    if (event.target.contains(event.target.querySelector('.lightbox-content'))) {
      event.preventDefault();
      event.stopPropagation();
      closeAllergensPopup(event);
      return false;
    }
  };
  var closeAllergensPopup = function closeAllergensPopup() {
    var popupElement = document.getElementById(lightboxId);

    if (popupElement) {
      popupElement.parentNode.removeChild(popupElement);
    }

    if (document.body.classList.contains('stop-scroll')) {
      document.body.classList.remove('stop-scroll');
    }
    document.removeEventListener('click', closeOnClickOutside);
    document.removeEventListener('keyup', documentEscapeEvent);
    currentElement.focus();
    return false;
  };
  // Define render helpers
  currentElement = eventHandler.target;
  var $this = $(eventHandler.target);
  var renderAdditives = function renderAdditives(additives, i18n) {
    var list = additives.reduce(function (result, item) {
      return i18n.list.hasOwnProperty(item) ? result + ('<li>' + i18n.list[item] + '</li>') : result;
    }, '');

    return '\n      <div class="additives">\n        <h3>' + i18n.titles.additives + '</h3>\n        <ul>\n          ' + list + '\n        </ul>\n      </div>';
  };

  var renderAllergens = function renderAllergens(allergens, i18n) {
    var list = allergens.reduce(function (result, item) {
      return i18n.list.hasOwnProperty(item) ? result + ('<li>' + i18n.list[item] + '</li>') : result;
    }, '');

    return '\n      <div class="allergens">\n        <h3>' + i18n.titles.allergens + '</h3>\n        <ul>\n          ' + list + '\n        </ul>\n      </div>';
  };

  var renderNutrition = function renderNutrition(nutrition, i18n) {
    var list = nutrition.reduce(function (result, item) {
      return result + (item + '<br/>');
    }, '');

    return '\n      <div class="allergens">\n        <h3>' + i18n.titles.nutrition + '</h3>\n        <p>\n          ' + list + '\n        </p>\n      </div>';
  };
  var allergens = [];
  var additives = [];
  var nutrition = [];

  var renderPopup = function renderPopup(i18n) {
    lightboxLock = false;

    var oldElement = document.getElementById(lightboxId);

    if (oldElement) {
      oldElement.parentNode.removeChild(oldElement);
    }
    var noresultText = '';
    if (window.app.services.feature.isActive('AenA_always_on') && allergens.length + additives.length + nutrition.length === 0) {
      noresultText = '\n<div class="additives">\n    <h3>' + i18n.titles.noresult + '</h3>\n</div>\n';
    }

    var innerHtml = '\n    <div id="' + lightboxId + '" class="lightbox lightbox-allergens">\n      <div class="lightbox-content">\n      <div class="lightbox-header">\n        <h1>' + i18n.titles.header + '</h1>\n        <button type="button" class="js-allergens-modal-close lightbox-allergens__close"></button>\n      </div>\n\n      <div class="lightbox-contents">\n        <div class="lightbox-contents-inner">\n          ' + noresultText + '\n          ' + (additives.length ? renderAdditives(additives, i18n) : '') + '\n          ' + (allergens.length ? renderAllergens(allergens, i18n) : '') + '\n          ' + (nutrition.length ? renderNutrition(nutrition, i18n) : '') + '\n          <div class="disclaimer">' + i18n.disclaimer + '</div>\n        </div>\n      </div>\n    </div>\n    ';
    var $body = $('body');
    $body.append(innerHtml);
    $body.addClass('stop-scroll');
    document.getElementById('main').classList.add('lightbox-opened');
    var newElement = document.getElementById(lightboxId);
    window.app.helpers.keepFocusWithinModal({ modalElement: newElement });

    document.addEventListener('keyup', documentEscapeEvent);
    document.addEventListener('click', closeOnClickOutside);
    var $closeButton = document.querySelector('.js-allergens-modal-close');
    $closeButton.addEventListener('click', closeAllergensPopup);
  };

  if (window.app.services.feature.isActive('AenA_always_on')) {
    lightboxLock = true;

    var _window$app$getState = window.app.getState(),
        _window$app$getState$ = _window$app$getState.productInfo,
        productInfo = _window$app$getState$ === undefined ? {} : _window$app$getState$,
        _window$app$getState$2 = _window$app$getState.sidedishInfo,
        sidedishInfo = _window$app$getState$2 === undefined ? {} : _window$app$getState$2,
        defaultAllergensText = _window$app$getState.defaultAllergensText;

    var _ref = productInfo[productId] || sidedishInfo[sideDishId],
        _ref$attributes = _ref.attributes,
        attributes = _ref$attributes === undefined ? {} : _ref$attributes;

    if (attributes.hasOwnProperty('allergens') && attributes.allergens !== '') {
      allergens = [].concat(_toConsumableArray(attributes.allergens.toUpperCase().split(',')));
    }
    if (attributes.hasOwnProperty('additives') && attributes.additives !== '') {
      additives = [].concat(_toConsumableArray(attributes.additives.toUpperCase().split(',')));
    }

    if (attributes.hasOwnProperty('nutrition_facts') && attributes.nutrition_facts !== '') {
      nutrition = attributes.nutrition_facts.split('\n');
    }
    renderPopup(defaultAllergensText);
  } else {
    // Prepare data
    allergens = $this.data('allergens') ? $this.data('allergens').toUpperCase().split(',') : [];
    additives = $this.data('additives') ? $this.data('additives').toString().split(',') : [];
    nutrition = $this.data('nutrition') ? $this.data('nutrition').toString().split('\n') : [];

    if (!lightboxLock) {
      if (typeof allergensTranslation === 'undefined') {
        lightboxLock = true;
        $.ajax({
          url: site.aPath + 'xHttp/product/additives-allergens/' + site.language,
          type: 'get',
          dataType: 'json',
          success: function success(data) {
            allergensTranslation = data;
            renderPopup(data);
          },
          error: function error() {
            lightboxLock = false;
          }
        });
      } else {
        renderPopup(allergensTranslation);
      }
    }
    return false;
  }
};
$(document).on('click', '.js-meal-allergens', function (eventHandler) {
  if (!window.app.services.feature.isActive('AenA_always_on')) {
    mealAllergensEvent(eventHandler);
  } else {
    window.app.components.infoComponents.openAllergensInfo(eventHandler);
  }
  return false;
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global $, Swiper */
$(document).ready(function () {
  if (!$('body').hasClass('step3')) {
    return;
  }

  var menuCategoryBar = document.querySelector('.menu-category-bar');
  var menuCategoryContainer = document.querySelector('.js-menu-category-bar-sticky');
  var menuCardMainContainer = document.querySelector('.js-menucard-main-container');
  var scrollingClass = 'category-scrolling';

  var restaurantCategorySwiper = new Swiper('.js-swiper', {
    slidesPerView: 'auto',
    freeMode: true,
    loop: false,
    watchOverflow: true,
    navigation: {
      nextEl: '.swipe-next'
    }
  });

  $.fn.isInViewport = function () {
    var elementTop = $(this).offset().top;
    var elementBottom = elementTop + $(this).outerHeight();
    var viewportTop = $(window).scrollTop();
    var viewportBottom = viewportTop + $(window).height();
    var scroller = $('.menu-category-bar-container');
    var scrollerHeight = scroller.length > 0 ? scroller.outerHeight() : 0;
    var smartBanner = $('.smartbnr');
    var smartBannerHeight = smartBanner.length > 0 ? smartBanner.outerHeight() : 0;
    return elementBottom > viewportTop + scrollerHeight + smartBannerHeight && elementTop < viewportBottom;
  };

  $(document).scroll(function () {
    stickyCategories();
    scrollCategories();
  });

  function stickyCategories() {
    if (menuCardMainContainer && menuCategoryContainer && menuCategoryBar) {
      var smartBanner = document.querySelector('.smartbnr'); // added afterward, because of ajax load
      var fromTop = smartBanner ? smartBanner.getBoundingClientRect().height : 0;
      if (menuCategoryContainer.getBoundingClientRect().top <= fromTop) {
        menuCardMainContainer.classList.add(scrollingClass);
      } else {
        menuCardMainContainer.classList.remove(scrollingClass);
      }
    }
  }

  function scrollCategories() {
    // Find the heighest element in the viewport
    var heighestElement = void 0;
    $('.menucard__meals-group').each(function () {
      if ($(this).isInViewport()) {
        if (heighestElement === undefined || $(this).position().top < $(heighestElement).position().top) {
          heighestElement = this;
        }
      }
    });

    // Set the active index on the category slider
    var index = $(heighestElement).attr('anchor-id');
    if (typeof index === 'undefined') {
      if (restaurantCategorySwiper.slides && restaurantCategorySwiper.slides.length) {
        restaurantCategorySwiper.slideTo(0);
        $('.swiper-slide').removeClass('slide-active');
        $('.swiper-wrapper a:first-child').addClass('slide-active');
      }
    } else {
      var $el = $('a[href="#' + index + '"]');
      restaurantCategorySwiper.slideTo($el.index());
      $('.swiper-slide').removeClass('slide-active');
      $el.addClass('slide-active');
    }
  }

  var navigateToAnchor = function navigateToAnchor($anchorElement) {
    if ($anchorElement) {
      var targetPosition = $anchorElement.getBoundingClientRect();
      var barHeight = menuCategoryBar ? menuCategoryBar.getBoundingClientRect().height : 0;
      var smartBanner = document.querySelector('.smartbnr');
      var smartBannerHeight = smartBanner ? smartBanner.getBoundingClientRect().height : 0;
      var windowYPosition = window.scrollY | window.pageYOffset; // if IE
      var newYPosition = windowYPosition + targetPosition.top - barHeight - smartBannerHeight;
      window.scrollTo(0, newYPosition); // Options object doesn't fire in IE
      var firstMeal = $anchorElement.querySelector('.js-meal-item');
      if (firstMeal) {
        firstMeal.focus();
      }
    }
  };

  // Go to a certain category
  var swiperItems = document.querySelectorAll('.menu-category-list .swiper-slide');
  for (var j in swiperItems) {
    var swiperItem = swiperItems[j];
    if ((typeof swiperItem === 'undefined' ? 'undefined' : _typeof(swiperItem)) === 'object') {
      swiperItem.addEventListener('click', function () {
        var categoryId = this.dataset.category;
        if (categoryId) {
          var newTarget = null;
          if (categoryId !== '0') {
            // popular products
            newTarget = document.getElementById(categoryId);
          }
          if (!newTarget) {
            // assumption c1icked on the popular dishes
            newTarget = document.querySelector('.menu-meals-group-populair');
            if (!newTarget) {
              // Still nothing, select the container to scroll up
              newTarget = document.querySelector('.menu-menucard');
            }
          }
          navigateToAnchor(newTarget);
          history.replaceState(null, null, $(this).attr('href'));
        }
      });
    }
  }

  function init() {
    scrollCategories();
    stickyCategories();
  }

  init();
});
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global google */
var InfoPage = function () {
  function InfoPage() {
    _classCallCheck(this, InfoPage);
  }

  _createClass(InfoPage, [{
    key: 'initInfopageMap',
    value: function initInfopageMap() {
      var $MapWrapper = document.getElementById('infoMap');
      if ($MapWrapper) {
        var lat = parseFloat(document.getElementById('lat').value);
        var lng = parseFloat(document.getElementById('long').value);

        if (lat !== 0 && lng !== 0) {
          var zoom = 16;
          var loc = { lat: lat, lng: lng };
          var latCenter = lat - 40 / Math.pow(2, zoom);

          var noPoi = [{
            featureType: 'poi',
            stylers: [{ visibility: 'off' }]
          }];
          var infoMapOptions = {
            zoom: zoom,
            center: { lat: latCenter, lng: lng },
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            mapTypeControl: false,
            streetViewControl: false,
            disableDefaultUI: true,
            draggable: false,
            scrollwheel: false,
            navigationControl: false,
            styles: noPoi
          };

          var infoMap = new google.maps.Map(document.getElementById('infoMap'), infoMapOptions);
          var markerTitle = '';
          var elementTitle = document.querySelector('.js-restaurant-title');
          if (elementTitle) {
            markerTitle = elementTitle.textContent;
          }

          // eslint-disable-next-line no-new, because google.maps.Marker is not a real class
          new google.maps.Marker({
            position: loc,
            map: infoMap,
            icon: {
              url: '//static.takeaway.com/images/googleMarker/marker2x.png',
              // 42px wide by 54 heigh
              scaledSize: new google.maps.Size(42, 54)
            },
            title: markerTitle
          });
        }
      }
    }
  }]);

  return InfoPage;
}();
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global
  $,
  AutoComplete,
  basket,
  CategoryOrderTimes,
  closeLightbox,
  Cookies,
  currentprice,
  currentPriceObj,
  currentRestaurant,
  format_price,
  getOpeningStatus,
  getPreorderTime,
  keyCode,
  MenucardProducts,
  moment,
  newvalue,
  newValue,
  oldPriceObj,
  oldvalue,
  OpeningStatus,
  optionValue,
  Pickup,
  productId,
  safari,
  selectedValue,
  site,
  Takeaway,
  toast,
  tooltip,
  TranslationsJSobject,
*/

// For caching purpose. When showSidedishes.php(removed) is called, store the selected product in here.
var selectedProduct = null;

// Show notification that delivery area info is needed
function menucard_DeliveryAreaNeeded(restid) {
  $.post(site.local + 'xHttp/showDeliveryArea.php', { restid: restid }).done(function (response) {
    if (response.status === 'OK') {
      window.app.components.locationPanel.UI.openPopup();
      window.app.components.locationPanel.UI.setClickSourceMeal();
      window.app.components.locationPanel.UI.removeInfoMessageIfExists();
      // Classname "lp__message" is important because new locationPanel.js removes it on every closePopup()
      $('.lp-popup .lp__places-container').prepend('<div class="lp__message">' + response.value + '</div>');
    }
  });
}

function formatQueryPostcode(postcode) {
  if (site.cc == 180 || site.cc == 239) {
    // Poland
    return postcode;
  } else if (site.cc == 181) {
    // Portugal
    var reg = new RegExp('[^0-9-]', 'g');
    return postcode.replace(reg, '');
  } else {
    // all other
    var _reg = new RegExp('[^0-9]', 'g');
    return postcode.replace(_reg, '');
  }
  return postcode;
}

function fomatQuerySplitPostcode(postcode) {
  // for now only do this for Netherlands / Belgium / Lieferservice
  if (site.cc != 1 && site.cc != 3 && site.cc != 6) {
    return postcode;
  }

  var splitpc = Cookies.get('deliveryareaid');
  if (typeof splitpc !== 'undefined') {
    var reg = new RegExp('[^0-9]', 'g');
    if (postcode.replace(reg, '') == splitpc.replace(reg, '')) {
      return splitpc;
    }
  }
  return postcode;
}

var parseQueryString = function parseQueryString() {
  var str = window.location.search;
  var objURL = {};

  str.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'), function ($0, $1, $2, $3) {
    objURL[$1] = $3;
  });
  return objURL;
};

/**
 * Returns user's delivery area (postcode) if there is one
 *
 * @returns {string/null}
 */
function getUsersDeliveryAreaId() {
  var postcode = Cookies.get('postcode');
  // Remove letters from postcode: e.g. 8766TS > 8766
  if (typeof postcode !== 'undefined') {
    postcode = formatQueryPostcode(postcode);
    postcode = fomatQuerySplitPostcode(postcode);
  }
  // If deliveryAreaId cookie is like '8888-alpha', use it instead of '8888'
  if (typeof postcode !== 'undefined') {
    var deliveryAreaId = Cookies.get('deliveryareaid');
    if (typeof deliveryAreaId !== 'undefined' && postcode !== deliveryAreaId && postcode === deliveryAreaId.split('-')[0]) {
      postcode = deliveryAreaId;
      console.log('getUsersDeliveryAreaId(): (split postcode) return: ', deliveryAreaId);
    }
  }

  // If website is Vietnam, take 'searchstring2' as postcode
  if (typeof postcode === 'undefined' && Cookies.get('searchstring1') && Cookies.get('searchstring2')) {
    postcode = Cookies.get('searchstring2');
    console.log('getUsersDeliveryAreaId(): (vietnam) return:', postcode);
  }

  /**
   * Set customer cookies if urlhash exists of a valid postcode
   *
   */
  var postcodeHash = location.hash;
  postcodeHash = postcodeHash.replace(/^#/, '');

  if (AutoComplete.settings && !$.trim(postcodeHash).match(AutoComplete.settings.pcMatch)) {
    // possible that the hash has some get variables in it (utm tags),
    // therefore try to remove them
    var match = postcodeHash.split('?');

    if ($.trim(match[0]).match(AutoComplete.settings.pcMatch)) {
      postcodeHash = match[0];
    }
  }

  //
  // FED-4289 - Chain api
  //
  var urlParams = new URLSearchParams(window.location.search);

  if (urlParams.has('postcode') && urlParams.has('lat') && urlParams.has('lng') && AutoComplete.settings && urlParams.get('postcode').match(AutoComplete.settings.pcMatch)) {
    console.log('Parse URL succesfull! Ordering possible, update settings');

    postcodeHash = urlParams.get('postcode');

    Cookies.set('latitude', urlParams.get('lat'), { expires: 365, path: site.path, secure: true });
    Cookies.set('longitude', urlParams.get('lng'), { expires: 365, path: site.path, secure: true });

    urlParams.delete('postcode');
    urlParams.delete('lat');
    urlParams.delete('lng');

    var urlParamsString = urlParams.toString() ? '?' + urlParams.toString() : '';
    window.history.pushState('', document.title, window.location.pathname + urlParamsString);
  }

  //
  // FED-4289 - Chain api
  //

  if (AutoComplete.settings && postcodeHash !== '' && $.trim(postcodeHash).match(AutoComplete.settings.pcMatch)) {
    postcode = postcodeHash;
    Cookies.set('postcode', postcode, { expires: 365, path: site.path, secure: true });
    Cookies.set('searchstring', postcode, { expires: 365, path: site.path, secure: true });
    console.log('getUsersDeliveryAreaId(): (found using hash) return:', postcode);

    window.app.services.headerService.updateLocationPanelString();
    history.pushState('', document.title, location.pathname + location.search); // clear hash from url
  }

  return typeof postcode !== 'undefined' ? postcode : null;
}

function hasRestaurantDeliveryAreaForPostcodeSearch(postcode) {
  var returnLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  for (var i in currentRestaurant.Locations) {
    var area = currentRestaurant.Locations[i];

    // This is especially for Vietnam
    if (returnLocation) {
      if (postcode === area.locationid.toString()) {
        return area.deliveryareaid.toString();
      }
    } else {
      if (postcode === area.deliveryareaid.toString()) {
        return true;
      }
    }
  }
  return false;
}

function hasRestaurantDeliveryAreaForPolygonSearch(postcode) {
  // This is an array of objects (mostly one object,
  // sometimes multiple multi-polygons), let's process each of them
  for (var i = 0; i < currentRestaurant.Polygons.length; i++) {
    if (currentRestaurant.Polygons[i].deliveryareaid === postcode) {
      return true;
    }
  }
  return false;
}

function isDeliveryPossible() {
  var deliveryArea = getUsersDeliveryAreaId();
  var postCode = Cookies.get('postcode');
  // searchString may be like '7522 dc', so remove spaces and make it uppercase
  var searchString = Cookies.get('searchstring');
  searchString = typeof searchString === 'string' ? searchString.replace(/\s/g, '').toUpperCase() : '';

  // prevent backbutton being pressed and using outdated lat lng data to calculate polygons
  if (site.cc == 45) {
    if (typeof postCode !== 'undefined') {
      if (deliveryArea !== formatQueryPostcode(postCode)) {
        polygons = false;
      }
    }
  }

  var isPostalCodeSearchResult = window.app.services.search.isPostalCodeSearch({
    postalCode: postCode,
    countryCode: site.iso,
    searchString: searchString
  });

  var isPolygonSearchEnabled = window.app.services.search.isPolygonSearchEnabled({
    pickupStatus: Pickup.getCurrentStatus(),
    isPostalCodeSearch: isPostalCodeSearchResult,
    usersLastSearchHasGeolocation: window.app.services.user.location,
    restaurantHasPolygon: typeof currentRestaurant.Polygons !== 'undefined' && currentRestaurant.Polygons.length > 0
  });

  if (Pickup.isPickupStatus()) {
    console.log('isDeliveryPossible(): true, pickup mode');
    return true;
  }

  if (!deliveryArea) {
    console.log('isDeliveryPossible(): false, no getUsersDeliveryAreaId()');
    return false;
  }

  if (isPolygonSearchEnabled && hasRestaurantDeliveryAreaForPolygonSearch(deliveryArea)) {
    // Look if user is inside the polygon

    // We already know deliveryArea, so we can filter them from original polygons array
    var filteredPolygons = currentRestaurant.Polygons.filter(function (x) {
      return x.deliveryareaid === deliveryArea;
    });
    console.log('isDeliveryPossible(): filteredPolygons', filteredPolygons);

    // THE polygon index that we try to find
    var polygonIndex = false;

    // filter() returns an empty Array if it can't find anything
    if (filteredPolygons.length) {
      polygonIndex = window.app.services.polygon.isPointInPolygons(window.app.services.user.location, filteredPolygons);

      if (polygonIndex !== false) {
        console.log('isDeliveryPossible(): filtered polygonIndex', polygonIndex);
        var polygon = filteredPolygons[polygonIndex];
        polygonIndex = currentRestaurant.Polygons.findIndex(function (x) {
          return x === polygon;
        });
        console.log('isDeliveryPossible(): original polygonIndex', polygonIndex);
      }
    } else {
      // This can be considered as fallback search in all polygons
      // May also be deleted if we don't need it anymore
      polygonIndex = window.app.services.polygon.isPointInPolygons(window.app.services.user.location, currentRestaurant.Polygons);
    }

    if (polygonIndex !== false) {
      var response = { searchType: 'address', postcode: deliveryArea, polygonIndex: polygonIndex };
      console.log('isDeliveryPossible(): user is inside a polygon:', response);
      return response;
    } else {
      // Return false when it's not found in the polygon (equal to Develop branch)
      console.log('isDeliveryPossible(): false, no delivery to userService.Location:', window.app.services.user.location);
      return false;
    }
  }

  if (currentRestaurant.Settings.PostcodeSupport) {
    // All countries
    if (hasRestaurantDeliveryAreaForPostcodeSearch(deliveryArea)) {
      console.log('isDeliveryPossible(): user is inside a postcode:', deliveryArea);
      return { searchType: 'postcode', postcode: deliveryArea };
    }
  } else {
    // Vietnam
    var realDeliveryArea = hasRestaurantDeliveryAreaForPostcodeSearch(deliveryArea, true);
    if (realDeliveryArea) {
      console.log('isDeliveryPossible(): (vietnam) user is inside a postcode:', realDeliveryArea, 'original input:', deliveryArea);
      return { searchType: 'postcode', postcode: realDeliveryArea };
    }
  }

  console.log('isDeliveryPossible(): false, no delivery to:', deliveryArea);
  return false;
}

function canOrderFromCategoryNow(formId) {
  var menuCatId = $('#' + formId).find('input[name="menucat"]').val();

  if (typeof CategoryOrderTimes[menuCatId] !== 'undefined' && CategoryOrderTimes[menuCatId] === true) {
    return false;
  }
  return true;
}

// Add simple product to basket
function menucard_AddSimpleProductToBasket(productId) {
  // TODO block sidedish opening in PHP
  // TODO Check emergency
  if (showEmergencyMessage()) {
    return false;
  }

  if (!isDeliveryPossible()) {
    menucard_DeliveryAreaNeeded(currentRestaurant.Id);
    return false;
  }

  basket.addProduct(productId);
  menucard_CloseSideDishes();
  selectedProduct = null;
  return false;
}

// Add product with size/sidedishes to basket
function menucard_AddExtendedProductToBasket(productId) {
  if (!isDeliveryPossible()) {
    menucard_DeliveryAreaNeeded(currentRestaurant.Id);
    return false;
  }

  for (var x in selectedProduct.sizes) {
    var size = selectedProduct.sizes[x];
    if (size.id === productId) {
      basket.addProduct(selectedProduct.productId);
      menucard_CloseSideDishes();
      delete selectedProduct.sizes;
      selectedProduct = null;
      return false;
    }
  }
  throw new Error('Product mismatched');
  return false;
}

function menucard_CloseSideDishes() {
  $('.sidedish-pop-in').html('');
  $('.meal-sidedish').each(function () {
    $(this).removeClass('meal-sidedish');
    $('.menu-meal-add', $(this)).removeAttr('disabled');
  });
  $('.js-meal__add-to-basket-button').removeClass('menucard-meal__sidedish-button--expand');
}

// Show sidedishes pop-in
function menucard_ShowSideDishes(formId, destId) {
  // Show emergency message
  if (showEmergencyMessage()) {
    return false;
  }

  // Check if restaurant is Open
  if (basket.restaurant.isClosed()) {
    basket.showRestaurantIsClosed();
    return false;
  }

  if (!isDeliveryPossible()) {
    menucard_DeliveryAreaNeeded(currentRestaurant.Id);
    return false;
  }

  $('.sidedish-pop-in').html('');
  $('.menu-meal-add').removeAttr('disabled');
  $('.meal.meal-sidedish').removeClass('meal-sidedish');
  // handle post and on completion load response in pop-in and scroll to it.
  $.ajax({
    url: site.aPath + 'xHttp/product/side-dishes?pickup=' + Pickup.getCurrentStatus(),
    type: 'get',
    headers: {
      'Cache-Control': 'no-cache',
      'Takeaway-Accept-Language': site.language
    },
    data: $('#' + formId).serialize(),
    dataType: 'html',
    success: function success(data) {
      var obj = $.parseJSON(data);

      var productId = $('input[name="product"]', '#' + formId).val();
      console.log('menucard_ShowSideDishes() success: productId', productId);
      var mealDiv = $('#' + formId).closest('.meal');

      $('#' + destId).html(obj.html);

      // Get the product from the object literal and pass the size/sidedishes into it.
      var id = void 0;
      // find() returns 'undefined' if nothing found
      var sidedish = obj.json.find(function (x) {
        return x.id === productId;
      });

      id = sidedish ? sidedish.id : obj.json[0].id; // Old way fallback: Get the first sidedish

      selectedProduct = MenucardProducts.filter(function (x) {
        return x.productId === id && x.categoryId !== '0';
      })[0];
      console.log('menucard_ShowSideDishes() success: selectedProduct', selectedProduct);

      selectedProduct.sizes = obj.json;
      // By default the first size is selected.
      selectedProduct.sizes[0].isSelected = true;
      // If the sidedish group is a pull down, then the first one will be selected.
      for (var x in selectedProduct.sizes) {
        var size = selectedProduct.sizes[x];
        if (size.sidedishes !== false) {
          for (var xx in size.sidedishgroups) {
            var sidedishGroup = size.sidedishgroups[xx];
            // Pulldown could be either 1 or 3?
            if (sidedishGroup.type === '1' || sidedishGroup.type === '3') {
              sidedishGroup.sidedishes[0].isSelected = true;
            }
          }
        }
      }

      $('.menu-meal-add', mealDiv).first().attr('disabled', 'disabled');
      if ($('.aa-switch input').prop('checked')) {
        $('.meal-allergens').addClass('show');
      }

      $('html,body').animate({ scrollTop: mealDiv.offset().top - $('.subnavigation').height() }, 600, 'swing');
      mealDiv.addClass('meal-sidedish');
    }
  });

  return false;
}

function showEmergencyMessage() {
  if (site.emergency) {
    var emergencyClosed = $('#emergencymessage').text();
    if (emergencyClosed) {
      // TODO: Make this also use the new toast message
      toast(emergencyClosed);
    }
    return true;
  }

  if (window.app && window.app.services && window.app.services.headerService && window.app.services.headerService.pickupDisabled && window.app.services.headerService.pickupDisabled(Pickup.isPickupStatus())) {
    return true;
  }

  return false;
}

/**
 * When change product size.
 */
$(document).on('change', '#isizeselection', function (e) {
  var id = $(e.target.options[e.target.options.selectedIndex]).data('id');
  for (var x in selectedProduct.sizes) {
    var size = selectedProduct.sizes[x];
    size.isSelected = false;
    if (size.id === id) {
      size.isSelected = true;
    }
  }
});

/**
 * When clicked on sidedish view more button.
 */
$(document).on('click', '.sidedishes .sidedish-checkboxgroup .show-more', function (event) {
  event.preventDefault();
  event.stopPropagation();
  var element = $(this);
  element.toggleClass('active');

  if (element.hasClass('active')) {
    element.text(element.data('less'));
  } else {
    element.text(element.data('more'));

    var mealDiv = element.closest('.meal');

    $('html,body').animate({
      scrollTop: mealDiv.offset().top - $('.subnavigation').height()
    }, 600, 'swing');
  }

  element.parent().children('.sidedish-overflow').slideToggle('fast');
});

/**
 * When clicked on sidedish checkbox.
 */
$(document).on('click', '.sidedishes .sidedish-checkbox input', function (e) {
  var isChecked = e.target.checked;
  var target = $(e.target);
  var id = target.data('sidedishid').toString();
  for (var x in selectedProduct.sizes) {
    var size = selectedProduct.sizes[x];
    if (size.isSelected) {
      for (var xx in size.sidedishgroups) {
        var group = size.sidedishgroups[xx];
        for (var xxx in group.sidedishes) {
          var sidedish = group.sidedishes[xxx];
          if (sidedish.id === id) {
            sidedish.isSelected = isChecked;
            return;
          }
        }
      }
    }
  }
});

/**
 * When change sidedish pull down
 */
$(document).on('change', '.sidedishes .sidedish-select .select-input select', function (e) {
  var id = $(e.target.options[e.target.options.selectedIndex]).data('sidedishid').toString();
  for (var x in selectedProduct.sizes) {
    var size = selectedProduct.sizes[x];
    if (size.isSelected) {
      for (var xx in size.sidedishgroups) {
        var group = size.sidedishgroups[xx];
        for (var xxx in group.sidedishes) {
          var sidedish = group.sidedishes[xxx];
          if (sidedish.id === id) {
            sidedish.isSelected = true;
            // Deselect the others fromt the same group.
            // Very lame, but there is no group id to check where the side dish belongs to.
            for (var xxxx in group.sidedishes) {
              var s = group.sidedishes[xxxx];
              if (s.id !== id) {
                s.isSelected = false;
              }
            }
          }
        }
      }
    }
  }
});

// DELETE: NOT USED FOR IN STATIC BASKET. Just use the simple toast().
function menucard_ShowNotification(referingObject, postvars) {
  // remove all tooltips
  $('.tooltip').remove();

  // get the productId of the related product form
  productId = $('input[name="product"]', referingObject).val();
  // inject a div at the start of the form to hold the notification tooltip if not yet existing
  if ($('#tooltipdiv' + productId).length === 0) {
    $('#' + referingObject.id).prepend('<div id="tooltipdiv' + productId + '"></div>');
  }
  // load content into the injected tooltipdiv
  // xmlRequest(site.local+'xHttp/showNotification.php', postvars, 'tooltipdiv'+productId);
  tooltip = $('#tooltipdiv' + productId);
  tooltip.html(postvars);
  referingButton = $('div.button_add', referingObject);

  // add correct classes
  tooltip.addClass('tooltip').delay(3000).fadeOut(200);
  return false;
}

function showSize(selectedValue) {
  var selectedValueParts = selectedValue.split(';');
  var sizedProductId = selectedValueParts[0];

  $('.sidedishformcontainer').addClass('hidden');
  $('#isidedishformcontainer' + sizedProductId).removeClass('hidden');

  // Hide all size attributes
  $('#sizeattributecontainer' + sizedProductId).parents('.js-meal-description-text').children('.sizeattributecontainer').addClass('hidden');

  // Show relevant size attribute line
  $('#sizeattributecontainer' + sizedProductId).removeClass('hidden');
}

/** checkbox in sidedish pop-in
 *
 */
function changeTotalSidedishPriceCheckbox(nr, nrofdecimals, decimalsepp, thousandsepp, symb, sidedishselector, productid) {
  // get current price object
  currentPriceObj = $('#isidedishprice' + productid);
  var currentprice = parseFloat(currentPriceObj.val());
  // get price from checkbox element
  if (!isNaN(currentprice)) {
    if (sidedishselector.checked) {
      // add pr
      currentPriceObj.val((Math.round(nr * 100) + Math.round(currentprice * 100)) / 100);
    } else {
      // substract pr
      currentPriceObj.val((Math.round(currentprice * 100) - Math.round(nr * 100)) / 100);
    }
    updateBtnPrice($('.sidedish-add-button', '#isidedishselectionform' + productid), currentPriceObj.val(), productid);
  }
}

/** pulldown in sidedish pop-in
 *
 */
function changeTotalSidedishPricePulldown(nrofdecimals, decimalsepp, thousandsepp, symb, pulldownselector, productid) {
  // get current price object
  currentPriceObj = $('#isidedishprice' + productid);
  // get object containing price before current change
  oldPriceObj = $('#isidedishselectvalue_' + pulldownselector.id.split('_')[1]);
  // get price from pulldown option element
  optionValue = $('#' + pulldownselector.id).find(':selected').val().split(';');
  newValue = optionValue.length >= 2 ? optionValue[1] : 0;

  currentprice = parseFloat(currentPriceObj.val());
  oldvalue = parseFloat(oldPriceObj.val());
  newvalue = parseFloat(newValue);
  if (!isNaN(currentprice) && !isNaN(oldvalue) && !isNaN(newvalue)) {
    // calculate new price
    currentPriceObj.val((Math.round(currentprice * 100) - Math.round(oldvalue * 100) + Math.round(newvalue * 100)) / 100);
    // update oldValue to contain the current selected value
    oldPriceObj.val(newValue);
    // update price on button
    updateBtnPrice($('.sidedish-add-button', '#isidedishselectionform' + productid), currentPriceObj.val(), productid);
  }
}

/** pulldown in sidedish pop-in update inline description
 *
 */
function changeSidedishDescription(pulldownselector, productid) {
  selectedValue = $(pulldownselector).find(':selected').val();
  // hide descriptors except the one belonging to the selected value
  $('.inline-desc > span', $(pulldownselector).parent()).each(function () {
    if ($(this).attr('id') != selectedValue) {
      $(this).addClass('hidden');
    } else {
      $(this).removeClass('hidden');
    }
  });
}

/**
 * Updates price on button_add styled buttons
 */
function updateBtnPrice(btnObj, price, productid) {
  // apply multiplier
  price = price * parseInt($('#ibasketproductnrspan' + productid).html());

  var prodPriceLabel = false;
  var useheading = false;
  prodPriceLabel = btnObj.find('.button_add_value').find('span').html();
  if (typeof prodPriceLabel !== 'undefined') {
    useheading = true;
    prodPriceLabel = '<span class="wai_screenreader">' + prodPriceLabel + '</span>';
  }
  if (useheading) {
    btnObj.find('.button_add_value').html('<h3>' + format_price(price, currentRestaurant.Currency) + prodPriceLabel + '</h3>');
  } else {
    btnObj.find('.button_add_value').html(format_price(price, currentRestaurant.Currency) + prodPriceLabel);
  }
  return false;
}

/**
 * Updates open status label in map on info page
 */
function InfoPageOpenLabelUpdate(DOMElement) {
  var _window$app$getState = window.app.getState(),
      normalizedServerTime = _window$app$getState.normalizedServerTime;

  var RestaurantTimes = currentRestaurant.Times.deliveryopentimes;
  var RestaurantExceptionTimes = currentRestaurant.Times.exceptionsdelivery;

  // if pickup is selected, use pickup times to calculate open/closed
  if (Pickup.isTakeawayStatus() === false) {
    RestaurantTimes = currentRestaurant.Times.pickupopentimes;
    RestaurantExceptionTimes = currentRestaurant.Times.exceptionspickup;
  }

  // sometimes we have no exception times, make sure it then takes the false value
  if (!RestaurantExceptionTimes) {
    RestaurantExceptionTimes = false;
  }

  var RestaurantOpenState = getOpeningStatus(normalizedServerTime, RestaurantTimes, RestaurantExceptionTimes);

  if (currentRestaurant.Open === '1') {
    switch (RestaurantOpenState) {
      case Pickup.isTakeawayStatus() && OpeningStatus.Closed:
        // Todo: Find first opening day+time and report that
        // If all fails: show closed
        DOMElement.html(TranslationsJSobject.closed_for_delivery);
        DOMElement.removeClass('open');
        DOMElement.removeClass('preorder');
        DOMElement.addClass('closed');
        break;
      case Pickup.isPickupStatus() && OpeningStatus.Closed:
        DOMElement.html(TranslationsJSobject.closed_for_pickup);
        DOMElement.removeClass('open');
        DOMElement.removeClass('preorder');
        DOMElement.addClass('closed');
        break;
      case OpeningStatus.Open:
        DOMElement.html(TranslationsJSobject.open);
        DOMElement.removeClass('closed');
        DOMElement.removeClass('preorder');
        DOMElement.addClass('open');
        break;
      case OpeningStatus.PreOrder:

        var preOrderTime = getPreorderTime(normalizedServerTime, RestaurantTimes, RestaurantExceptionTimes);
        var preOrderLabel = moment(preOrderTime.starttime, 'HH:mm:ss').format('HH:mm');

        DOMElement.html(TranslationsJSobject.openfrom + ' ' + preOrderLabel);
        DOMElement.removeClass('open');
        DOMElement.removeClass('closed');
        DOMElement.addClass('preorder');
        break;
    }
  } else {
    DOMElement.html(TranslationsJSobject.closed);
    DOMElement.removeClass('open');
    DOMElement.removeClass('preorder');
    DOMElement.addClass('closed');
  }
}

function closeSideDish($mealButtonElement) {
  var $sideDishElement = $mealButtonElement.closest('.js-meal-container');
  $('body').removeClass('fullscreen');
  $('html').removeClass('fullscreen');
  $sideDishElement.removeClass('meal-sidedish');
  $('.menu-meal-add').removeAttr('disabled');
  $mealButtonElement.find('.js-meal__add-to-basket-button').removeClass('menucard-meal__sidedish-button--expand');
  $sideDishElement.find('.sidedish-pop-in').html('');
}

$(document).ready(function () {
  /**
   * Main function to submit the form for a meal
   * Either adding it to the basket via menucard_AddSimpleProductToBasket (fn)
   * or by opening the sidedishes via menucard_ShowSideDishes (fn)
   */

  var MenuCard = function () {
    var useBuffer = true;
    var sideDishAction = void 0;
    var buffer = {
      json: [],
      sidedishes: []
    };

    function init() {
      var $mealItem = $('.js-meal-item');

      function menuCardButtonClick(event) {
        // Don't fire when user clicks the alergens popup button
        if (event && event.target && event.target.classList.contains('js-meal-allergens')) {
          return;
        }
        var $buttonMenucard = $(event.target).closest('.js-meal-container');
        if ($buttonMenucard.find('.js-meal__add-to-basket-button').length === 0) {
          console.log('Cannot order this product at the moment');
          return false;
        }

        if (showEmergencyMessage()) {
          return false;
        }

        if (basket.restaurant.isClosed()) {
          console.log('Restaurant is closed');
          basket.showRestaurantIsClosed();
          return false;
        }

        if (!Pickup.isPickupStatus()) {
          // delivery mode, so let's check if delivery is possible
          if (!isDeliveryPossible()) {
            console.log('No delivery possible');
            menucard_DeliveryAreaNeeded(currentRestaurant.Id);
            return false;
          }
        } // when pickup mode, don't care about the location

        var action = 'addSimpleProduct';
        var hasSidedishes = $buttonMenucard.find('.js-has-sidedishes').length > 0;
        var sideDishesLoaded = $buttonMenucard.find('.sidedish-pop-in').text().trim() !== '';

        if (hasSidedishes) {
          action = 'openSideDishes';
          if (sideDishesLoaded) {
            // If sidedishes are already loaded, then close
            action = 'closeSideDishes';
          }
        }

        switch (action) {
          case 'addSimpleProduct':
            console.log('addSimpleProduct');
            addSimpleProductToBasket($buttonMenucard);
            break;
          case 'openSideDishes':
            console.log('openSideDishes');
            openSideDishes($buttonMenucard);
            break;
          case 'closeSideDishes':
            console.log('closeSideDishes');
            closeSideDish($buttonMenucard);
            break;
        }
      }

      $mealItem.bind('click', menuCardButtonClick);
      $mealItem.bind('keyup', function (eventHandler) {
        // $mealItem is a div
        // to keep functionality simular to a button
        // add same keyboard events for pressing a button.
        if (eventHandler.keyCode === keyCode.ENTER || eventHandler.keyCode === keyCode.SPACE) {
          return menuCardButtonClick(eventHandler);
        }
      });

      if (isStep3() && currentRestaurant && currentRestaurant.Pickup === Takeaway.DeliveryMethod.Type.DeliveryAndPickup) {
        var $mealContainers = $('.js-meal-container');
        $mealContainers.first().map(function (key, element) {
          var jsondata = getMealJson($(element));
          if (typeof jsondata.prices !== 'undefined') {
            updateMealPrices($mealContainers);
          }
        });
      }

      var mealAttributeDescriptionContainers = [].concat(_toConsumableArray(document.querySelectorAll('.sizeattributecontainer .meal__description-attribute-descriptions')));
      var isTakeawayStatus = Pickup.isTakeawayStatus();

      mealAttributeDescriptionContainers.forEach(function (mealAttributeDescriptionContainer) {
        var lastChild = void 0;

        mealAttributeDescriptionContainer.childNodes.forEach(function (mealAttributeDescription) {
          if (!isTakeawayStatus && mealAttributeDescription.classList.contains('meal__description-attribute-description--delivery') || isTakeawayStatus && mealAttributeDescription.classList.contains('meal__description-attribute-description--pickup')) {
            mealAttributeDescription.classList.add('hidden');
          }

          if (!mealAttributeDescription.classList.contains('hidden')) {
            lastChild = mealAttributeDescription;
          }
        });

        if (lastChild) {
          lastChild.classList.add('meal__description-attribute-description--last-child');
        }
      });
    }

    function getMealKey($meal) {
      return $meal.attr('id');
    }

    function getMealJson($meal) {
      var mealKey = getMealKey($meal);
      var jsondata = void 0;
      if (useBuffer === true && buffer.json.hasOwnProperty(mealKey)) {
        jsondata = buffer.json[mealKey];
      } else {
        jsondata = $meal.find('.meal__wrapper .meal-json').text();
        if (jsondata) {
          jsondata = JSON.parse(jsondata);
          buffer.json[mealKey] = jsondata;
        }
      }
      return jsondata;
    }

    function renderSideDishes($meal, obj) {
      var jsondata = getMealJson($meal);
      var productId = jsondata.product;
      console.log('menucard_ShowSideDishes() success: productId', productId);
      $meal.find('.sidedish-pop-in').html(obj.html);

      // Get the product from the object literal and pass the size/sidedishes into it.
      // find() returns 'undefined' if nothing found
      var sidedish = obj.json.find(function (x) {
        return x.id === productId;
      });

      var id = sidedish ? sidedish.id : obj.json[0].id; // Old way fallback: Get the first sidedish

      selectedProduct = MenucardProducts.filter(function (x) {
        return x.productId === id && x.categoryId !== '0';
      })[0];
      console.log('menucard_ShowSideDishes() success: selectedProduct', selectedProduct);
      selectedProduct.sizes = obj.json;
      // By default the first size is selected.
      selectedProduct.sizes[0].isSelected = true;
      // If the sidedish group is a pull down, then the first one will be selected.
      for (var x in selectedProduct.sizes) {
        var size = selectedProduct.sizes[x];
        if (size.sidedishes !== false) {
          for (var xx in size.sidedishgroups) {
            var sidedishGroup = size.sidedishgroups[xx];
            // make sure all sidedish items have isSelected = false
            sidedishGroup.sidedishes.forEach(function (item) {
              item.isSelected = false;
            });
            // Pulldowns should have first item isSelected = true
            if (sidedishGroup.type === '1' || sidedishGroup.type === '3') {
              sidedishGroup.sidedishes[0].isSelected = true;
            }
          }
        }
      }

      $meal.find('.menu-meal-add').attr('disabled', 'disabled');

      if ($('.aa-switch input').prop('checked')) {
        $('.meal-allergens').addClass('show');
      }

      $('html,body').animate({ scrollTop: $meal.offset().top - $('.subnavigation').height() }, 600, 'swing');
      $meal.addClass('meal-sidedish');
      $meal.find('.js-meal__add-to-basket-button').addClass('menucard-meal__sidedish-button--expand');
    }

    function openSideDishes($meal) {
      $('.sidedish-pop-in').html('');
      $('.menu-meal-add').removeAttr('disabled');
      $('.meal.meal-sidedish').removeClass('meal-sidedish');
      $('.js-meal__add-to-basket-button').removeClass('menucard-meal__sidedish-button--expand');
      // handle post and on completion load response in pop-in and scroll to it.

      if (sideDishAction) {
        sideDishAction.abort();
      }

      var mealKey = getMealKey($meal);
      if (useBuffer === true && buffer.sidedishes.hasOwnProperty(mealKey)) {
        console.log('rendering sidedishes from the buffer');
        var obj = buffer.sidedishes[mealKey];
        renderSideDishes($meal, obj);
        return;
      }

      var jsondata = getMealJson($meal);
      console.log('jsondata', jsondata);

      sideDishAction = $.ajax({
        url: site.aPath + 'xHttp/product/side-dishes?pickup=' + Pickup.getCurrentStatus(),
        type: 'get',
        headers: {
          'Cache-Control': 'no-cache',
          'Takeaway-Accept-Language': site.language
        },
        data: jsondata,
        dataType: 'html',
        success: function success(data) {
          var obj = $.parseJSON(data);
          buffer.sidedishes[mealKey] = obj;
          renderSideDishes($meal, obj);
        }
      });

      return false;
    }

    function addSimpleProductToBasket($meal) {
      $('.js-meal__add-to-basket-button').removeClass('menucard-meal__sidedish-button--expand');
      var jsondata = getMealJson($meal);
      console.log('jsondata', jsondata);
      basket.addProduct(jsondata.product);
      menucard_CloseSideDishes();
      selectedProduct = null;
      return false;
    }

    var updateMealPrices = function updateMealPrices($mealContainers) {
      var pickupMode = Pickup.getCurrentStatus();
      $mealContainers.each(function (key, element) {
        var meal = $(element);
        var jsondata = getMealJson(meal);
        meal.find('.meal__price').html(jsondata.prices[pickupMode]);
      });
    };
    var isStep3 = function isStep3() {
      return $(document.body).hasClass('step3');
    };

    return { init: init };
  }();

  MenuCard.init();

  function updateGoBackUrl() {
    if (window.currentRestaurant) {
      // Cache cookie value as it is a slow check
      // Don't overwrite the default url (that contains the postcode of the
      // restaurant's own address) if there is no match with the postcode
      // of the user, maybe it's just a search engine crawler
      var postCode = Cookies.get('postcode') || Cookies.get('AID');
      if (postCode) {
        postCode = fomatQuerySplitPostcode(formatQueryPostcode(postCode));
        $('.js-go-back-button').attr('href', '' + site.local + postCode + '?back');
      }
    }
  }

  if ($(document.body).hasClass('step3')) {
    InfoPageOpenLabelUpdate($('.openstate'));
    updateGoBackUrl();
  }
});

/**
 * Fix Back-forward cache for Safari + step3
 * @see FED-4200
 */
window.onpageshow = function (event) {
  var isStep3 = document.body.classList.contains('step3');
  // @see Browser detection: https://stackoverflow.com/a/9851769/7325594
  // Safari 3.0+ "[object HTMLElementConstructor]"
  var isSafari = /constructor/i.test(window.HTMLElement) || function (p) {
    return p.toString() === '[object SafariRemoteNotification]';
  }(!window['safari'] || typeof safari !== 'undefined' && safari.pushNotification);
  // @see https://coderwall.com/p/ktrbhq/detect-mobile-safari
  // iOS Safari "[iPad iPhone iPod]"
  var isIosSafari = /iP(ad|hone|od).+Version\/[\d.]+.*Safari/i.test(navigator.userAgent);
  if (event.persisted && isStep3 && (isSafari || isIosSafari)) {
    // Close the modal, so that the user does not think that the modal has not been closed by mistake
    if (typeof closeLightbox === 'function') {
      closeLightbox();
    }
    window.location.reload();
  }
};

// Used for updating delivery costs in the restaurant information popup
// eslint-disable-next-line no-unused-vars
function UpdateDeliveryCostInfo() {
  try {
    var deliveryCostElements = Array.from(document.querySelectorAll('.js-delivery-cost'));
    var minimumCostsElements = Array.from(document.querySelectorAll('.js-minimum-costs'));
    if (deliveryCostElements.length > 0) {
      var polygonIndex = isDeliveryPossible()['polygonIndex'];
      var data = typeof polygonIndex !== 'undefined' && currentRestaurant.Polygons[polygonIndex].costs ? calculatePolygonsDeliveryCosts(polygonIndex) : calculatePostalDeliveryCosts();
      minimumCostsElements.forEach(function (element) {
        element.innerHTML = data['minimumAmount'];
      });
      deliveryCostElements.forEach(function (element) {
        element.innerHTML = data['deliveryCostValue'];
      });
    }
  } catch (exception) {
    throw new Error('Error UpdateDeliveryCostInfo: "' + exception.message + '"');
  }
}

var calculatePolygonsDeliveryCosts = function calculatePolygonsDeliveryCosts(polygonIndex) {
  var deliveryCostValue = format_price(currentRestaurant.Polygons[polygonIndex].costs[0].costs, currentRestaurant.Currency);
  var minimumAmount = format_price(currentRestaurant.Polygons[polygonIndex].minimumcosts, currentRestaurant.Currency);
  return { 'minimumAmount': minimumAmount, 'deliveryCostValue': deliveryCostValue };
};

var calculatePostalDeliveryCosts = function calculatePostalDeliveryCosts() {
  var deliveryAreaId = getUsersDeliveryAreaId();
  var deliveryLocation = hasRestaurantDeliveryAreaForPostcodeSearch(deliveryAreaId) ? currentRestaurant.Locations.find(function (deliveryLocation) {
    return deliveryLocation.deliveryareaid.toString() === deliveryAreaId;
  }) : currentRestaurant.Locations[0];

  var minimumAmount = format_price(deliveryLocation.minimumcosts, currentRestaurant.Currency);
  var element = document.getElementById('textpaidorfreedelivery');
  var textValue = element ? JSON.parse(element.value || '{}') : { free: format_price(0, currentRestaurant.Currency) };
  var deliveryCostValue = textValue.free;
  if (deliveryLocation.costs && deliveryLocation.costs[0] && deliveryLocation.costs[0].costs !== '0') {
    deliveryCostValue = format_price(parseFloat(deliveryLocation.costs[0].costs || '0'), currentRestaurant.Currency);
  }

  return { 'minimumAmount': minimumAmount, 'deliveryCostValue': deliveryCostValue };
};
/* global $, Fuse, app, keyCode, initLazyLoad */
$(document).ready(function () {
  if (!$('body').hasClass('step3')) {
    return;
  }

  var delayTimer = void 0;
  var fuseBuffer = void 0;
  var $meals = [];
  var $container = $('.menu-category-search');
  var $mealSearchInput = $('.menu-meal-search-input');
  var $noProductFound = $('.no_products_found');
  var $productSearch = $('.js-product-search');
  var $clearSearchButton = $('.js-menu-meal-clear-search');
  var CONSTS = {
    EXPANDED_CLASS: 'expanded',
    TAB_KEY: 9,
    DELAY_TIME: 100
  };

  $productSearch.bind('keyup', function (event) {
    event.preventDefault();
    $container.addClass(CONSTS.EXPANDED_CLASS);
    filterMeals();
    focusOnInput();
  });

  $clearSearchButton.bind('focusout', function (event) {
    event.preventDefault();
    $container.removeClass(CONSTS.EXPANDED_CLASS);
  });

  var clearSearchEvent = function clearSearchEvent(event) {
    event.preventDefault();
    var $value = $mealSearchInput.val();
    if ($value === '' || !isMobile()) {
      toggleInputVisibility();
    }
    clearInput();
  };

  $clearSearchButton.bind('click', clearSearchEvent);

  $('.js-menu-meal-search-expand').on('click', function () {
    if (!$container.is('.' + CONSTS.EXPANDED_CLASS)) {
      console.log('expanding search');
      toggleInputVisibility();
    }
    focusOnInput();
  });

  $noProductFound.find('.js-reset-product-filter').on('click', function () {
    $mealSearchInput.val('');
    filterMeals();
  });

  function clearInput() {
    $mealSearchInput.val('');
    filterMeals();
  }

  function toggleInputVisibility() {
    $container.toggleClass(CONSTS.EXPANDED_CLASS);
    if ($container.is('.' + CONSTS.EXPANDED_CLASS)) {
      focusOnInput();
    }
  }

  function focusOnInput() {
    $mealSearchInput.focus();
  }

  function isMobile() {
    return window.app.services.mediaQueryService.respondTo('>=tablet-landscape') === false;
  }

  function filterMeals() {
    var searchVal = $mealSearchInput.val();
    if (delayTimer !== null) {
      window.clearTimeout(delayTimer);
    }
    var delay = 0;
    if (searchVal.length > 0) {
      delay = CONSTS.DELAY_TIME;
    }
    window.setTimeout(searchItems.bind(null, searchVal), delay);
  }

  function getMeals() {
    if ($meals.length === 0) {
      $meals = $('#imenucard .menucard__meals-group[id!="0"] .js-meal-container');
    }
    return $meals;
  }

  function getFuse() {
    if (!fuseBuffer) {
      var options = {
        shouldSort: false,
        threshold: 0.38,
        location: 0,
        distance: 350,
        maxPatternLength: 32,
        sortFn: function sortFn(a, b) {
          // This won't be called, but it will sort the result descending.
          return parseFloat(b.score) - parseFloat(a.score);
        },
        keys: [{
          name: 'name',
          weight: 0.9
        }, {
          name: 'description',
          weight: 0.1
        }]
      };

      var _$meals = getMeals();
      var itemsIndexed = [];

      _$meals.each(function (index, element) {
        var $this = $(this);
        itemsIndexed.push({
          className: '.js-meal-search-' + element.id,
          name: $this.find('.meal-name').text().trim(),
          description: $this.find('.meal__description-additional-info').text().trim()
        });
      });

      fuseBuffer = new Fuse(itemsIndexed, options);
    }

    return fuseBuffer;
  }

  function searchItems(searchVal) {
    window.clearTimeout(delayTimer);

    var fuse = getFuse();
    var $meals = getMeals();
    var $groupCategories = $('.menucard__meals-group');
    $noProductFound.hide();

    if (searchVal.length === 0) {
      // No search value, show everything
      $meals.show();
      $groupCategories.show();
      return false;
    }

    // Hide all items
    $meals.hide();
    $groupCategories.hide();

    var result = fuse.search(searchVal);

    for (var j in result) {
      var $item = $(result[j].className);
      var _$container = $item.closest('.menucard__meals-group');
      // show the meal
      $item.show();
      _$container.show();
    }

    if (result.length === 0) {
      $noProductFound.show();
    }
    initLazyLoad();

    return false;
  }
});
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* global google, infoBox */

function initMap() {
  console.log('initMap');

  var noPoi = [{
    featureType: 'poi',
    stylers: [{ visibility: 'off' }]
  }];
  var lat = parseFloat(document.getElementById('lat').value);
  var long = parseFloat(document.getElementById('long').value);

  console.log(lat, long);

  var loc = { lat: lat, lng: long };
  var infoMapOptions = {
    zoom: 16,
    center: loc,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    mapTypeControl: false,
    streetViewControl: false,
    styles: noPoi
  };

  var infoMap = new google.maps.Map(document.getElementById('infoMap'), infoMapOptions);
  var marker = new google.maps.Marker(_defineProperty({
    position: loc,
    map: infoMap,
    icon: {
      url: 'http://static.takeaway.com/images/googleMarker/marker2x.png',
      // 42px wide by 54 heigh
      scaledSize: new google.maps.Size(42, 54)
    },
    title: 'testing',
    disableDefaultUI: true,
    scrollwheel: false,
    navigationControl: false,
    gestureHandling: 'none',
    zoomControl: false,
    panControl: false,
    draggable: false
  }, 'scrollwheel', false));

  infoBox.open(infoMap, marker);
}
/* global $, site */
// product id of the current opened remark
var currentProduct = null;
// restaurant id
var restaurantId = null;
$(document).ready(function () {
  /**
   * Click outside the remark and close it. Very ugly check with jQuery.
   */
  $(document.body).click(function (e) {
    if (e.target.classList.contains('productremark') || e.target.classList.contains('div.cart-meal-edit-comment')) {
      return;
    }
    if (restaurantId !== null && currentProduct !== null) {
      closeProductComment(e, true, restaurantId, currentProduct, null, '');
    }
  });

  if (!$(document.body).hasClass('step3') && !$(document.body).hasClass('step4')) {
    return;
  }

  /**
   * Click outside the remark and close it. Very ugly check with jQuery.
   */
  $(document.body).click(function (e) {
    if (typeof window.basket !== 'undefined' && e.target.classList.contains('cart-meal-textarea') === false && e.target.classList.contains('cart-meal-edit-comment') === false) {
      window.basket.closeProductComment(e, window.basket.selectedProductCommentId, true);
    }
  });
});

/**
 * Save product comment via AJAX.
 * @param {event} the event triggering this
 * @param {boolean} save whether to save the comment or not.
 * @param {string} restaurantId the restaurant id.
 * @param {string} productId The current product
 * @param {fn} callback will be called when ajax is fininshed. Optional
 * @param {string} productId2 is needed for the callback. Required when callback is set.
 */
function closeProductComment(event, save, restaurantId, productId, callback, productId2) {
  event.stopPropagation();
  if (save) {
    saveProductComment(restaurantId, productId, callback, productId2);
  }

  $('#productremark-' + productId).hide();
  currentProduct = null;
  restaurantId = null;
}

/**
 * Save product comment via AJAX.
 * @param {string} restaurantId
 * @param {string} productId The current product
 * @param {function} callback will be called when ajax is fininshed. Optional
 * @param {string} productId2 is needed for the callback. Required when callback is set.
 */
function saveProductComment(restaurantId, productId, callback, productId2) {
  var comment = $('#textarea-' + productId).val().replace(/<(?:.|\n)*?>/gm, '');

  $.ajax({
    type: 'POST',
    url: site.local + 'xHttp/Basket.php',
    data: {
      rest: restaurantId,
      action: 'remark',
      productId: productId,
      content: comment
    }
  }).done(function (msg) {
    $('#ibasket').html(msg);
    if (typeof callback === 'function') {
      callback(productId2);
    }
  });
}
function paymentDone(methodStatus, methodText) {
  var responseElement = document.getElementById('iresponsediv');

  if (responseElement) {
    switch (methodStatus) {
      case 'success':
        window.location = methodText;
        break;
      case 'unknownstatus':
        responseElement.innerHTML = '<strong>Unknown status</strong><br />' + methodText;
        break;
      case 'generalerror':
        responseElement.innerHTML = '<strong>General error</strong><br />' + methodText;
        break;
      default:
        responseElement.innerHTML = methodText;
    }
  }
}
/* global ActiveXObject, site, paymentDone */
var paymentIntervalTime = 10000;
var paymentMaxAttempts = 10 * 6;

var paymentCurrentAttempts = 0;

function doPaymentRequest(url, vars) {
  paymentCurrentAttempts = paymentCurrentAttempts + 1;
  var paymentConnection = false;

  if (window.XMLHttpRequest) {
    paymentConnection = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      paymentConnection = new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {
      paymentConnection = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  if (!paymentConnection) {
    return false;
  }

  paymentConnection.open('POST', url, true);
  paymentConnection.setRequestHeader('Takeaway-Accept-Language', site.language);

  paymentConnection.onreadystatechange = function () {
    if (paymentConnection.readyState == 4) {
      var response = eval('(' + paymentConnection.responseText + ')');

      if (response['status']) {
        switch (response['status']) {
          case 'failure':
          case 'expired':
          case 'cancelled':
          case 'unknown':
            document.querySelector('.button-retry').classList.add('is-failure');
            paymentDone(response['status'], response['text']);
            break;
          case 'success':
            paymentDone(response['status'], response['text']);
            break;
          case 'open':
          case 'pending':
          case 'new':
            if (paymentCurrentAttempts > paymentMaxAttempts) {
              paymentDone(response['status'], response['text']);
            } else {
              window.setTimeout("doPaymentRequest('" + url + "', '" + vars + "')", paymentIntervalTime);
            }
            break;
          default:
            paymentDone('unknownstatus', response['text']);
        }
      } else {
        paymentDone('generalerror', paymentConnection.responseText);
      }
    }
  };

  paymentConnection.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  paymentConnection.send(vars);
}
/* global $, site, basket, Takeaway, vouchercode */
// Callback function to keep ideal payment user selection after XHR requests
// we set this in Checkout.js
function lastSelectedBank() {
  if (window.sessionStorage) {
    if (sessionStorage.selectBankVal) {
      var val = sessionStorage.getItem('selectBankVal');
      $('#iidealbank option[value=' + val + ']').attr('selected', true);
    }
  }
}

function doVoucherRequest(voucherCode) {
  var email = $(document).find("input[name='email']");
  var lastName = $(document).find("input[name='surname']");
  var phoneNumber = $(document).find("input[name='phonenumber']");
  var address = $(document).find("input[name='address']");
  var classtoRemove = 'marked';

  email.removeClass(classtoRemove);
  lastName.removeClass(classtoRemove);
  phoneNumber.removeClass(classtoRemove);
  address.removeClass(classtoRemove);

  $.ajax({
    type: 'POST',
    url: site.local + 'checkVoucher.php',
    data: JSON.stringify({
      vouchercode: voucherCode,
      basket: JSON.parse(basket.getBasketJson()),
      email: email.val(),
      lastName: lastName.val(),
      phoneNumber: phoneNumber.val(),
      address: address.val()
    })
  }).done(function (response) {
    response = JSON.parse(response);
    if (response.hasOwnProperty('status')) {
      if (response.status === 'success') {
        var voucher = new Takeaway.Voucher();
        voucher.voucherName = response.voucherobj.vouchername;
        voucher.description = response.voucherobj.voucherdescription;
        voucher.code = response.voucherobj.vouchercode;
        voucher.type = parseInt(response.voucherobj.vouchertype);
        voucher.initialCredit = parseFloat(response.voucherobj.voucheramount);
        voucher.currentCredit = parseFloat(response.voucherobj.vouchercredit);
        voucher.amount = parseFloat(response.voucherobj.voucherdiscountamount);
        voucher.percentage = parseFloat(response.voucherobj.voucherdiscountpercentage);
        voucher.minimumOrderAmount = parseFloat(response.voucherobj.voucherdiscountfrom);
        voucher.productId = response.voucherobj.productid;
        voucher.productName = response.voucherobj.productname;
        basket.addVoucher(voucher);

        var paymentMethod = basket.getPaymentMethod();
        var selectPaymentMethod = false;

        if (typeof paymentMethod.id !== 'undefined') {
          var $paymentMethodElement = $('.paymentmethod' + paymentMethod.id);

          if ($paymentMethodElement.hasClass('payment-method-type-online')) {
            selectPaymentMethod = paymentMethod.id;
          }
        }

        if (selectPaymentMethod !== false) {
          $('.paymentmethod' + selectPaymentMethod)[0].click();
          $('.paymentmethod' + selectPaymentMethod + ' input')[0].click();
        } else {
          $('.paymentbuttonwrapper.payment-method-type-online')[0].click();
          $('.paymentbuttonwrapper.payment-method-type-online input')[0].click();
        }
      } else if (response.status === 'error') {
        for (var i = 0; i < response.markfields.length; i++) {
          var mfield = document.getElementById(response.markfields[i]);
          if (mfield) {
            var teststr = mfield.className;
            if (teststr.substr(teststr.length - 7) !== ' marked') {
              mfield.className = mfield.className + ' marked';
            }
          }
        }
        $('#ivouchermessage')[0].innerHTML = response.value;
      }
      basket.updateBasketAfterValidation(response.basketResponse);
    }
  });
}

function removeVoucher() {
  $.ajax({
    type: 'POST',
    url: site.local + 'xHttp/OrderDetails/removeVoucher.php',
    data: { unsetvoucher: true },
    statusCode: {
      200: function _() {
        var elt = document.getElementById('ivoucherpopuplink');
        if (elt) {
          elt.className = 'smalltextright';
        }

        elt = document.getElementById('ivouchercontainer');
        if (elt) {
          elt.innerHTML = '';
        }

        basket.removeVoucher();
        $('#ivouchercontainerr').show();
        $('.paymentnormal').show();

        if ($('body').hasClass('step4')) {
          var paymentMethod = basket.getPaymentMethod();
          var selectPaymentMethod = false;

          if (typeof paymentMethod.id !== 'undefined') {
            var $paymentMethodElement = $('.paymentmethod' + paymentMethod.id);

            if ($paymentMethodElement.hasClass('payment-method-type-online')) {
              selectPaymentMethod = paymentMethod.id;
            }
          }

          if (selectPaymentMethod !== false) {
            $('.paymentmethod' + selectPaymentMethod)[0].click();
            $('.paymentmethod' + selectPaymentMethod + ' input')[0].click();
          } else {
            $('.paymentbuttonwrapper.payment-method-type-online')[0].click();
            $('.paymentbuttonwrapper.payment-method-type-online input')[0].click();
          }
        }
      }
    }
  });
}

$(document).ready(function () {
  $(document).on('click', '.checkout-voucher .voucher-add-check', function (e) {
    e.preventDefault();
    vouchercode = $(this).prev().val();

    $('#ivouchermessage').html('');
    doVoucherRequest(vouchercode);
    return false;
  });

  $(document).on('click', '.js-voucher-add', function (e) {
    e.preventDefault();
    $(this).toggleClass('open');
    $('.checkout-voucher-container').toggleClass('open');
    return false;
  });
});
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* global Pickup, $, Cookies, site, currentRestaurant */

var Step4 = function () {
  var nawElementProperty = 'data-checkout-naw';

  function getTownElem() {
    return document.getElementById('itown');
  }

  function getPostcodeElem() {
    return document.getElementById('ipostcode');
  }

  function getCityElem() {
    return document.getElementById('itown');
  }

  function getAddressElem() {
    return document.getElementById('iaddress');
  }

  function getAddressDropdownElem() {
    return document.getElementById('icustomeraddress');
  }

  function updateAddressDropdownElem(value) {
    var address = getAddressDropdownElem();
    if (address) {
      address.value = value;
    }
  }

  function getAddressValuesElem() {
    return document.getElementById('addressValues');
  }

  /**
   * @param {HTMLElement} checkoutForm
   *
   * @returns {boolean}
   */
  function isFormPosted(checkoutForm) {
    return checkoutForm.querySelector('.js-checkout-naw[' + nawElementProperty + ']') instanceof HTMLElement;
  }

  function fillFormWithPostedNawData(checkoutForm) {
    var checkoutNawDataElement = checkoutForm.querySelector('.js-checkout-naw[' + nawElementProperty + ']');

    if (checkoutNawDataElement) {
      var nawData = checkoutNawDataElement.getAttribute(nawElementProperty);
      var parsedNawData = JSON.parse(nawData || '{}');
      fillFormWith(checkoutForm, parsedNawData);
    }
  }

  /**
   * Takes an key/vale object where the key is te name of an input and the value
   * is the value the input should be set to.
   *
   * @param {HTMLFormElement} form
   * @param {object} data
   */
  function fillFormWith(form, data) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.entries(data)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ref = _step.value;

        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var value = _ref2[1];

        var element = form.querySelector('[name="' + key + '"]');

        if (element) {
          // Because the code which is coming in is like &amp; etc, we need to convert it to viewable html.
          // snippet below does that work.
          var newDiv = document.createElement('div');
          newDiv.innerHTML = value;
          element.value = newDiv.innerText;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return {
    fillFormWithPostedNawData: fillFormWithPostedNawData,
    getAddressDropdownElem: getAddressDropdownElem,
    getAddressElem: getAddressElem,
    getAddressValuesElem: getAddressValuesElem,
    getCityElem: getCityElem,
    getPostcodeElem: getPostcodeElem,
    getTownElem: getTownElem,
    isFormPosted: isFormPosted,
    updateAddressDropdownElem: updateAddressDropdownElem
  };
}();

$(document).ready(function () {
  // once user is logged, update the view
  $('body').on('hideEmailDisclamer', function (event, subscriptionStatus) {
    if (subscriptionStatus.subscribed) {
      $('.newslettersignup.checkout-newsletter').addClass('checkout-newsletter-hidden');
    } else {
      $('.newslettersignup.checkout-newsletter').removeClass('checkout-newsletter-hidden');
    }
  });

  if ($('body').hasClass('step4')) {
    var $newsletterWrapper = $('.checkout-newsletter');

    if ($newsletterWrapper.hasClass('checkout-newsletter-hidden')) {
      $('#iemail').keyup(function () {
        $newsletterWrapper.show();
      });
    }
  }

  // Only execute this code if checkoutform exists
  var checkoutForm = document.querySelector('#checkoutform');
  if (checkoutForm) {
    if (Step4.isFormPosted(checkoutForm)) {
      console.log('[Step4] [Form POST] skipping pre-fill address, using POST NAW data instead');
      Step4.fillFormWithPostedNawData(checkoutForm);
    } else {
      // First time, pre-fill the Address
      PrefillAddress();
    }
  }
});

// Set savedAddressId to cookies for checking it on CS side. For more details please check - FED-12312.
function setSavedAddressIdToCookie() {
  console.log('Set saved address id to cookie - step4');
  var addressValues = document.getElementById('addressValues').value && JSON.parse(document.getElementById('addressValues').value);
  var selectValue = document.getElementById('icustomeraddress').value;
  var savedAddress = addressValues.find(function (_ref3) {
    var value = _ref3.value;
    return value === selectValue;
  });

  var savedAddressId = savedAddress && savedAddress.value;
  if (savedAddressId) {
    Cookies.set('savedAddressId', encodeURIComponent(savedAddressId), { secure: true });
  }
}

function onChangeSavedAddressSelect() {
  FillSelectedAddress();
  setSavedAddressIdToCookie();
}

// This function saves the value from the dropdown.
function SaveAddressSelection() {
  var addressDropdownElem = Step4.getAddressDropdownElem();
  var addressElem = Step4.getAddressElem();
  var postcodeElem = Step4.getPostcodeElem();
  var cityElem = Step4.getCityElem();
  var address = {};

  FillSelectedAddress();
  function getAddressFields() {
    if (addressElem) {
      address.route = addressElem.value || '';
    }
    if (postcodeElem) {
      address.postal_code = postcodeElem.value || '';
    }
    if (cityElem) {
      address.locality = cityElem.value || '';
    }

    return {
      address: {
        postal_code: address.postal_code,
        route: address.route,
        locality: address.locality
      }
    };
  }
  if (addressDropdownElem && addressDropdownElem.value) {
    var savedAddress = getAddressFields();
    window.localStorage.setItem('lastSelectedAddress', JSON.stringify(savedAddress));
  } else {
    window.localStorage.removeItem('lastSelectedAddress');
  }
}

var RenderTakeawayPay = function RenderTakeawayPay() {
  if (document.body.classList.contains('step4')) {
    // currentRestaurant.Id needs to be passed through here to be available in TakeawayPay.phtml, used for checkbox disable
    window.fetch(site.aPath + 'xHttp/' + site.language + '/takeaway-pay?restid=' + (currentRestaurant.Id || ''), {
      headers: {
        'Takeaway-Accept-Language': site.language
      },
      credentials: 'same-origin'
    }).then(function (response) {
      return response.text();
    }).then(function (htmlContent) {
      var $paymentContainer = document.querySelector('.js-payment');
      if ($paymentContainer) {
        $paymentContainer.insertAdjacentHTML('afterbegin', htmlContent);
      }

      window.basket.initTakeawayPay();
    });
  }
};
// Is used in the Userpanel
window.RenderTakeawayPay = RenderTakeawayPay;
// This is used for when user is logged out and the address of the combobox is not there
function PrefillLatestSelection() {
  // return when in pickup mode (prefill not needed)
  if (typeof Pickup !== 'undefined' && Pickup.isPickupStatus()) {
    // 'Pickup mode - skipping prefill address'
    return;
  }
  var addressElem = Step4.getAddressElem();
  var postcodeElem = Step4.getPostcodeElem();
  var cityElem = Step4.getCityElem();
  var emptyObjStr = '{}';

  var lastAddress = JSON.parse(window.localStorage.getItem('lastSelectedAddress') || emptyObjStr);
  if (lastAddress.address) {
    if (postcodeElem) {
      postcodeElem.value = lastAddress.address.postal_code || postcodeElem.value;
    }
    addressElem.value = lastAddress.address.route || addressElem.value;
    cityElem.value = lastAddress.address.locality || cityElem.value;
  }
  window.localStorage.removeItem('lastSelectedAddress');
}

function FillSelectedAddress() {
  var addressValuesElem = Step4.getAddressValuesElem();
  var addressDropdownElem = Step4.getAddressDropdownElem();
  var addressElem = Step4.getAddressElem();
  var postcodeElem = Step4.getPostcodeElem();
  var cityElem = Step4.getCityElem();
  var emptyObjStr = '{}';
  var fillAddress = {
    postalCode: '',
    streetAddress: '',
    town: ''
  };
  function GetAddressForEmptyValue(address) {
    var addressValue = window.localStorage.getItem('emptyValue') || JSON.stringify(address);
    return JSON.parse(addressValue);
  }

  function FillInAddress(address) {
    if (address) {
      var isThuisbezorgdNl = window.site.cc === '1';
      if (isThuisbezorgdNl) {
        if (postcodeElem) {
          var oldValue = postcodeElem.getAttribute('old-value');
          postcodeElem.value = oldValue || address.postalCode;
        }
      } else {
        // Postal Code input box is not always there so check if the field exists
        if (postcodeElem && postcodeElem.value.trim() === '') {
          postcodeElem.value = address.postalCode;
        }
      }
      if (addressElem && addressElem.value.trim() === '') {
        addressElem.value = address.streetAddress;
      }
      if (cityElem && cityElem.value.trim() === '') {
        cityElem.value = address.town;
      }
    }
  }

  // return when in pickup mode (prefill not needed)
  if (typeof Pickup !== 'undefined' && Pickup.isPickupStatus()) {
    // 'Pickup mode - skipping prefill address'
    return;
  }

  var addressValues = JSON.parse(addressValuesElem ? addressValuesElem.value : emptyObjStr || emptyObjStr); // needs attention
  var currentStreetAddressKey = addressDropdownElem ? addressDropdownElem.value : '' || ''; // needs attention
  if (addressValues.length > 0) {
    var addressValue = addressValues.find(function (item) {
      return item.value === currentStreetAddressKey;
    });
    if (addressValue && addressValue.data) {
      fillAddress.postalCode = (postcodeElem ? postcodeElem.value : '') || addressValue.data.postcode;
      fillAddress.streetAddress = addressElem.value || [addressValue.data.address, addressValue.data.housenumber || ''].join(' ').trim();
      fillAddress.town = cityElem.value || addressValue.data.town;
    } else {
      fillAddress = GetAddressForEmptyValue(fillAddress);
    }

    FillInAddress(fillAddress);
  }
}

// This function is called as callback function when html\xHttp\OrderDetails\showPaymentDetails.php is fired
function PrefillAddress() {
  // return when in pickup mode (prefill not needed)
  if (typeof Pickup !== 'undefined' && Pickup.isPickupStatus()) {
    console.log('[Step4] Pickup mode - skipping prefill address');
    return;
  }

  var addressValuesElem = Step4.getAddressValuesElem();
  var addressDropdownElem = Step4.getAddressDropdownElem();
  var addressElem = Step4.getAddressElem();
  var postcodeElem = Step4.getPostcodeElem();
  var cityElem = Step4.getCityElem();
  var emptyObjStr = '{}';

  function SaveEmptyAddress(address) {
    window.localStorage.setItem('emptyValue', JSON.stringify(address));
  }

  function GetKeyFromDropdown(address) {
    var addressValues = JSON.parse(addressValuesElem ? addressValuesElem.value : emptyObjStr || emptyObjStr); // needs attention
    // Find the address in the list of customer addresses
    if (Array.isArray(addressValues)) {
      var _addressValues$filter = addressValues.filter(function (_ref4) {
        var data = _ref4.data;

        if (data && data.address && data.town) {
          // Check street and town
          // Street in the saved address can contain housenumber
          // Town should be equal
          var sameStreet = data.address.toLowerCase().indexOf(address.streetAddress.toLowerCase()) === 0;
          var sameTown = data.town.toLowerCase() === address.town.toLowerCase();
          return sameStreet && sameTown;
        }
      }).map(function (_ref5) {
        var data = _ref5.data,
            value = _ref5.value;

        if (data && data.address) {
          var isStrict = data.address.toLowerCase() === address.streetAddress.toLowerCase();
          return { value: value, isStrict: isStrict };
        }
      })
      // Because the isStrict property can be undefined we need
      // to convert it to a boolean using !!
      // sorting is done to show the true values first
      .sort(function (_ref6, _ref7) {
        var isStrictA = _ref6.isStrict;
        var isStrictB = _ref7.istStrict;
        return !!isStrictB - !!isStrictA;
      }).map(function (_ref8) {
        var value = _ref8.value;
        return value;
      }),
          _addressValues$filter2 = _slicedToArray(_addressValues$filter, 1),
          addressValue = _addressValues$filter2[0];

      // If more addresses are found only return key of the first item found


      return addressValue;
    }
  }

  var addressSelectionValue = addressDropdownElem ? addressDropdownElem.value : undefined;
  var selectedAddress = JSON.parse(window.localStorage.getItem('SelectedAddress') || Cookies.get('selectedAddress') || emptyObjStr);
  console.log('[Step4] selectedAddress', selectedAddress);
  var selectedCity = JSON.parse(window.localStorage.getItem('SelectedCity') || emptyObjStr);
  console.log('[Step4] selectedCity', selectedCity);

  var town = window.AreaCity || '';
  var postalCode = Cookies.get('postcode') || '';

  if (typeof selectedAddress.street_number !== 'undefined' && typeof selectedAddress.affix !== 'undefined') {
    selectedAddress.street_number_full = selectedAddress.street_number + selectedAddress.affix;
  } else if (typeof selectedAddress.street_number !== 'undefined') {
    selectedAddress.street_number_full = selectedAddress.street_number;
  }

  // postalCode is taken from the selectedCity, as this is a value from our system, and not from the google api.

  var foundAddressPostalCode = (postcodeElem ? postcodeElem.value : '') || selectedAddress.postal_code || selectedCity.postal_code || postalCode;
  if (parseInt(site.cc, 10) === 180) {
    // Only change this for Poland, ugly fix
    foundAddressPostalCode = (postcodeElem ? postcodeElem.value : '') || selectedCity.postal_code || selectedAddress.postal_code || postalCode;
  }
  var foundAddress = {
    streetAddress: addressElem.value || [selectedAddress.route, selectedAddress.street_number_full].join(' ').trim(),
    postalCode: foundAddressPostalCode,
    town: cityElem.value || selectedAddress.locality || selectedCity.locality || town
  };
  var frenchCountryCode = '8';
  if (site.cc === frenchCountryCode) {
    foundAddress.streetAddress = [selectedAddress.street_number_full, selectedAddress.route].join(' ').trim() || addressElem.value;
    console.log('[Step4] Prefill Addres value france ', foundAddress);
  }
  console.log('[Step4] Prefill Addres value ', foundAddress);
  SaveEmptyAddress(foundAddress);
  if (addressSelectionValue) {
    console.log('[Step4] Fill selected address');
    FillSelectedAddress();
  } else {
    console.log('[Step4] Fill from local storage ');

    // if there is an address found by google use that first
    // if there is a city found by postal_code use that next
    // if there is nothing found leave it at the value it already has, it might be filled in from the server

    // There are countries without using postal code, so only fill it if it exists
    var addressKey = GetKeyFromDropdown(foundAddress);
    if (addressKey) {
      // Set the combobox to the address value of the customer which is found
      addressDropdownElem.value = addressKey;
    } else {
      // Fill in the textboxes
      if (postcodeElem && postcodeElem.value.trim() === '') {
        postcodeElem.value = foundAddress.postalCode;
      }
      if (addressElem && addressElem.value.trim() === '') {
        addressElem.value = foundAddress.streetAddress;
      }
      if (cityElem && cityElem.value.trim() === '') {
        cityElem.value = foundAddress.town;
      }
    }
  }
  SaveAddressSelection();
}

var updateAddressIfExists = function updateAddressIfExists() {
  /**
   * Compare 2 values and checks if they are same
   * @param {string} value1
   * @param {string} value2
   * @returns {boolean}
   */
  var valueIsSameIgnoringWhitespaceAndCase = function valueIsSameIgnoringWhitespaceAndCase() {
    var value1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    // If both values are empty they are still the same
    if (!value1 && !value2) {
      return true;
    }

    // Compare items ignoring case and white spaces
    return value1.replace(/\s/g, '').toLowerCase() === value2.replace(/\s/g, '').toLowerCase();
  };

  var _ref9 = Step4.getAddressValuesElem() || { value: '[]' },
      addressValues = _ref9.value;

  var _ref10 = Step4.getAddressElem() || { value: '' },
      currentAddress = _ref10.value;

  var _ref11 = Step4.getPostcodeElem() || { value: '' },
      currentPostcode = _ref11.value;

  var _ref12 = Step4.getCityElem() || { value: '' },
      currentTown = _ref12.value;

  var addresses = JSON.parse(addressValues);
  var foundAddress = addresses.find(function (addressData) {
    var _addressData$data = addressData.data,
        _addressData$data$add = _addressData$data.address,
        address = _addressData$data$add === undefined ? '' : _addressData$data$add,
        _addressData$data$pos = _addressData$data.postcode,
        postcode = _addressData$data$pos === undefined ? '' : _addressData$data$pos,
        _addressData$data$tow = _addressData$data.town,
        town = _addressData$data$tow === undefined ? '' : _addressData$data$tow;

    return valueIsSameIgnoringWhitespaceAndCase(currentAddress, address) && valueIsSameIgnoringWhitespaceAndCase(currentPostcode, postcode) && valueIsSameIgnoringWhitespaceAndCase(currentTown, town);
  });
  if (foundAddress) {
    Step4.updateAddressDropdownElem(foundAddress.value);
  }
};
/* global $, Helper, site */
Helper.ready(function () {
  addNeedHelpExpandOnClickEvent();
  addTrackingToLoyaltyShopBanner();
  addFoodtrackerCopiedSuccessNotification();
  storeCookieConsentElement();
  var tipping = new window.app.components.Tipping({
    containerSelector: '.js-tipping-step5',
    source: 'order-confirmation' // Overwritten by the container, because of the foodtracker
  });
  tipping.init();
  if (document.body.classList.contains('step5')) {
    window.app.services.addChatButtonClickEvent();
    window.app.services.addChatFaqButtonClickEvent();
    window.app.services.optInService.setOptInValueFromOrderConfirmationPage();

    var $addressElement = document.querySelector(window.app.enums.SELECTOR_CLASS_NAMES.ORDER_CONFIRMATION.CUSTOMER_ADDRESS);
    var $confirmationPage = document.querySelector(window.app.enums.SELECTOR_CLASS_NAMES.ORDER_CONFIRMATION.IS_ORDER_CONFIRMATION_PAGE);
    // Exclude the foodtracker page only run this on order confirmation page
    if ($confirmationPage && $addressElement && $addressElement.dataset.customerAddress) {
      try {
        var addressParsed = JSON.parse($addressElement.dataset.customerAddress);
        window.app.services.addressStorage.addSavedAddress(addressParsed);
      } catch (error) {
        console.log('Error', error);
      }
    }
  }
});

// FUNCTIONS

var addTrackingToLoyaltyShopBanner = function addTrackingToLoyaltyShopBanner() {
  var loyaltyShopBannerLink = document.querySelector(window.app.enums.SELECTOR_CLASS_NAMES.ORDER_CONFIRMATION.LOYALTY_SHOP_BANNER_LINK);
  if (loyaltyShopBannerLink) {
    loyaltyShopBannerLink.addEventListener('click', function () {
      return window.app.services.tracking.send({
        eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_LOYALTY_BANNER
      });
    });
  }
};

var storeCookieConsentElement = function storeCookieConsentElement() {
  var storeCookieConsentElement = document.querySelector('.js-store-cookie-consent');
  if (storeCookieConsentElement) {
    fetch(site.aPath + 'api/storeCookieConsent').then(function (response) {
      return response.json();
    });
  }
};

var addNeedHelpExpandOnClickEvent = function addNeedHelpExpandOnClickEvent() {
  $('.js-needhelp-expand').on('click', function () {
    $(this).closest('.needhelp').toggleClass('expanded');
  });
};

var addFoodtrackerCopiedSuccessNotification = function addFoodtrackerCopiedSuccessNotification() {
  var icon = document.querySelector('.js-foodtracker-icon');
  if (icon) {
    icon.addEventListener('copied', function (event) {
      var text = null;
      if (event.detail && typeof event.detail.notifyText === 'string') {
        text = event.detail.notifyText;
      }
      if (text) {
        window.app.helpers.notifySuccess(text);
      }
    });
  }
};
/* global $, setModal, site, xmlRequest, reorderTexts, initStrengthBar, toastlast,
ADDRESS, google, AutoComplete, Cookies, Address */
$(document).ready(function () {
  $('button.reorder').click(function () {
    $(this).parents('.orders').children('.moredetails').slideToggle();
  });

  $('button.button-link').click(function () {
    window.location = $(this).attr('data-url');
  });

  $(document).on('click', '.myaccount-favorite-delete', function (e) {
    if (!e) {
      e = window.event;
    }
    e.cancelBubble = true;
    if (e.stopPropagation) e.stopPropagation();

    xmlRequest(site.local + 'setFavorite.php', 'action=removefavorite&bid=' + $(this).data('id'), 'idummy');

    $(this).removeClass('selected');
    $(this).parents('.my-favorite').slideUp('normal', function () {
      $(this).remove();

      if ($('.js-account-favorites > .restaurant').length === 0) {
        $('.js-account-nofavorites').removeClass('hidden');
      }
    });

    return false;
  });

  $('.reorderForm').submit(function (e) {
    if ($(this).attr('action') == '#') {
      e.preventDefault();

      var reorder = $('.reorderBtn');

      $.ajax({
        type: 'POST',
        url: $(this).data('target'),
        data: $(this).serialize(),
        success: function success(serverResponse) {
          if (serverResponse != '') {
            if (serverResponse.type == 'SUCCESS') {
              if (serverResponse.redirect != '') {
                if (serverResponse.errorCode != '') {
                  setReorderMessage(serverResponse.errorCode);
                  reorder.val(reorderTexts[1]);
                  $('.reorderForm').attr('action', serverResponse.redirect);
                } else {
                  window.location.href = serverResponse.redirect;
                }
              }
            } else {
              setReorderMessage(serverResponse.errorCode, serverResponse.restaurant);
              reorder.prop('disabled', true);
            }
          }
        }
      });
    }
  });

  $('.address-reference-link').on('click', function (ev) {
    ev.stopPropagation();
    AutoComplete.clickReference($(this));
  });

  // @TODO
  // why? why? why? this is being executed every single time, for now above prevents it from running it outside the myaccount pages
  if ($('body').hasClass('myaccountpages')) {
    setAddressModalPanel();
    handleCompanynameFormField();
    var $progressBar = $('.progress-bar-parent');
    if ($progressBar.length > 0) {
      initStrengthBar($progressBar);
    }

    $('#password, #passwordrepeat, #currentpassword').keyup(function () {
      if ($(this).hasClass('marked')) {
        $(this).removeClass('marked');
      }
    });
  }
});

function setAddressModalPanel() {
  var $body = $('body');
  $body.append('<div id="modalpanel" class="modalpanel"></div>');
  var modalpanelElement = $('#modalpanel');

  modalpanelElement.click(function (e) {
    if (e.target !== this) {
      return;
    }
    modalpanelElement.empty().hide();
    window.location.reload();
  });

  document.querySelectorAll('.js-single-address').forEach(function (item) {
    item.addEventListener('click', function (event) {
      // Seems not to fire on embedded links
      var link = this;
      var savedAddressId = link.id;

      var _JSON$parse = JSON.parse(link.dataset['address']),
          city = _JSON$parse.city,
          number = _JSON$parse.number,
          postcode = _JSON$parse.postcode,
          street = _JSON$parse.street;

      var savedAddress = {
        city: city,
        number: number,
        postcode: postcode,
        savedAddressId: savedAddressId,
        street: street
      };
      if (savedAddressId) {
        Cookies.set('savedAddressId', encodeURIComponent(savedAddressId), { secure: true });
      } else if (Cookies.get('savedAddressId')) {
        Cookies.remove('savedAddressId');
      }

      var savedAddressString = new Address(savedAddress).toString();
      if (savedAddressString.replace(/\s/g, '') !== '') {
        AutoComplete.geoCodeService(savedAddressString, $(this), true);
      } else {
        throw new Error('Empty saved address found');
      }
    });
  });

  $('.edit-address').click(function (e) {
    e.preventDefault();
    modalpanelElement.show();
    var stopScrollClass = 'stop-scroll';

    $body.addClass(stopScrollClass);
    var $this = $(this);

    $.ajax({
      type: 'POST',
      data: {
        myaddress_panel_mode: $this.data('address-mode'),
        myaccount_address: $this.data('address-id')
      },
      dataType: 'html',
      url: site.local + 'xHttp/MyAccount/AddressPanel.php'
    }).done(function (msg) {
      modalpanelElement.html(msg);
      setModal(modalpanelElement);

      $('.modal-close').click(function () {
        modalpanelElement.empty().hide();
        $body.removeClass(stopScrollClass);
      });
    });
  });
}

function setReorderMessage(errorCode, restaurantName) {
  var html = reorderTexts[errorCode];
  if (errorCode == 4 && restaurantName != false) {
    html = html.replace('[restaurantname]', restaurantName);
  }
  $('.myaccount_reorder_text').html(html);
}

function handleCompanynameFormField() {
  $('#accounttype').on('change', function (ev) {
    ev.stopPropagation();
    ev.preventDefault();
    var $companyNameWrapper = $('.companyname-wrapper');
    var $name = $('#name');
    switch (ev.target.value) {
      case '1':
        $companyNameWrapper.hide();
        $name.addClass('mandatory');
        break;
      case '3':
        $companyNameWrapper.show();
        $name.removeClass('mandatory');
        break;
    }
  });
}

function triggerInitialPreferenceToast(message) {
  var element = "<div class='dpToast init' id='dpToast' style='display:block;'> <span id='dpToastClose' class='dpToastClose toast-close'></span><span class='toastText'>" + message + '</span></div>';
  typeof toastlast !== 'undefined' ? $('#' + toastlast).remove() : toastlast = 'dpToast';
  $(element).fadeIn().appendTo('.dpToastContainer');
};

function triggerPreferencesToggleToast(message) {
  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4500;

  var element = "<div class='dpToast' id='dpToast' style='display:block;'><span class='toastText'>" + message + '</span></div>';

  typeof toastlast !== 'undefined' !== false ? $('#' + toastlast).remove() : toastlast = 'dpToast';

  $(element).fadeIn().appendTo('.dpToastContainer').delay(time).queue(function (n) {
    $(this).fadeOut();
    n();
  });
}

$(function () {
  $(document).on('click', '.navigation-menu', function () {
    $(this).toggleClass('show').next().toggleClass('show');
  });
  $('.navigation li').each(function (index) {
    if ($(this).hasClass('active')) {
      $('.navigation-menu').find('span').html($(this).text());
    }
  });

  $(document).on('click', '#myaccount-logout', function () {
    var item = 'logout';

    $.post(site.local + 'xHttp/CustomerPanel.php', { 'open': item }).done(function (data) {
      if (item === 'logout' && $('body').hasClass('myaccountpages')) {
        window.app.services.optInService.removeOptedInStatus();
        window.location.reload();
        return false;
      }
    });
  });
});

/*
* Add / Edit address form
*/

// View the console to see results.

var AddressesStore = function AddressesStore(el) {
  var form = $('#imyaccount_addeditaddressform');

  if (site.forceGeo) {
    var street = form.find('input[name="myaccount_street"]').val();
    var town = form.find('input[name="myaccount_town"]').val();
    Account.validatePolygonDistrict(street, town);
  } else {
    Account.FormSuccessDirect();
  }
  return false;
};

$(document).on('blur', '#imyaccount_street', function () {
  if ($(this).hasClass('nohousenumber')) return false;

  var val = this.value;
  if (val !== '') {
    if (val.match(/\d+/g) == null) {
      $(this).addClass('marked');
      $('#iaddressnotice').fadeIn();
    } else {
      $('#iaddressnotice').fadeOut();
      $(this).removeClass('marked');
    }
  }
});

/**
 * Account
 */

var Account = {

  /**
   * Error handling
   */
  Error: function Error(el, text) {
    document.getElementById(el).innerHTML = text;
    document.getElementById(el).style.display = 'block';

    var $requiredFields = $('.required');

    if (!$requiredFields.hasClass('marked')) {
      $requiredFields.addClass('marked');
    }
  },
  /**
   * Submit form
   */
  FormSuccess: function FormSuccess(obj) {
    var form = $('#imyaccount_addeditaddressform');
    var postData = Account.objectifyForm(form.serializeArray());

    $.extend(postData, obj);

    $.ajax({
      type: 'POST',
      data: postData,
      dataType: 'html',
      url: site.local + 'xHttp/MyAccount/AddressPanel.php'
    }).done(function (responseData) {
      var data = $.parseJSON(responseData);

      if (data.type === 'success') {
        var notificationElement = $('#inotification');

        notificationElement.html(data.html).show();
        $('#imyaccount_addeditaddressform').remove();

        window.app.services.user.handleSavedAddresses().then(function (response) {
          if (response !== false) {
            window.app.services.user.setAddress(ADDRESS.SAVED, response);
          }
        });

        $('.modal-close').click(function () {
          window.location.reload();
        });
      } else {
        $('#modalpanel').html(responseData);
        Account.Error('inotification', $('#inotification').data('failed'));
      }
    });
  },
  /**
   * Submit form without locationtype
   */
  FormSuccessDirect: function FormSuccessDirect() {
    var form = $('#imyaccount_addeditaddressform');

    $.ajax({
      type: 'POST',
      data: form.serialize(),
      dataType: 'html',
      url: site.local + 'xHttp/MyAccount/AddressPanel.php'
    }).done(function (responseData) {
      var data = $.parseJSON(responseData);
      var notificationElement = $('#inotification');

      if (data.type === 'success') {
        notificationElement.html(data.html).show();
        $('#imyaccount_addeditaddressform').remove();

        window.app.services.user.handleSavedAddresses().then(function (response) {
          if (response !== false) {
            window.app.services.user.setAddress(ADDRESS.SAVED, response);
          }
        });

        $('.modal-close').click(function () {
          window.location.reload();
        });
      } else {
        if (data.errors != undefined) {
          var msg = '';
          $.each(data.errors, function (fieldname, errorTxt) {
            $('#imyaccount_addeditaddressform input[name="' + fieldname + '"]').addClass('marked');
            msg += errorTxt;
          });

          notificationElement.html(msg).show();
        } else {
          $('#modalpanel').html(responseData);
          Account.Error('inotification', $('#inotification').data('failed'));
        }

        if (typeof data.id !== 'undefined' && typeof data.hash !== 'undefined') {
          var tokenField = $('#csrfToken');

          tokenField.attr('name', data.id);
          tokenField.val(data.hash);
        }
      }
    });
  },

  /**
   * Validate locationtype 23
   */
  validatePolygonDistrict: function validatePolygonDistrict(street, town) {
    var notificationElement = $('#inotification');

    // validate fields
    if (typeof street !== 'undefined' && typeof town !== 'undefined' && street !== '' && town !== '') {
      var search = street + ', ' + town + ', ' + site.iso;
      var geocoder = new google.maps.Geocoder();

      geocoder.geocode({ 'address': search, componentRestrictions: { country: site.iso } }, function (places, status) {
        if (status === google.maps.GeocoderStatus.OK && places[0] && places[0].types.indexOf('country') === -1) {
          var placecomponent = {
            placeId: places[0].place_id,
            latitude: places[0].geometry.location.lat(),
            longitude: places[0].geometry.location.lng(),
            search: search
          };
          Account.FormSuccess(placecomponent);
        } else {
          Account.Error('inotification', notificationElement.data('failed'));
        }
      });
    } else {
      Account.Error('inotification', notificationElement.data('fieldserror'));
    }
  },
  /**
   *
   * Convert SerializeArray to readable object
   * @param formArray
   * @return object
   *
   */
  objectifyForm: function objectifyForm(formArray) {
    var returnArray = {};
    for (var i = 0, j = formArray.length; i < j; i++) {
      returnArray[formArray[i]['name']] = formArray[i]['value'];
    }
    return returnArray;
  },
  /**
   * $(document).ready equivalent for the project
   *
   * @param fn
   */
  ready: function ready(fn) {
    if (document.readyState !== 'loading') {
      fn();
    } else {
      document.addEventListener('DOMContentLoaded', fn);
    }
  }
};
/* global $ */
/**
 * Initiates the actions for the strength bar
 * @param element Parent element for the strength bar
 */
function initStrengthBar(element) {
  if (!element.length) return;
  var target = element.data('target');

  adjustBar(element);

  $(document).on('keyup', '#' + target, function () {
    adjustBar(element);
  });
}

/**
 * Adjusts the bar on the page that sets the strength
 */
function adjustBar(element) {
  var target = element.data('target');
  var value = $('#' + target).val();

  if (value !== '') {
    var strength = calculateStrength(value);
    var barClasses = ['strength-level1', 'strength-level2', 'strength-level3', 'strength-level4', 'strength-level5', 'strength-level6'];
    var minStrength = 1;
    var maxStrength = 6;

    strength = strength > maxStrength ? maxStrength : strength;
    strength = strength < minStrength ? minStrength : strength;
    var total = strength === maxStrength ? 100 : 100 / maxStrength * strength;
    // Strength = 1..6, the array is 0..5 so substract 1
    var newStrengthClass = barClasses[strength - 1];
    var removeOldClasses = barClasses.join(' ');
    // first remove previous set strength classes, we remove all 6 classes
    // then add the class with the current strength
    element.children('.progress-bar').stop().animate({
      width: total + '%'
    }, 1500).removeClass(removeOldClasses).addClass(newStrengthClass);
  }
}

/**
 * Please see App/Library/User/Password.php for the server sided equivalent of this function.
 * @param password
 * @returns number Strength in points
 */
function calculateStrength(password) {
  var strength = 0;
  var hasUpperCase = false;
  var hasLowerCase = false;
  var hasNumber = false;
  var hasSpecial = false;

  if (password.length >= 8) {
    strength = strength + 1;

    if (password.length >= 10) {
      strength = strength + 1;
    }
  }

  if (password.match(/[a-z]/) !== null) {
    strength = strength + 1;
    hasLowerCase = true;
  }

  if (password.match(/[A-Z]/) !== null) {
    strength = strength + 1;
    hasUpperCase = true;
  }

  if (password.match(/[0-9]/) !== null) {
    strength = strength + 1;
    hasNumber = true;
  }

  if (password.match(/['^£$%&*()}{@#~?><>,|=.!_+¬-]/) !== null) {
    strength = strength + 1;
    hasSpecial = true;
  }

  if (strength > 3 && (password.length < 8 || hasLowerCase === false || hasUpperCase === false || hasNumber === false && hasSpecial === false)) {
    strength = 3;
  }

  return strength;
}
/* global $, initStrengthBar */
$(document).ready(function () {
  if ($('body').hasClass('passwordreset')) {
    if ($('.progress-bar-parent').length > 0) {
      initStrengthBar($('.progress-bar-parent'));
    }

    $('#passwordrepeat').keyup(function () {
      var passwordRepeat = $(this);
      var password = $('#password');
      var inputError = $('.input-error');

      console.log(1);
      if (passwordRepeat.val() === password.val()) {
        password.removeClass('marked');
      }
    });

    $('#passwordrepeat').blur(function () {
      var passwordRepeat = $(this);
      var password = $('#password');
      var inputError = $('.input-error');

      if (passwordRepeat.val() !== password.val()) {
        if (!password.hasClass('marked')) {
          password.addClass('marked');
        }

        if (!passwordRepeat.hasClass('marked')) {
          passwordRepeat.addClass('marked');
        }

        if (inputError.is(':hidden')) {
          inputError.show();
        }
      } else {
        if (password.hasClass('marked')) {
          password.removeClass('marked');
        }

        if (passwordRepeat.hasClass('marked')) {
          passwordRepeat.removeClass('marked');
        }

        if (inputError.is(':visible')) {
          inputError.hide();
        }
      }
    });
  }
});
/*
  global
  $,
  currentRestaurant,
  basket,
  Cookies,
  updateAddressIfExists,
  Pickup,
  site
*/
function showHideCompany(showcomp) {
  var comp1 = document.getElementById('icompanyname1');
  var comp2 = document.getElementById('icompanyname2');
  if (comp1 && comp2) {
    if (showcomp) {
      comp1.className = 'companyname1';
      comp2.className = 'companyname2';
    } else {
      comp1.className = 'companyname1_nodisplay';
      comp2.className = 'companyname2_nodisplay';
    }
  }
}

function changeResidenceTypes(selectedtype) {
  // first set all to no_display
  var allresdentelts = new Array('apartmentname', 'floor', 'roomnumber', 'buildingname', 'hotelname', 'compoundname', 'addressatcompound');
  var i;
  for (i = 0; i < allresdentelts.length; i++) {
    $('#icheckoutdivr_' + allresdentelts[i]).addClass('checkoutdivr_nodisplay');
    // document.getElementById('icheckoutdivrs_' + allresdentelts[i]).className = "checkoutdivr_nodisplay";
  }
  // now display the correct ones
  switch (selectedtype) {
    case 'apartment':
      $('#icheckoutdivr_apartmentname').addClass('checkoutdivr');
      $('#icheckoutdivr_apartmentname').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivrs_apartmentname').addClass('checkoutdivr');
      $('#icheckoutdivrs_apartmentname').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivr_floor').addClass('off-02 checkoutdivr');
      $('#icheckoutdivr_floor').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivr_roomnumber').addClass('checkoutdivr');
      $('#icheckoutdivr_roomnumber').removeClass('off-02 checkoutdivr_nodisplay');
      break;
    case 'hotel':

      $('#icheckoutdivr_hotelname').addClass('checkoutdivr');
      $('#icheckoutdivr_hotelname').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivr_roomnumber').addClass('checkoutdivr off-02');
      $('#icheckoutdivr_roomnumber').removeClass('checkoutdivr_nodisplay');
      break;
    case 'office':
      $('#icheckoutdivr_roomnumber').addClass('checkoutdivr');
      $('#icheckoutdivr_roomnumber').removeClass('off-02 checkoutdivr_nodisplay');

      $('#icheckoutdivr_buildingname').addClass('checkoutdivr');
      $('#icheckoutdivr_buildingname').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivr_floor').addClass('off-02 checkoutdivr');
      $('#icheckoutdivr_floor').removeClass('checkoutdivr_nodisplay');

      break;
    case 'compound':
      $('#icheckoutdivr_compoundname').addClass('checkoutdivr');
      $('#icheckoutdivr_compoundname').removeClass('checkoutdivr_nodisplay');

      $('#icheckoutdivr_addressatcompound').addClass('off-02 checkoutdivr');
      $('#icheckoutdivr_addressatcompound').removeClass('checkoutdivr_nodisplay');

      break;
    case 'house':
    default:
      break;
  }
}

function toggleOwnCharacteristics(costcentervalue) {
  var elt = document.getElementById('ibusinessreference');
  if (elt) {
    if (costcentervalue == '') {
      elt.className = 'businessreference';
    } else {
      elt.className = 'businessreference_nodisplay';
    }
  }
}

var checkIfPaymentMethodIsVisible = function checkIfPaymentMethodIsVisible(selector, id) {
  return Array.from(document.querySelectorAll(selector)).filter(function (option) {
    return option.value === id && window.getComputedStyle(option).display !== 'none';
  }).length > 0;
};

var checkIfPaymentMethodIsAvailable = function checkIfPaymentMethodIsAvailable(id) {
  return checkIfPaymentMethodIsVisible('#ipaymentmethods > .paymentbuttonwrapper', id) || checkIfPaymentMethodIsVisible('#iselectpayment option', id);
};

/**
 * This code was first in PaymentOptions.phtml.
 */
function selectFirstPossiblePaymentMethod() {
  // get first possible paymentmethod
  // then, select proper elements on checkout page for visual

  var paymentId = null;

  for (var paymentMethod in currentRestaurant.Settings.PaymentMethods) {
    if (currentRestaurant.Settings.PaymentMethods.hasOwnProperty(paymentMethod) && typeof paymentMethod.id !== 'undefined' && checkIfPaymentMethodIsAvailable(paymentMethod.id)) {
      paymentId = paymentMethod.id;
      break;
    }
  }

  if (paymentId === null) {
    paymentId = currentRestaurant.Settings.PaymentMethods[0].id;
  }

  $('.paymentbuttonwrapper', '#ipaymentmethods').each(function (index, el) {
    $(this).removeClass('paymentbuttonchecked');
    if (index === 0) {
      $(this).addClass('paymentbuttonchecked').find('input').prop('checked', true);
    }
  });

  $('#iselectpayment').val(paymentId);
  basket.setPaymentMethod(paymentId);
}

function selectPaymentMethodById(id) {
  $('.paymentbuttonwrapper', '#ipaymentmethods').each(function (index, el) {
    $(this).removeClass('paymentbuttonchecked');
    if (id === $(el).find('input').val()) {
      $(this).addClass('paymentbuttonchecked').find('input').prop('checked', true);
    }
  });

  $('#iselectpayment').val(id);
  basket.setPaymentMethod(id);
}

$(document).ready(function () {
  var initialValue = {};
  if ($('body').hasClass('step4')) {
    var first = $('input:text, textarea', '.orderdetails-checkout').first();
    var mandatory = $('input:text.marked, textarea.marked', '.orderdetails-checkout');
    if (mandatory.length === 0 && first.val() == '') {
      $(first).focus();
    } else {
      $(mandatory).first().focus();
    }

    $(document).on('keypress', 'input', function (e) {
      var code = e.keyCode || e.which;

      if (e.target.id === 'iaddress' && typeof initialValue.iaddress === 'undefined') {
        initialValue.iaddress = e.target.value;
      }

      if (code === 13) {
        e.preventDefault();
        return false;
      }
    });
  }

  // Save and Delete remarks
  $(document).on('submit', '#checkoutform', function (ev) {
    if ($('#isaveremarks').prop('checked')) {
      var value = $('#iremarks').val();
      if (value !== '') {
        Cookies.set('orderRemarks', value, { expires: 365, path: '/', secure: true });
      }
    } else {
      if (Cookies.getJSON().orderRemarks) {
        Cookies.remove('orderRemarks', { path: '/' });
      }
    }
  });

  $(document).on('change', '#iselectpayment', function () {
    $('.paymentmethod' + $(this).val()).click().find('input').click();
  });

  $(document).on('click', '.paymentbuttonwrapper', function (event) {
    event.preventDefault();
    event.stopPropagation();

    $('.paymentbuttonwrapper', '#ipayments').each(function (index, value) {
      $(this).removeClass('paymentbuttonchecked');
    });
    $(this).addClass('paymentbuttonchecked');
    // $('input',$(this)).attr('checked','checked');
    $('input', $(this)).prop('checked', true);

    var paymentId = $(this).find('input').val();
    $('#iselectpayment').val(paymentId);
    basket.setPaymentMethod(paymentId);
  });

  $(document).on('click', '#iaddress', function () {
    window.app.services.tracking.send({
      onlyTrackOnce: true,
      eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_CLICKED_FIELD_FORM,
      eventData: {
        fieldName: 'address'
      }
    });
  });

  var isModifiedEventSent = false;
  $(document).on('blur', '#iaddress', function () {
    if ($(this).hasClass('nohousenumber')) return false;

    var val = this.value;

    if (val && typeof initialValue.iaddress !== 'undefined' && val !== initialValue.iaddress && !isModifiedEventSent) {
      window.app.services.tracking.send({
        onlyTrackOnce: true,
        eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_MODIFIED_FIELD_IN_FORM,
        eventData: {
          fieldName: 'address'
        }
      });
      isModifiedEventSent = true;
    }

    if (val != '') {
      if (val.match(/\d+/g) == null) {
        $(this).addClass('marked');
        $('#iaddressnotice').fadeIn();
      } else {
        $('#iaddressnotice').fadeOut();
        $(this).removeClass('marked');
      }
    }
  });

  if (window.sessionStorage) {
    $(document).on('change', '#iidealbank', function () {
      var selectedBank = $('#iidealbank :selected');
      var selectedBankVal = selectedBank.val();

      sessionStorage.setItem('selectBankVal', selectedBankVal);
    });
  }
});

$.when($.ready).then(function () {
  if (!$(document.body).hasClass('step4')) {
    return;
  }
  var e = $('#ideliverytime, #ipickuptime')[0];
  if (e.options.selectedIndex === -1) {
    return;
  }
  var selectedTime = e.options[e.options.selectedIndex];
  basket.validateDeliveryTime(selectedTime.value);
});

$(document).on('change', '#ideliverytime, #ipickuptime', function (e) {
  var selectedTime = e.target.options[e.target.options.selectedIndex];
  basket.validateDeliveryTime(selectedTime.value);
});

var hasClicked = false;

/* BEGIN When modifying these functions, check with checkIfPaymentMethodIsAvailable() method too */
function hideOfflinePaymentMethods() {
  $('.paymentdetailnormal').hide();
  $('.payment-method-type-offline').hide();
  $('.js-choose-payment-header').hide();
  switchDropdownVisibility($('option.payment-method-type-offline'), false);
}

function showOfflinePaymentMethods() {
  $('.paymentdetailnormal').show();
  $('.js-choose-payment-header').show();
  switchDropdownVisibility($('option.payment-method-type-offline'), true);
}

function hideOnlinePaymentMethods() {
  $('.payment-method-type-online').hide();
  $('.payment-type-online').hide();
  $('.js-choose-payment-header').hide();
  switchDropdownVisibility($('option.payment-method-type-online'), false);
}

function showOnlinePaymentMethods() {
  $('#ipaymentmethodsmobile').removeClass('hidden');
  $('.payment-method-type-online').show();
  $('.js-choose-payment-header').show();
  switchDropdownVisibility($('option.payment-method-type-online'), true);
}

function showOnlinePaymentMethodsExceptBusiness() {
  $('#ipaymentmethodsmobile').removeClass('hidden');
  $('.payment-method-type-online').not('js-payment-method-business').show();
  $('.js-choose-payment-header').show();
  switchDropdownVisibility($('option.payment-method-type-online').not('option.js-payment-method-business'), true);
  $('.paymentmethod7').hide();
  switchDropdownVisibility($('option.js-payment-method-business'), false);
}

function hideAllPaymentMethods() {
  $('#ipaymentmethodsmobile').addClass('hidden');
  $('.paymentbuttonwrapper').hide();
  $('.paymentdetailnormal').hide();
  $('.payment-type-online').hide();
  $('.js-choose-payment-header').hide();
}

function showAllPaymentMethods() {
  $('#ipaymentmethodsmobile').removeClass('hidden');
  $('.paymentbuttonwrapper').show();
  $('.js-choose-payment-header').show();
  switchDropdownVisibility($('option.payment-method-type-online'), true);
  switchDropdownVisibility($('option.payment-method-type-offline'), true);
}

function switchDropdownVisibility(element, visible) {
  if (visible) {
    element.show();
    element.filter('span > option').unwrap();
  } else {
    element.hide();
    element.filter(':not(span > option)').wrap('<span>').parent().hide();
  }

  return this;
}
/* END When modifying these functions, check with checkIfPaymentMethodIsAvailable() method too */

function clickSubmitbuttonOnce(buttoninput) {
  if (window.app.services.headerService.pickupDisabled(Pickup.isPickupStatus())) {
    return;
  }

  $('.meal-error-mismatching').hide();
  $('.meal-error-missing').hide();

  if (hasClicked) {
    return false;
  } else {
    hasClicked = true;
    updateAddressIfExists();
    if ($(buttoninput).hasClass('button_form')) {
      $(buttoninput).addClass('button_form_disabled');

      var $checkout = $('#checkoutform');

      $('#basketJson').remove();
      var basketJson = basket.getBasketJson();
      console.log('baSket', $checkout);
      var input = $('<input>').attr('id', 'basketJson').attr('type', 'hidden').attr('name', 'basket').val(basketJson);

      var optInChecked = $('#inewsletter').prop('checked');
      // opt-in GA Tracking
      if (optInChecked === true) {
        window.app.services.tracking.send({
          eventName: window.app.enums.TRACKING_EVENT_NAMES.HAS_OPTED_IN_NEWSLETTER_CHECKOUT
        });
      }

      // Hacky fix for checkout newsletter, as due to the Business Form (form inside form), every input after the
      // closing of that form, is not being fetched by jQuery submit.
      var $newCheck = $('<input>').attr('type', 'checkbox').attr('name', 'newsletter').attr('value', '1').prop('checked', optInChecked);
      $checkout.append($newCheck);
      $checkout.append($(input));
      if (parseInt(site.cc) === 8 && localStorage.SelectedAddress && JSON.parse(localStorage.SelectedAddress).postal_code) {
        $checkout.append($('<input>').attr('type', 'hidden').attr('name', 'postcode').val(JSON.parse(localStorage.SelectedAddress).postal_code));
      }

      $checkout.submit();
    }
  }
  return false;
}
/*
  global
  Helper,
  userpanel,
  Cookies,
*/
var TakeawayPay = function () {

  var userPanelSelector = '#userpanel';

  function getUserPanel() {
    return document.querySelector(userPanelSelector);
  }

  function getAddressFromLocalStorage(jsonFromSelectedCity) {
    var postalCode = jsonFromSelectedCity.postal_code;
    var locality = jsonFromSelectedCity.locality;
    var country = jsonFromSelectedCity.country;
    var route = jsonFromSelectedCity.route; // In NL this contains the streetname

    var streetNumber = jsonFromSelectedCity.street_number;

    var addressParts = [];

    if (typeof route !== 'undefined' && route.length > 0) {
      var streetParts = [];

      streetParts.push(route);

      if (typeof streetNumber !== 'undefined' && streetNumber.length > 0) {
        streetParts.push(streetNumber);
      }

      addressParts.push(streetParts.join(' '));
    }

    if (typeof postalCode !== 'undefined' && postalCode.length > 0) {
      addressParts.push(postalCode);
    }

    if (typeof locality !== 'undefined' && locality.length > 0) {
      addressParts.push(locality);
    }

    if (typeof country !== 'undefined' && country.length > 0) {
      addressParts.push(country);
    }

    return addressParts.join(', ');
  }

  function saveSelectedAddressesToUrl(selectedAddresses, currentLocation, locationSlug) {
    selectedAddresses[currentLocation.toString()] = locationSlug;
    window.localStorage.setItem('SelectedAddressesToUrl', JSON.stringify(selectedAddresses));
  }

  function initClickOnUserPanel() {
    var userPanel = getUserPanel();
    var takeawayPayLink = userPanel.querySelector('.js-takeaway-pay-link');
    if (takeawayPayLink) {
      // We need to check if there is a Takeaway Pay allowance
      // This is stored inside the span with class `.right-part` and `.js-takeaway-pay-menu-amount`
      takeawayPayLink.addEventListener('click', function (event) {
        var takeawayPayAllowance = takeawayPayLink.querySelector('.right-part .js-takeaway-pay-menu-amount');

        // If we have no allowance, do nothing
        if (takeawayPayAllowance === null || takeawayPayAllowance.innerHTML.trim().length === 0) {
          return;
        }

        var isFeatureToggleActive = window.app.services.feature.isActive('takeawayPayOverviewRedirect');
        if (isFeatureToggleActive === false) {
          return;
        }

        event.preventDefault();

        setTrafficRLCookie();

        handleClickOnTakeawayPayLink(function (slug) {
          // redirect
          var urlPath = window.site.local + '/' + window.site.foodRoute + '/' + slug + '#takeawaypayoverview';
          window.location.href = 'https://' + window.site.domain + urlPath.replace('//', '/');
        }, function () {
          window.location.href = takeawayPayLink.href;
        });
      });
    }
  }

  function setTrafficRLCookie() {
    var isFeatureToggleActive = window.app.services.feature.isActive('forceTrafficRLCookie');
    if (isFeatureToggleActive === false) {
      return;
    }

    if (!Cookies.get('traffic_rl') || Cookies.get('traffic_rl') !== 3) {
      Cookies.set('traffic_rl', 3, { expires: 0.5, path: '/', secure: false });
    }
  }

  function handleClickOnTakeawayPayLink(cbLocationFound, cbDefault) {
    // 1. Get current address from Storage
    // 2. If no address - do nothing
    // 3. If there is an address, check if we have cached the slug for that in localstorage
    // 4. If present in localstorage, redirect user
    // 5. If not present, fire api call
    // 6. Cache response in localstorage
    // 7. Redirect user

    var localStorageSelectedAddress = window.app.services.localStorageService.getObjectFromLocalStorage('SelectedAddress');

    var addressFromStorage = getAddressFromLocalStorage(localStorageSelectedAddress);

    if (addressFromStorage.trim().length === 0) {
      var localStorageSelectedCity = window.app.services.localStorageService.getObjectFromLocalStorage('SelectedCity');

      addressFromStorage = getAddressFromLocalStorage(localStorageSelectedCity);
    }

    if (addressFromStorage.trim().length === 0) {
      cbDefault();
    }

    var uriEncoded = encodeURIComponent(addressFromStorage);

    var addressesCached = window.app.services.localStorageService.getObjectFromLocalStorage('SelectedAddressesToUrl');

    if (typeof addressesCached[uriEncoded] !== 'undefined') {
      cbLocationFound(addressesCached[uriEncoded]);
    }

    var options = {
      headers: {
        'Accept-Language': site.language,
        'X-Country-Code': site.iso.toLowerCase()
      }
    };

    window.axios.get(site.cwApi + 'api/v27/location/geocoder?addressString=' + uriEncoded, options).then(function (response) {
      if (response.status !== 200) {
        cbDefault();
      }

      var addresses = response.data.addresses;

      if (!Array.isArray(addresses) || addresses.length === 0) {
        cbDefault();
      }

      var slug = addresses[0].locationSlug;
      saveSelectedAddressesToUrl(addressesCached, uriEncoded, slug);

      cbLocationFound(slug);
    }).catch(function () {
      cbDefault();
    });
  }

  return {
    initClickOnUserPanel: initClickOnUserPanel
  };
}();
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global addTracker, GtmTracker, tracker */
/**
 * @author Ka Wing Chin (kawing.chin@takeaway.com)
 */

/**
 * @namespace TakeawayTracker
 */
var TakeawayTracker = TakeawayTracker || {};

/**
 * @class Observer
 */
TakeawayTracker.Observer = function () {
  var subscribers = new Array();
  /**
   * Constructor
   */
  function Observer() {}

  Observer.subscribe = function (tracker) {
    if (tracker instanceof TakeawayTracker.TrackerAbstract === false) {
      throw new Error('Not instance of TakeawayTracker!');
    }
    subscribers.push(tracker);
  };

  Observer.unsubscribe = function (tracker) {
    for (var i = 0; i < subscribers.length; i++) {
      if (subscribers[i] === tracker) {
        subscribers.splice(i, 1);
        break;
      }
    }
  };

  Observer.publish = function (action, data) {
    if (typeof action !== 'string') {
      throw new Error(action + ' must be string');
    }

    if (data !== undefined && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      throw new Error(action + ' must be object literal');
    }

    for (var i = 0; i < subscribers.length; i++) {
      subscribers[i][action](data);
    }
  };

  return Observer;
}();

/**
 * @author Ka Wing Chin (kawing.chin@takeaway.com)
 */

/**
 * @class TakeawayTracker.TrackerAbstract
 * This is an abstract class.
 */
TakeawayTracker.TrackerAbstract = function () {
  /**
   * The actual tracker object.
   */
  this.tracker = undefined;

  /**
   * Constructor
   */
  function TrackerAbstract() {}

  /**
   * Add the actual tracker
   * @param {object} tracker
   */
  this.addTracker = function (tracker) {
    this.tracker = tracker;
  };

  TrackerAbstract.prototype.trackPageView = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackHasRestaurant = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackAddedRestaurantToWishList = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackAddedRestaurantReview = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackVoucherError = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackViewedRestaurantTab = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackChangedLanguage = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackChangedCountry = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackSubscribedNewsLetter = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackUnsubscribedNewsLetter = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackSearch = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackClickedOnSearchResult = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackHasAcceptedCookies = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackClickedLogo = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackViewedCookiePopup = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackViewedExtraCookieInfo = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackViewedPopupScreen = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackFormError = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackSearchError = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackSubmittedVoucher = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackPreviewedNewsLetter = function (data) {
    throw new Error('Abstract method');
  };

  TrackerAbstract.prototype.trackCheckoutOption = function (data) {
    throw new Error('Abstract method');
  };

  return TrackerAbstract;
}();

/**
 * @author Ka Wing Chin (kawing.chin@takeaway.com)
 */

/**
 * @class TakeawayTracker.Tracker
 */
TakeawayTracker.Tracker = function () {
  Tracker.prototype = Object.create(TakeawayTracker.TrackerAbstract.prototype);
  Tracker.constructor = Tracker;

  /**
   * Events that needs to be fired when page got loaded while tealium controller is not loaded
   * yet will be placed in a queue.
   */
  var queue = [];
  /**
   * @type {object} literal which contains the page data and failed id.
   */
  var trackerData;

  /**
   * Constructor
   * @param {object} the data that is needed for tracking the current viewed page.
   */
  function Tracker(data) {
    // tealiumData
    trackerData = data;
    TakeawayTracker.TrackerAbstract.call(this);
    if (typeof window.dataLayer !== 'undefined' && typeof window.dataLayer.push === 'function') {
      gtmLoadedHandler.call(this);
    }
  }

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing.
   */
  var debounce = function debounce(func, wait, immediate) {
    var timeout;
    return function () {
      var context = this;var args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  };

  var gtmLoadedHandler = debounce(function () {
    addTracker(GtmTracker);
    this.trackPageView(trackerData);
    if (_typeof(window.OrderConfirmationCheck) === 'object' && typeof window.OrderConfirmationCheck.setTrackerReached === 'function') {
      window.OrderConfirmationCheck.setTrackerReached(true);
    }
    var length = queue.length;
    for (var i = 0; i < length; i++) {
      var q = queue[i];
      this[q.action](q.data);
    }
    queue = [];
  }, 500, false);

  Tracker.prototype.trackPageView = function (data) {
    //tracker.data.userData = data.customer
    //tracker.data.businessData = data.business
    //tracker.data.restaurantData = data.restaurant
    //tracker.data.pageData = data.pagedata
    //tracker.data.allowtracking = data.allowtracking
    //tracker.data.transactionData = setTransactionData(data.transactiondata)

    var tmsData = {
      userData: data.customer,
      businessData: data.business,
      restaurantData: data.restaurant,
      pageData: data.pagedata,
      allowtracking: data.allowtracking,
      transactionData: setTransactionData(data.transactiondata)
    };

    window.dataLayer.push({
      'event': 'Pageview',
      'tms_data': tmsData
    });
  };

  Tracker.prototype.trackHasRestaurant = function (data) {
    window.dataLayer.push({ 'event': 'hasRestaurant', 'tms_data': { hasRestaurant: 'True' } });
    Tracker.trackPageview(data);

    //tracker.data.hasRestaurant = 'True'
    //tracker.trackPageview()
  };

  Tracker.prototype.trackAddedRestaurantToWishList = function (data) {
    window.dataLayer.push({ 'event': 'restaurantAddToWishlist' });
    //tracker.trackEvent('restaurantAddToWishlist')
  };

  Tracker.prototype.trackAddedRestaurantReview = function (data) {
    var tmsData = {
      reviewAddingStarsDelivery: data.delivery,
      reviewAddingStarsQuality: data.quality
    };

    window.dataLayer.push({ 'event': 'restaurantReviewAdded', 'tms_data': tmsData });

    //tracker.data.reviewData = {
    //  reviewAddingStarsDelivery: data.delivery,
    //  reviewAddingStarsQuality: data.quality
    //}
    //tracker.trackEvent('restaurantReviewAdded')
  };

  Tracker.prototype.trackVoucherError = function (data) {
    window.dataLayer.push({
      'event': 'hasVoucherError',
      'tms_data': { voucherErrorType: data.voucherError }
    });

    //tracker.data.voucherData = { voucherErrorType: data.voucherError }
    //tracker.trackEvent('hasVoucherError')
  };

  Tracker.prototype.trackViewedRestaurantTab = function (data) {
    if (addToQueue('trackViewedRestaurantTab', data)) return;
    window.dataLayer.push({
      'event': 'restaurantTabViewed',
      'tms_data': { restaurantTab: data.restaurantTab }
    });

    //tracker.data.restaurantData = { restaurantTab: data.restaurantTab }
    //tracker.trackEvent('restaurantTabViewed')
  };

  Tracker.prototype.trackChangedLanguage = function (data) {};

  Tracker.prototype.trackChangedCountry = function (data) {};

  Tracker.prototype.trackViewedCookiePopup = function (data) {
    window.dataLayer.push({
      event: 'hasViewedCookiePopup',
      tms_data: { hasViewedCookiePopup: data.hasViewedCookiePopup }
    });
  };

  Tracker.prototype.trackHasAcceptedCookies = function (data) {
    window.dataLayer.push({ 'event': 'hasAcceptedCookies' });
  };

  Tracker.prototype.trackViewedExtraCookieInfo = function (data) {
    window.dataLayer.push({ 'event': 'hasViewedExtraCookieInfo' });
  };

  Tracker.prototype.trackSubscribedNewsLetter = function (data) {
    window.dataLayer.push({ 'event': 'hasSubscribedToNewsletter' });
  };

  Tracker.prototype.trackUnsubscribedNewsLetter = function (data) {
    window.dataLayer.push({ 'event': 'hasUnsubscribedToNewsletter' });
  };

  Tracker.prototype.trackViewedPopupScreen = function (data) {};

  Tracker.prototype.trackFormError = function (data) {
    var tmsData = {
      formErrorType: data.formErrorType !== undefined ? data.formErrorType : null,
      formName: data.formName !== undefined ? data.formName : null
    };

    window.dataLayer.push({ event: 'hasFormError', tms_data: tmsData });
  };

  Tracker.prototype.trackSearch = function (data) {
    if (addToQueue('trackSearch', data)) return;
    window.dataLayer.push({
      event: 'hasSearched',
      tms_data: { searchData: validateSearchData(data) }
    });
  };

  Tracker.prototype.trackSearchError = function (data) {
    window.dataLayer.push({
      event: 'hasSearchError',
      tms_data: { searchData: validateSearchData(data) }
    });
  };

  Tracker.prototype.trackCheckoutOption = function (data) {};

  var addToQueue = function addToQueue(action, data) {
    if (tracker === undefined) {
      queue.push({ action: action, data: data });
      return true;
    }
    return false;
  };

  var validateSearchData = function validateSearchData(data) {
    return {
      searchInterface: data.searchInterface !== undefined ? data.searchInterface : null,
      searchKeyword: data.searchKeyword !== undefined ? data.searchKeyword : null,
      searchMainCategory: data.searchMainCategory !== undefined ? data.searchMainCategory : null,
      searchNumberOfResults: data.searchNumberOfResults !== undefined ? data.searchNumberOfResults : null,
      searchSortOrder: data.searchSortOrder !== undefined ? data.searchSortOrder : null,
      searchViewtype: data.searchViewtype !== undefined ? data.searchViewtype : null,
      searchZipcode: data.searchZipcode !== undefined ? data.searchZipcode : null
    };
  };

  var setTransactionData = function setTransactionData(data) {
    var sessionStorageSupport = typeof window.sessionStorage !== 'undefined';
    var latestTransactionId = sessionStorageSupport && window.sessionStorage.getItem('transactionId') || null;
    if (!data.transactionID || latestTransactionId === data.transactionID) {
      return false;
    }
    if (sessionStorageSupport) {
      window.sessionStorage.setItem('transactionId', data.transactionID);
    }
    return data;
  };

  return Tracker;
}();
//# sourceMappingURL=takeaway.js.map